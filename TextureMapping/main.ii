# 1 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp"
# 1 "/home/joe/Github_Repos/opengl-projects/TextureMapping//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp"




# 1 "/usr/include/c++/4.8/iostream" 1 3
# 36 "/usr/include/c++/4.8/iostream" 3
       
# 37 "/usr/include/c++/4.8/iostream" 3

# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 1 3
# 184 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 426 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/os_defines.h" 2 3
# 427 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/cpu_defines.h" 1 3
# 430 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h" 2 3
# 39 "/usr/include/c++/4.8/iostream" 2 3
# 1 "/usr/include/c++/4.8/ostream" 1 3
# 36 "/usr/include/c++/4.8/ostream" 3
       
# 37 "/usr/include/c++/4.8/ostream" 3

# 1 "/usr/include/c++/4.8/ios" 1 3
# 36 "/usr/include/c++/4.8/ios" 3
       
# 37 "/usr/include/c++/4.8/ios" 3

# 1 "/usr/include/c++/4.8/iosfwd" 1 3
# 36 "/usr/include/c++/4.8/iosfwd" 3
       
# 37 "/usr/include/c++/4.8/iosfwd" 3


# 1 "/usr/include/c++/4.8/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/4.8/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/4.8/bits/stringfwd.h" 3


# 1 "/usr/include/c++/4.8/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/4.8/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/4.8/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/4.8/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 41 "/usr/include/c++/4.8/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/include/c++/4.8/iosfwd" 2 3
# 1 "/usr/include/c++/4.8/bits/postypes.h" 1 3
# 38 "/usr/include/c++/4.8/bits/postypes.h" 3
       
# 39 "/usr/include/c++/4.8/bits/postypes.h" 3

# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 36 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/stdio.h" 1 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 37 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 40 "/usr/include/wchar.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 42 "/usr/include/wchar.h" 2 3 4
# 51 "/usr/include/wchar.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 353 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef unsigned int wint_t;
# 52 "/usr/include/wchar.h" 2 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






# 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();



# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 181 "/usr/include/wchar.h" 2 3 4

extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
# 306 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();

# 405 "/usr/include/wchar.h" 3 4



extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
# 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
# 680 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
# 736 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

# 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
# 891 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 62 "/usr/include/c++/4.8/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/4.8/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 232 "/usr/include/c++/4.8/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "/usr/include/c++/4.8/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "/usr/include/c++/4.8/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/4.8/bits/postypes.h" 2 3
# 68 "/usr/include/c++/4.8/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/4.8/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/4.8/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/4.8/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/4.8/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/4.8/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/4.8/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/exception" 1 3
# 33 "/usr/include/c++/4.8/exception" 3
       
# 34 "/usr/include/c++/4.8/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 1 3
# 33 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
       
# 34 "/usr/include/c++/4.8/bits/atomic_lockfree_defines.h" 3
# 39 "/usr/include/c++/4.8/exception" 2 3

extern "C++" {

namespace std
{
# 60 "/usr/include/c++/4.8/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  void unexpected() __attribute__ ((__noreturn__));
# 117 "/usr/include/c++/4.8/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 142 "/usr/include/c++/4.8/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/4.8/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/4.8/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/4.8/bits/exception_ptr.h" 2 3





extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 111 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 138 "/usr/include/c++/4.8/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    {
      try
 {

   throw __ex;

 }
      catch(...)
 {
   return current_exception();
 }
    }




  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    { return std::copy_exception<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 153 "/usr/include/c++/4.8/exception" 2 3
# 1 "/usr/include/c++/4.8/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/4.8/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "/usr/include/c++/4.8/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception() noexcept;

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 154 "/usr/include/c++/4.8/exception" 2 3
# 40 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/4.8/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/4.8/bits/char_traits.h" 3

# 1 "/usr/include/c++/4.8/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/4.8/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/4.8/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
# 68 "/usr/include/c++/4.8/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 62 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 63 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/4.8/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/4.8/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_pair.h" 1 3
# 59 "/usr/include/c++/4.8/bits/stl_pair.h" 3
# 1 "/usr/include/c++/4.8/bits/move.h" 1 3
# 34 "/usr/include/c++/4.8/bits/move.h" 3
# 1 "/usr/include/c++/4.8/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/4.8/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/4.8/bits/concept_check.h" 3
# 35 "/usr/include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "/usr/include/c++/4.8/type_traits" 1 3
# 32 "/usr/include/c++/4.8/type_traits" 3
       
# 33 "/usr/include/c++/4.8/type_traits" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() { return value; }
    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };

  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 245 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 274 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename>
    struct __is_nullptr_t_helper
    : public false_type { };

  template<>
    struct __is_nullptr_t_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public integral_constant<bool, (__is_nullptr_t_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };


  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public integral_constant<bool, (__is_nt_destructible_safe<_Tp>::value)>
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public integral_constant<bool, (__is_default_constructible_safe<
          _Tp>::value)>
    { };
# 765 "/usr/include/c++/4.8/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public integral_constant<bool, (__is_direct_constructible_new<
          _Tp, _Arg>::value)>
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool, (__is_constructible_impl<_Tp,
          _Args...>::value)>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Up1>
        static decltype(declval<_Tp1>() = declval<_Up1>(), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_Tp, _Up>(0)) == 1;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public integral_constant<bool,
                               __is_assignable_helper<_Tp, _Up>::value>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = is_void<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };
# 1203 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { static constexpr bool value = is_void<_To>::value; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      template<typename _To1>
        static void __test_aux(_To1);

      template<typename _From1, typename _To1>
        static decltype(__test_aux<_To1>(std::declval<_From1>()), __one())
 __test(int);

      template<typename, typename>
        static __two __test(...);

    public:
      static constexpr bool value = sizeof(__test<_From, _To>(0)) == 1;
    };


  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::value>
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp,
    bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp,
           bool = __and_<__not_<is_reference<_Tp>>,
                         __not_<is_void<_Tp>>>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1492 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
# 1574 "/usr/include/c++/4.8/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1691 "/usr/include/c++/4.8/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;




  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };
# 2069 "/usr/include/c++/4.8/type_traits" 3

}
# 58 "/usr/include/c++/4.8/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



}
# 149 "/usr/include/c++/4.8/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 164 "/usr/include/c++/4.8/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "/usr/include/c++/4.8/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
# 95 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 273 "/usr/include/c++/4.8/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 292 "/usr/include/c++/4.8/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 142 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper : __sfinae_types { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static __one __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static __two __test(...); public: static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; }; template<typename _Tp> struct __has_iterator_category : integral_constant<bool, __has_iterator_category_helper <typename remove_cv<_Tp>::type>::value> { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 174 "/usr/include/c++/4.8/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3


# 1 "/usr/include/c++/4.8/debug/debug.h" 1 3
# 46 "/usr/include/c++/4.8/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/4.8/bits/stl_iterator.h" 1 3
# 67 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 95 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 159 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 289 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 401 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 435 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 477 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 492 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 525 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 567 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 586 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 637 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 681 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 705 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
# 803 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 929 "/usr/include/c++/4.8/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}
# 68 "/usr/include/c++/4.8/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 117 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 147 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 163 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 191 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 214 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 237 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 258 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 448 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 481 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 617 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 653 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 719 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 779 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
# 941 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1019 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1051 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1082 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1118 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
# 1158 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1195 "/usr/include/c++/4.8/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
# 40 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 42 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "/usr/include/c++/4.8/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "/usr/include/c++/4.8/cstdint" 1 3
# 32 "/usr/include/c++/4.8/cstdint" 3
       
# 33 "/usr/include/c++/4.8/cstdint" 3
# 41 "/usr/include/c++/4.8/cstdint" 3
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 27 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 36 "/usr/include/stdint.h" 3 4
typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;







typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h" 2 3 4
# 42 "/usr/include/c++/4.8/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 377 "/usr/include/c++/4.8/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/4.8/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/4.8/bits/localefwd.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 1 3
# 39 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 3
       
# 40 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 3

# 1 "/usr/include/c++/4.8/clocale" 1 3
# 39 "/usr/include/c++/4.8/clocale" 3
       
# 40 "/usr/include/c++/4.8/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 50 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 120 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


# 151 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
# 186 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
# 43 "/usr/include/c++/4.8/clocale" 2 3
# 51 "/usr/include/c++/4.8/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/4.8/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/4.8/cctype" 1 3
# 39 "/usr/include/c++/4.8/cctype" 3
       
# 40 "/usr/include/c++/4.8/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 26 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 27 "/usr/include/ctype.h" 2 3 4

extern "C" {
# 39 "/usr/include/ctype.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 40 "/usr/include/ctype.h" 2 3 4






enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
# 104 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
# 347 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/4.8/cctype" 2 3
# 62 "/usr/include/c++/4.8/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "/usr/include/c++/4.8/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/4.8/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 42 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/4.8/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/4.8/bits/ios_base.h" 3

# 1 "/usr/include/c++/4.8/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/4.8/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/4.8/ext/atomicity.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 1 3
# 30 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 23 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 28 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 29 "/usr/include/sched.h" 2 3 4



# 1 "/usr/include/time.h" 1 3 4
# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 33 "/usr/include/sched.h" 2 3 4


typedef __pid_t pid_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 72 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
# 118 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 201 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
# 42 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
# 116 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
# 24 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
extern "C" {







# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
# 42 "/usr/include/time.h" 2 3 4
# 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 25 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 27 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 125 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 166 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 201 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 239 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
# 505 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 517 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 551 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 753 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
# 899 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1011 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
# 1055 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
# 1122 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
# 1170 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 2 3
# 47 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
# 236 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
# 246 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 658 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 807 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/4.8/ext/atomicity.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/atomic_word.h" 1 3
# 32 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/4.8/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/4.8/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "/usr/include/c++/4.8/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/4.8/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_classes.h" 3


# 1 "/usr/include/c++/4.8/string" 1 3
# 36 "/usr/include/c++/4.8/string" 3
       
# 37 "/usr/include/c++/4.8/string" 3




# 1 "/usr/include/c++/4.8/bits/allocator.h" 1 3
# 46 "/usr/include/c++/4.8/bits/allocator.h" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 1 3
# 33 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 3
# 1 "/usr/include/c++/4.8/ext/new_allocator.h" 1 3
# 33 "/usr/include/c++/4.8/ext/new_allocator.h" 3
# 1 "/usr/include/c++/4.8/new" 1 3
# 37 "/usr/include/c++/4.8/new" 3
       
# 38 "/usr/include/c++/4.8/new" 3




#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
# 91 "/usr/include/c++/4.8/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "/usr/include/c++/4.8/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "/usr/include/c++/4.8/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "/usr/include/c++/4.8/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/4.8/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

    };
# 91 "/usr/include/c++/4.8/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c)
      {
 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }
      }
    };



}
# 42 "/usr/include/c++/4.8/string" 2 3


# 1 "/usr/include/c++/4.8/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/4.8/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/4.8/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/4.8/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/4.8/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/4.8/string" 2 3



# 1 "/usr/include/c++/4.8/bits/stl_function.h" 1 3
# 59 "/usr/include/c++/4.8/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 100 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 139 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 203 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 267 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
# 350 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 421 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 541 "/usr/include/c++/4.8/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/4.8/backward/binders.h" 1 3
# 59 "/usr/include/c++/4.8/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 103 "/usr/include/c++/4.8/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 732 "/usr/include/c++/4.8/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/4.8/string" 2 3


# 1 "/usr/include/c++/4.8/bits/range_access.h" 1 3
# 33 "/usr/include/c++/4.8/bits/range_access.h" 3
       
# 34 "/usr/include/c++/4.8/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 52 "/usr/include/c++/4.8/string" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/4.8/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/4.8/bits/basic_string.h" 3




# 1 "/usr/include/c++/4.8/initializer_list" 1 3
# 33 "/usr/include/c++/4.8/initializer_list" 3
       
# 34 "/usr/include/c++/4.8/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 43 "/usr/include/c++/4.8/bits/basic_string.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 111 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "/usr/include/c++/4.8/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "/usr/include/c++/4.8/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 483 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 507 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 531 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string() noexcept
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 564 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 579 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_rep()->_M_length; }



      size_type
      length() const noexcept
      { return _M_rep()->_M_length; }


      size_type
      max_size() const noexcept
      { return _Rep::_S_max_size; }
# 739 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 752 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit()
      {
 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }
      }






      size_type
      capacity() const noexcept
      { return _M_rep()->_M_capacity; }
# 796 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 825 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
# 842 "/usr/include/c++/4.8/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 863 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
# 882 "/usr/include/c++/4.8/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const
      { return operator[](this->size() - 1); }
# 931 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 988 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1020 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1042 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1078 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1099 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1115 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1127 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1143 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1155 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1184 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1200 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1212 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1232 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1254 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1277 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1295 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1318 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1336 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1361 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1377 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1397 "/usr/include/c++/4.8/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);







      void
      pop_back()
      { erase(size()-1, 1); }
# 1428 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1450 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1475 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1495 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1519 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1537 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1556 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1577 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1598 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1621 "/usr/include/c++/4.8/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1692 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1779 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1789 "/usr/include/c++/4.8/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1799 "/usr/include/c++/4.8/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_dataplus; }
# 1832 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1845 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 1860 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1877 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 1890 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1907 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1920 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1937 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 1951 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1968 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 1981 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2000 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2015 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2032 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2045 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2064 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2078 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2095 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2109 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2126 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2141 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2158 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2172 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2189 "/usr/include/c++/4.8/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2205 "/usr/include/c++/4.8/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2224 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2256 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2282 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2300 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2324 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2351 "/usr/include/c++/4.8/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2363 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2484 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2530 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2567 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2604 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2641 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2678 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2715 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2733 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2751 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2774 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2791 "/usr/include/c++/4.8/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}




# 1 "/usr/include/c++/4.8/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/4.8/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/4.8/ext/string_conversions.h" 3
# 41 "/usr/include/c++/4.8/ext/string_conversions.h" 3
# 1 "/usr/include/c++/4.8/cstdlib" 1 3
# 39 "/usr/include/c++/4.8/cstdlib" 3
       
# 40 "/usr/include/c++/4.8/cstdlib" 3
# 72 "/usr/include/c++/4.8/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

# 239 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 104 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 136 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 200 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;







# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 54 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern "C" {
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
}
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));
# 58 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 262 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;
# 273 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
}
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 630 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 652 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
# 674 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 684 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 694 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 706 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) throw ();


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw ();


extern int wctomb (char *__s, wchar_t __wchar) throw ();



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 956 "/usr/include/stdlib.h" 2 3 4
# 968 "/usr/include/stdlib.h" 3 4
}
# 73 "/usr/include/c++/4.8/cstdlib" 2 3
# 114 "/usr/include/c++/4.8/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }








}
# 196 "/usr/include/c++/4.8/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 228 "/usr/include/c++/4.8/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
# 42 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cwchar" 1 3
# 39 "/usr/include/c++/4.8/cwchar" 3
       
# 40 "/usr/include/c++/4.8/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 45 "/usr/include/c++/4.8/cwchar" 2 3
# 43 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4
extern "C" {



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h" 1 3 4
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
# 526 "/usr/include/libio.h" 3 4
}
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();








extern FILE *tmpfile (void) ;
# 205 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);









extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4


extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
# 943 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/4.8/cstdio" 2 3
# 94 "/usr/include/c++/4.8/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 150 "/usr/include/c++/4.8/cstdio" 3
namespace __gnu_cxx
{
# 168 "/usr/include/c++/4.8/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/4.8/cerrno" 1 3
# 39 "/usr/include/c++/4.8/cerrno" 3
       
# 40 "/usr/include/c++/4.8/cerrno" 3

# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4
extern "C" {



# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 42 "/usr/include/c++/4.8/cerrno" 2 3
# 45 "/usr/include/c++/4.8/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;
      (*__errno_location ()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 2816 "/usr/include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }


  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }


  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}





# 1 "/usr/include/c++/4.8/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/4.8/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/4.8/bits/functional_hash.h" 3

# 1 "/usr/include/c++/4.8/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/4.8/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/4.8/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "/usr/include/c++/4.8/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/4.8/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 80 "/usr/include/c++/4.8/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 3034 "/usr/include/c++/4.8/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };



}
# 53 "/usr/include/c++/4.8/string" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_string.tcc" 1 3
# 40 "/usr/include/c++/4.8/bits/basic_string.tcc" 3
       
# 41 "/usr/include/c++/4.8/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "/usr/include/c++/4.8/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "/usr/include/c++/4.8/string" 2 3
# 41 "/usr/include/c++/4.8/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 164 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 177 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 191 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 206 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
# 225 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 253 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 269 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 304 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
# 338 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 369 "/usr/include/c++/4.8/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
# 436 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
# 583 "/usr/include/c++/4.8/bits/locale_classes.h" 3
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 610 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 624 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 641 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 660 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 674 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 703 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 717 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 730 "/usr/include/c++/4.8/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/4.8/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/4.8/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 788 "/usr/include/c++/4.8/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/4.8/bits/ios_base.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
# 199 "/usr/include/c++/4.8/bits/ios_base.h" 3
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
# 255 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 330 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 361 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 393 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 419 "/usr/include/c++/4.8/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 436 "/usr/include/c++/4.8/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 448 "/usr/include/c++/4.8/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 561 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 577 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 594 "/usr/include/c++/4.8/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 620 "/usr/include/c++/4.8/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 671 "/usr/include/c++/4.8/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 683 "/usr/include/c++/4.8/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 694 "/usr/include/c++/4.8/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 705 "/usr/include/c++/4.8/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 724 "/usr/include/c++/4.8/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 740 "/usr/include/c++/4.8/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 761 "/usr/include/c++/4.8/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 778 "/usr/include/c++/4.8/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
# 43 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/streambuf" 1 3
# 36 "/usr/include/c++/4.8/streambuf" 3
       
# 37 "/usr/include/c++/4.8/streambuf" 3
# 45 "/usr/include/c++/4.8/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "/usr/include/c++/4.8/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "/usr/include/c++/4.8/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "/usr/include/c++/4.8/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "/usr/include/c++/4.8/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "/usr/include/c++/4.8/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "/usr/include/c++/4.8/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "/usr/include/c++/4.8/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "/usr/include/c++/4.8/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "/usr/include/c++/4.8/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "/usr/include/c++/4.8/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "/usr/include/c++/4.8/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "/usr/include/c++/4.8/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "/usr/include/c++/4.8/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "/usr/include/c++/4.8/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "/usr/include/c++/4.8/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "/usr/include/c++/4.8/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "/usr/include/c++/4.8/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "/usr/include/c++/4.8/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "/usr/include/c++/4.8/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "/usr/include/c++/4.8/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "/usr/include/c++/4.8/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "/usr/include/c++/4.8/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "/usr/include/c++/4.8/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "/usr/include/c++/4.8/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const basic_streambuf& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      basic_streambuf&
      operator=(const basic_streambuf&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "/usr/include/c++/4.8/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 829 "/usr/include/c++/4.8/streambuf" 2 3
# 44 "/usr/include/c++/4.8/ios" 2 3
# 1 "/usr/include/c++/4.8/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/4.8/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/4.8/bits/basic_ios.h" 3



# 1 "/usr/include/c++/4.8/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/4.8/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/4.8/bits/locale_facets.h" 3

# 1 "/usr/include/c++/4.8/cwctype" 1 3
# 39 "/usr/include/c++/4.8/cwctype" 3
       
# 40 "/usr/include/c++/4.8/cwctype" 3
# 50 "/usr/include/c++/4.8/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 33 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/wchar.h" 1 3 4
# 34 "/usr/include/wctype.h" 2 3 4
# 49 "/usr/include/wctype.h" 3 4



typedef unsigned long int wctype_t;

# 71 "/usr/include/wctype.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
# 171 "/usr/include/wctype.h" 3 4
extern wctype_t wctype (const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
# 213 "/usr/include/wctype.h" 3 4
extern "C" {




extern wctrans_t wctrans (const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
# 51 "/usr/include/c++/4.8/cwctype" 2 3
# 80 "/usr/include/c++/4.8/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/4.8/cctype" 1 3
# 39 "/usr/include/c++/4.8/cctype" 3
       
# 40 "/usr/include/c++/4.8/cctype" 3
# 41 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/ctype_base.h" 1 3
# 36 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}
# 42 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/4.8/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 142 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 161 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 178 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 194 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 210 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 224 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 239 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 253 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 268 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 285 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 304 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 323 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 345 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 370 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 389 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 408 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 427 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 445 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 462 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 478 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 495 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 514 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 535 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 556 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 581 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 604 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 673 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 710 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 723 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 736 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 751 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 765 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 779 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 794 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 811 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 827 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 844 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 864 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 891 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 922 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 955 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1004 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1021 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1037 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1054 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1074 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1097 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1123 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1149 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1174 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1207 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1218 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1242 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1261 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1279 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1297 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1314 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1331 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1347 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1364 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1384 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1406 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1429 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1455 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/ctype_inline.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1512 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
# 1640 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1678 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1692 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1706 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1719 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1750 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1763 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1776 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1793 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1805 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1818 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1831 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1844 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


# 1914 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1935 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1961 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 1998 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2058 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2101 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2172 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2235 "/usr/include/c++/4.8/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2253 "/usr/include/c++/4.8/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2274 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2292 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2334 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2397 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2422 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2470 "/usr/include/c++/4.8/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/4.8/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 136 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 730 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 966 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
# 1027 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1152 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1189 "/usr/include/c++/4.8/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2609 "/usr/include/c++/4.8/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/4.8/bits/basic_ios.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 65 "/usr/include/c++/4.8/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
# 130 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 141 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 194 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 215 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 250 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 288 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 300 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 340 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 354 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 383 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 403 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 423 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 442 "/usr/include/c++/4.8/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/4.8/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/4.8/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 476 "/usr/include/c++/4.8/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/4.8/ios" 2 3
# 39 "/usr/include/c++/4.8/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/4.8/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      flush();
# 357 "/usr/include/c++/4.8/ostream" 3
      pos_type
      tellp();
# 368 "/usr/include/c++/4.8/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "/usr/include/c++/4.8/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 399 "/usr/include/c++/4.8/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 418 "/usr/include/c++/4.8/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 428 "/usr/include/c++/4.8/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 447 "/usr/include/c++/4.8/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 469 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 511 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 562 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 574 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 600 "/usr/include/c++/4.8/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}

# 1 "/usr/include/c++/4.8/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 613 "/usr/include/c++/4.8/ostream" 2 3
# 40 "/usr/include/c++/4.8/iostream" 2 3
# 1 "/usr/include/c++/4.8/istream" 1 3
# 36 "/usr/include/c++/4.8/istream" 3
       
# 37 "/usr/include/c++/4.8/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/4.8/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/4.8/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/4.8/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/4.8/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/4.8/istream" 3
      int
      sync();
# 570 "/usr/include/c++/4.8/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/4.8/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 656 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 692 "/usr/include/c++/4.8/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 703 "/usr/include/c++/4.8/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 721 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 763 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 794 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
# 854 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 870 "/usr/include/c++/4.8/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}

# 1 "/usr/include/c++/4.8/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "/usr/include/c++/4.8/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 883 "/usr/include/c++/4.8/istream" 2 3
# 41 "/usr/include/c++/4.8/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/4.8/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 6 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 44 "/usr/include/string.h" 3 4


extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/string.h" 3 4
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 211 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 234 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 261 "/usr/include/string.h" 3 4
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 313 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 340 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 382 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 487 "/usr/include/string.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 515 "/usr/include/string.h" 3 4
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 644 "/usr/include/string.h" 3 4
}
# 7 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2



# 1 "/usr/include/GL/glew.h" 1 3 4
# 216 "/usr/include/GL/glew.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 422 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 217 "/usr/include/GL/glew.h" 2 3 4
# 262 "/usr/include/GL/glew.h" 3 4
extern "C" {







typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 296 "/usr/include/GL/glew.h" 3 4
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;

typedef GLint64EXT GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
# 840 "/usr/include/GL/glew.h" 3 4
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid* *params);
extern void glGetPolygonStipple (GLubyte *mask);
extern const GLubyte * glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 1188 "/usr/include/GL/glew.h" 3 4
# 1 "/usr/include/GL/glu.h" 1 3 4
# 38 "/usr/include/GL/glu.h" 3 4
# 1 "/usr/include/GL/gl.h" 1 3 4
# 39 "/usr/include/GL/glu.h" 2 3 4
# 65 "/usr/include/GL/glu.h" 3 4
extern "C" {
# 270 "/usr/include/GL/glu.h" 3 4
class GLUnurbs;
class GLUquadric;
class GLUtesselator;






typedef GLUnurbs GLUnurbsObj;
typedef GLUquadric GLUquadricObj;
typedef GLUtesselator GLUtesselatorObj;
typedef GLUtesselator GLUtriangulatorObj;




typedef void ( * _GLUfuncptr)(void);

extern void gluBeginCurve (GLUnurbs* nurb);
extern void gluBeginPolygon (GLUtesselator* tess);
extern void gluBeginSurface (GLUnurbs* nurb);
extern void gluBeginTrim (GLUnurbs* nurb);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb);
extern void gluDeleteQuadric (GLUquadric* quad);
extern void gluDeleteTess (GLUtesselator* tess);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
extern void gluEndCurve (GLUnurbs* nurb);
extern void gluEndPolygon (GLUtesselator* tess);
extern void gluEndSurface (GLUnurbs* nurb);
extern void gluEndTrim (GLUnurbs* nurb);
extern const GLubyte * gluErrorString (GLenum error);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
extern const GLubyte * gluGetString (GLenum name);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
extern GLUnurbs* gluNewNurbsRenderer (void);
extern GLUquadric* gluNewQuadric (void);
extern GLUtesselator* gluNewTess (void);
extern void gluNextContour (GLUtesselator* tess, GLenum type);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal);
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
extern void gluTessBeginContour (GLUtesselator* tess);
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
extern void gluTessCallback (GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluTessEndContour (GLUtesselator* tess);
extern void gluTessEndPolygon (GLUtesselator* tess);
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 1189 "/usr/include/GL/glew.h" 2 3 4
# 1238 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 1363 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLvoid *img);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
# 1506 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei drawcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);
# 1662 "/usr/include/GL/glew.h" 3 4
typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef GLvoid* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
# 1799 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum, GLenum);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint, GLenum, GLvoid**);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint, GLenum, GLdouble*);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint, GLenum, GLfloat*);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint, GLenum, GLint*);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar** strings, const GLint* lengths);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum, GLuint);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer);
# 2020 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 2149 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint, GLenum);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint, GLuint, const GLchar*);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum, GLenum);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum, GLint, GLfloat, GLint);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum, GLint, const GLfloat*);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum, GLint, const GLint*);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum, GLint, const GLuint*);
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
typedef void ( * PFNGLDISABLEIPROC) (GLenum, GLuint);
typedef void ( * PFNGLENABLEIPROC) (GLenum, GLuint);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum, GLuint, GLboolean*);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint, const GLchar*);
typedef const GLubyte* ( * PFNGLGETSTRINGIPROC) (GLenum, GLuint);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum, GLenum, GLint*);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum, GLenum, GLuint*);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint, GLint, GLuint*);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint, GLenum, GLint*);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint, GLenum, GLuint*);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum, GLuint);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum, GLenum, const GLint*);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum, GLenum, const GLuint*);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint, GLsizei, const GLchar **, GLenum);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint, GLuint);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint, GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint, GLint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint, const GLbyte*);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint, GLint, GLint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint, const GLshort*);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint, const GLubyte*);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint, GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint, const GLushort*);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint, GLint, GLenum, GLsizei, const GLvoid*);
# 2305 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum, GLint, GLsizei, GLsizei);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum, GLsizei, GLenum, const GLvoid*, GLsizei);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum, GLenum, GLuint);
# 2347 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum, GLenum, GLuint, GLint);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum, GLenum, GLint64 *);
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum, GLuint, GLint64 *);
# 2367 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 2393 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
# 2474 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 2535 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, GLvoid *userParam);
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);
# 2568 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 2597 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);
# 2610 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
# 2631 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 2656 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, GLvoid *data);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
# 2715 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);
# 2767 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void ( * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
# 2787 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);
# 2835 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);
# 2873 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 2890 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 2905 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);
# 3005 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);
# 3040 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
# 3079 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);
# 3103 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
# 3157 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 3179 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
# 3250 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid **params);
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, GLvoid *pointer);
# 3278 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 3306 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
# 3334 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
# 3387 "/usr/include/GL/glew.h" 3 4
typedef int GLfixed;

typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const GLvoid*binary, GLsizei length);
# 3443 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 3462 "/usr/include/GL/glew.h" 3 4
typedef GLuint64 ( * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);
# 3510 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);
# 3535 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const GLvoid* data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid* data, GLbitfield flags);
# 3553 "/usr/include/GL/glew.h" 3 4
typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);
# 3569 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);
# 3590 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data);
# 3611 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 3670 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
# 3690 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
# 3715 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 3728 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 3764 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const GLvoid *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
# 3842 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);
# 3855 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
# 3874 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *basevertex);
# 3896 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);
# 4028 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
# 4122 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 4204 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
# 4228 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, GLvoid*binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 4274 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
# 4421 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 4499 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
# 4516 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 4535 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
# 4648 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);
# 4661 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
# 4702 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef GLvoid * ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 4728 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);
# 4749 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void ( * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void ( * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void ( * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 4772 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
# 4797 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 4846 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 4931 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
# 4988 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);
# 5063 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);
# 5091 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 5135 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, GLvoid*column, GLvoid*span);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
# 5207 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 5222 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
# 5293 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar ** strings);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
# 5454 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
# 5559 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 5618 "/usr/include/GL/glew.h" 3 4
typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
# 5745 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
# 5768 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
# 5828 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);
# 5896 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void ( * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 5938 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
# 5996 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
# 6028 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 6054 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 6081 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLvoid *img);
# 6322 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 6443 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 6466 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 6506 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 6522 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
# 6544 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
# 6572 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
# 6591 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 6611 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
# 6664 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 6708 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 6727 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 6766 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
# 6832 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);
# 6895 "/usr/include/GL/glew.h" 3 4
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef GLvoid * ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
# 7011 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
# 7154 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
# 7185 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);
# 7286 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);
# 7317 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);
# 7431 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);
# 7448 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
# 7474 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
# 7548 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);
# 7587 "/usr/include/GL/glew.h" 3 4
typedef GLvoid * ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 7625 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
# 7645 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
# 7747 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
# 7782 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
# 7810 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
# 7967 "/usr/include/GL/glew.h" 3 4
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
# 7990 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 8006 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 8024 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 8051 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 8101 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 8119 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 8155 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 8207 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, GLvoid *pointer);
# 8222 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 8247 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);
# 8262 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void ( * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
# 8282 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 8299 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLvoid *img);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLvoid *img);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, GLvoid *string);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLvoid** params);
typedef void ( * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, GLvoid** params);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLvoid** param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, GLvoid** param);
typedef GLvoid * ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef GLvoid * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 8736 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 8759 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 8777 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 8799 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
# 8835 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);
# 8887 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 8904 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 8981 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 9059 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 9076 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
# 9118 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 9211 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 9251 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);
# 9264 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
# 9296 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 9322 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const GLvoid * const *indices, GLsizei primcount);
# 9355 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 9434 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
# 9477 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
# 9514 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);
# 9533 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 9551 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 9575 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINSCENEEXTPROC) (void);
typedef void ( * PFNGLENDSCENEEXTPROC) (void);
# 9598 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 9645 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
# 9731 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 9781 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 9806 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 9885 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
# 9907 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 9926 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 10144 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
# 10199 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);
# 10225 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 10356 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 10387 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);
# 10446 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
# 10497 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 10641 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid **data);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, GLvoid *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
# 10750 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);
# 10769 "/usr/include/GL/glew.h" 3 4
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 10782 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 10795 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);
# 10817 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
# 10869 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride);
# 10935 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
# 10996 "/usr/include/GL/glew.h" 3 4
typedef GLvoid * ( * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void ( * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void ( * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);
# 11019 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
# 11038 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void ( * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);
# 11094 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const GLvoid *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void ( * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void ( * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void ( * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void ( * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);
# 11170 "/usr/include/GL/glew.h" 3 4
typedef GLuint ( * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void ( * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint ( * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
# 11218 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 11231 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);
# 11303 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void ( * PFNGLENDCONDITIONALRENDERNVXPROC) (void);
# 11333 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const GLvoid *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
# 11348 "/usr/include/GL/glew.h" 3 4
typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
# 11432 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDBARRIERNVPROC) (void);
typedef void ( * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
# 11482 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 11509 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 11539 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
# 11582 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
# 11620 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);
# 11660 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 11681 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
# 11751 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);
# 11812 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 11829 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
# 11860 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
# 11958 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 12039 "/usr/include/GL/glew.h" 3 4
typedef unsigned short GLhalf;

typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);
# 12183 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
# 12226 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
# 12381 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERSTROKEPATHNVPROC) (GLuint name, GLenum coverMode);
typedef void ( * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint ( * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHCOMMANDSNVPROC) (GLuint name, GLubyte* commands);
typedef void ( * PFNGLGETPATHCOORDSNVPROC) (GLuint name, GLfloat* coords);
typedef void ( * PFNGLGETPATHDASHARRAYNVPROC) (GLuint name, GLfloat* dashArray);
typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void ( * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void ( * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint name, GLenum param, GLfloat* value);
typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint name, GLenum param, GLint* value);
typedef void ( * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void ( * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void ( * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean ( * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void ( * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void ( * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void ( * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void ( * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void ( * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef void ( * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void ( * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void ( * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void ( * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void ( * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void* pathString);
typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void ( * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void ( * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void ( * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void ( * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);
# 12497 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, GLvoid *pointer);
# 12516 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
# 12538 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
# 12564 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
# 12631 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);
# 12670 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);
# 12707 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 12793 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 12844 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 13055 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
# 13093 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
# 13123 "/usr/include/GL/glew.h" 3 4
typedef GLintptr GLvdpauSurfaceNV;

typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void ( * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const GLvoid*getProcAddress);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
# 13162 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, GLvoid *pointer);
# 13191 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 13266 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
# 13385 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);
# 13606 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
# 13682 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARDEPTHFOESPROC) (GLclampd depth);
typedef void ( * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void ( * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void ( * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
# 13807 "/usr/include/GL/glew.h" 3 4
typedef int GLclampx;

typedef void ( * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void ( * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void ( * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void ( * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void ( * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void ( * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void ( * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void ( * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void ( * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void ( * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void ( * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void ( * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void ( * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);
# 13882 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void ( * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void ( * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void ( * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void ( * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const GLvoid* pointer);
typedef void ( * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
# 13939 "/usr/include/GL/glew.h" 3 4
typedef const GLchar* ( * PFNGLERRORSTRINGREGALPROC) (GLenum error);
# 13952 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean ( * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);
# 13977 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, GLvoid *context);

typedef void ( * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);
# 14039 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
# 14054 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);
# 14098 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 14140 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
# 14155 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const GLvoid *pixels);
# 14192 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);
# 14232 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);
# 14328 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 14357 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);
# 14370 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);
# 14415 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
# 14457 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 14479 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);
# 14532 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);
# 14551 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 14729 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
# 14769 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 14796 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
# 14835 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
# 14877 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);
# 14902 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
# 15016 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 15043 "/usr/include/GL/glew.h" 3 4
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAPROC __glewBufferData;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYPROC __glewEndQuery;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESPROC __glewGenQueries;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERPROC __glewIsBuffer;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYPROC __glewIsQuery;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __attribute__ ((visibility("default"))) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROC __glewCreateShader;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __attribute__ ((visibility("default"))) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __attribute__ ((visibility("default"))) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPROC __glewIsProgram;
extern __attribute__ ((visibility("default"))) PFNGLISSHADERPROC __glewIsShader;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIPROC __glewDisablei;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIPROC __glewEnablei;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __attribute__ ((visibility("default"))) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __attribute__ ((visibility("default"))) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __attribute__ ((visibility("default"))) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __attribute__ ((visibility("default"))) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __attribute__ ((visibility("default"))) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __attribute__ ((visibility("default"))) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __attribute__ ((visibility("default"))) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __attribute__ ((visibility("default"))) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPROC __glewColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMPROC __glewHistogram;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXPROC __glewMinmax;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __attribute__ ((visibility("default"))) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __attribute__ ((visibility("default"))) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __attribute__ ((visibility("default"))) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISSAMPLERPROC __glewIsSampler;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __attribute__ ((visibility("default"))) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __attribute__ ((visibility("default"))) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __attribute__ ((visibility("default"))) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __attribute__ ((visibility("default"))) PFNGLFENCESYNCPROC __glewFenceSync;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __attribute__ ((visibility("default"))) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __attribute__ ((visibility("default"))) PFNGLISSYNCPROC __glewIsSync;
extern __attribute__ ((visibility("default"))) PFNGLWAITSYNCPROC __glewWaitSync;

extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __attribute__ ((visibility("default"))) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __attribute__ ((visibility("default"))) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __attribute__ ((visibility("default"))) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __attribute__ ((visibility("default"))) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __attribute__ ((visibility("default"))) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __attribute__ ((visibility("default"))) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __attribute__ ((visibility("default"))) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __attribute__ ((visibility("default"))) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __attribute__ ((visibility("default"))) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __attribute__ ((visibility("default"))) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __attribute__ ((visibility("default"))) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __attribute__ ((visibility("default"))) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __attribute__ ((visibility("default"))) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __attribute__ ((visibility("default"))) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __attribute__ ((visibility("default"))) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __attribute__ ((visibility("default"))) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __attribute__ ((visibility("default"))) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLISPATHNVPROC __glewIsPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __attribute__ ((visibility("default"))) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __attribute__ ((visibility("default"))) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __attribute__ ((visibility("default"))) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFOESPROC __glewOrthofOES;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4XPROC __glewColor4x;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __attribute__ ((visibility("default"))) PFNGLFOGXPROC __glewFogx;
extern __attribute__ ((visibility("default"))) PFNGLFOGXVPROC __glewFogxv;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXPROC __glewLightx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXVPROC __glewLightxv;
extern __attribute__ ((visibility("default"))) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __attribute__ ((visibility("default"))) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXPROC __glewMaterialx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3XPROC __glewNormal3x;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFPROC __glewOrthof;
extern __attribute__ ((visibility("default"))) PFNGLORTHOXPROC __glewOrthox;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __attribute__ ((visibility("default"))) PFNGLROTATEXPROC __glewRotatex;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __attribute__ ((visibility("default"))) PFNGLSCALEXPROC __glewScalex;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXPROC __glewTexEnvx;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __attribute__ ((visibility("default"))) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __attribute__ ((visibility("default"))) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __attribute__ ((visibility("default"))) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __attribute__ ((visibility("default"))) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __attribute__ ((visibility("default"))) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __attribute__ ((visibility("default"))) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __attribute__ ((visibility("default"))) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __attribute__ ((visibility("default"))) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __attribute__ ((visibility("default"))) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __attribute__ ((visibility("default"))) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __attribute__ ((visibility("default"))) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __attribute__ ((visibility("default"))) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __attribute__ ((visibility("default"))) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;






extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_tbuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_interleaved_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_name_gen_delete;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_performance_monitor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_pinned_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sample_positions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_texture_texture4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_usage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_client_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_float_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_object_purgeable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_pixel_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_rgb_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_row_bytes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_specular_vector;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_transform_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_ycbcr_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES2_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_base_instance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_blend_func_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_buffer_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_cl_event;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_color_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_enhanced_layouts;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_get_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_imaging;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_indirect_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_invalidate_subdata;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_bind;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multitexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_program_interface_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sample_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sampler_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_group_vote;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_subroutine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_100;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_420pack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_include;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_packing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_stencil_texturing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_gather;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_levels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rg;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transpose_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_viewport_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_point_sprites;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_route;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_map_object_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_meminfo;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_pn_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_separate_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_text_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_mirror_once;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_streams;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_422_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_Cg_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_abgr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bindable_uniform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_equation_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_func_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_logic_op;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_subtract;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_volume_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cmyka;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_subtable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_convolution;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_coordinate_frame;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_copy_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_debug_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_depth_bounds_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_direct_state_access;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_range_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fog_coord;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fragment_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_array_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_func;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_material;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_light_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_misc_attribute;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_polygon_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_rescale_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_scene_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_secondary_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_specular_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shadow_funcs;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shared_texture_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_two_side;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_wrap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_subtexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_latc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_integer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_snorm;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_weighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_x11_sync_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_string_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_image_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_occlusion_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_texture_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_rasterpos_clip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_static_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_vertex_array_lists;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_color_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_interlace_read;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_map_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_parallel_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_texture_scissor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_debug;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KTX_buffer_region;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESAX_texture_stack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_pack_invert;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_resize_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_ycbcr_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_gpu_memory_info;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_square;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_compute_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_depth_to_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_deep_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_range_unclamped;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_explicit_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_float_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fog_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_light_max_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_filter_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_path_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pixel_data_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_present_video;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_primitive_restart;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_buffer_load;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_tessellation_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_emboss;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_reflection;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_barrier;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_vtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_env_combine4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_expand_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vdpau_interop;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_video_capture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_byte_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_compressed_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_read_format;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_single_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_misc_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_vertex_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_enable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_error_string;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_extension_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_log;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REND_screen_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_S3_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_color_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_detail_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_fog_function;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_generate_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_point_line_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_sharpen_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture4D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_filter4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_select;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_clipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_flush_raster;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_framezoom;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ir_instrument1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_list_priority;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_reference_plane;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_add_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcb;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_texture_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUNX_constant_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_global_alpha;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_mesh_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_read_video_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_slice_accum;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_triangle_list;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_phong_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_specular_fog;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_swap_hint;
# 18024 "/usr/include/GL/glew.h" 3 4
extern __attribute__ ((visibility("default"))) GLenum glewInit (void);
extern __attribute__ ((visibility("default"))) GLboolean glewIsSupported (const char *name);







extern __attribute__ ((visibility("default"))) GLboolean glewExperimental;
extern __attribute__ ((visibility("default"))) GLboolean glewGetExtension (const char *name);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetErrorString (GLenum error);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetString (GLenum name);


}
# 11 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/usr/include/GLFW/glfw3.h" 1 3 4
# 33 "/usr/include/GLFW/glfw3.h" 3 4
extern "C" {
# 137 "/usr/include/GLFW/glfw3.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 138 "/usr/include/GLFW/glfw3.h" 2 3 4
# 558 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (*GLFWglproc)(void);







typedef struct GLFWmonitor GLFWmonitor;







typedef struct GLFWwindow GLFWwindow;
# 587 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWerrorfun)(int,const char*);
# 603 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowposfun)(GLFWwindow*,int,int);
# 617 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowsizefun)(GLFWwindow*,int,int);
# 629 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowclosefun)(GLFWwindow*);
# 641 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowrefreshfun)(GLFWwindow*);
# 655 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowfocusfun)(GLFWwindow*,int);
# 670 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowiconifyfun)(GLFWwindow*,int);
# 685 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWframebuffersizefun)(GLFWwindow*,int,int);
# 702 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWmousebuttonfun)(GLFWwindow*,int,int,int);
# 716 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcursorposfun)(GLFWwindow*,double,double);
# 730 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcursorenterfun)(GLFWwindow*,int);
# 744 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWscrollfun)(GLFWwindow*,double,double);
# 761 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWkeyfun)(GLFWwindow*,int,int,int,int);
# 774 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcharfun)(GLFWwindow*,unsigned int);
# 787 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWmonitorfun)(GLFWmonitor*,int);







typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 825 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 874 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwInit(void);
# 898 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwTerminate(void);
# 918 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetVersion(int* major, int* minor, int* rev);
# 948 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetVersionString(void);
# 973 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun);
# 995 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor** glfwGetMonitors(int* count);
# 1008 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor* glfwGetPrimaryMonitor(void);
# 1021 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 1040 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* width, int* height);
# 1056 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 1074 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun cbfun);
# 1098 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 1116 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 1128 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 1142 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 1155 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 1168 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwDefaultWindowHints(void);
# 1190 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWindowHint(int target, int hint);
# 1258 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 1280 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwDestroyWindow(GLFWwindow* window);
# 1293 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwWindowShouldClose(GLFWwindow* window);
# 1308 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 1322 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 1339 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 1367 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 1385 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 1409 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 1427 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 1444 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwIconifyWindow(GLFWwindow* window);
# 1461 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwRestoreWindow(GLFWwindow* window);
# 1477 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwShowWindow(GLFWwindow* window);
# 1493 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwHideWindow(GLFWwindow* window);
# 1505 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 1519 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 1534 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 1547 "/usr/include/GLFW/glfw3.h" 3 4
 void* glfwGetWindowUserPointer(GLFWwindow* window);
# 1563 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun cbfun);
# 1579 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun cbfun);
# 1606 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun cbfun);
# 1630 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun cbfun);
# 1650 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun cbfun);
# 1665 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun cbfun);
# 1680 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun cbfun);
# 1711 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwPollEvents(void);
# 1744 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWaitEvents(void);
# 1756 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetInputMode(GLFWwindow* window, int mode);
# 1794 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 1820 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetKey(GLFWwindow* window, int key);
# 1838 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetMouseButton(GLFWwindow* window, int button);
# 1865 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 1889 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 1923 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun cbfun);
# 1942 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun cbfun);
# 1963 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun cbfun);
# 1980 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun cbfun);
# 1996 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun cbfun);
# 2015 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun cbfun);
# 2026 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwJoystickPresent(int joy);
# 2045 "/usr/include/GLFW/glfw3.h" 3 4
 const float* glfwGetJoystickAxes(int joy, int* count);
# 2064 "/usr/include/GLFW/glfw3.h" 3 4
 const unsigned char* glfwGetJoystickButtons(int joy, int* count);
# 2082 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetJoystickName(int joy);
# 2099 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 2122 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetClipboardString(GLFWwindow* window);
# 2140 "/usr/include/GLFW/glfw3.h" 3 4
 double glfwGetTime(void);
# 2155 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetTime(double time);
# 2173 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwMakeContextCurrent(GLFWwindow* window);
# 2189 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindow* glfwGetCurrentContext(void);
# 2209 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSwapBuffers(GLFWwindow* window);
# 2243 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSwapInterval(int interval);
# 2264 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwExtensionSupported(const char* extension);
# 2285 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWglproc glfwGetProcAddress(const char* procname);
# 2308 "/usr/include/GLFW/glfw3.h" 3 4
}
# 12 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2


# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 78 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 29 "/usr/include/glm/detail/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3




# 1 "/usr/include/math.h" 1 3 4
# 28 "/usr/include/math.h" 3 4
extern "C" {



# 1 "/usr/include/x86_64-linux-gnu/bits/huge_val.h" 1 3 4
# 33 "/usr/include/math.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/huge_valf.h" 1 3 4
# 35 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/huge_vall.h" 1 3 4
# 36 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/inf.h" 1 3 4
# 39 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/nan.h" 1 3 4
# 42 "/usr/include/math.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
# 46 "/usr/include/math.h" 2 3 4
# 69 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
__extension__
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
__extension__
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern int __issignaling (double __value) throw ()
     __attribute__ ((__const__));




extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
# 70 "/usr/include/math.h" 2 3 4
# 88 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
__extension__
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
__extension__
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern int __issignalingf (float __value) throw ()
     __attribute__ ((__const__));




extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
# 89 "/usr/include/math.h" 2 3 4
# 132 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw () __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
__extension__
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
__extension__
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern int __issignalingl (long double __value) throw ()
     __attribute__ ((__const__));




extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
# 133 "/usr/include/math.h" 2 3 4
# 148 "/usr/include/math.h" 3 4
extern int signgam;
# 189 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 301 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
# 324 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
# 488 "/usr/include/math.h" 3 4
}
# 45 "/usr/include/c++/4.8/cmath" 2 3
# 75 "/usr/include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 431 "/usr/include/c++/4.8/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "/usr/include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }

  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }

  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }

  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }

  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }

  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }

  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }

  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }

  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }

  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 916 "/usr/include/c++/4.8/cmath" 3

}
# 1032 "/usr/include/c++/4.8/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;


  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }

  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }

  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }

  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }

  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }

  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }

  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }

  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }

  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }

  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }

  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }

  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }

  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }

  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }


  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }

  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }

  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }

  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }

  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }

  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }

  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }

  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }

  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }

  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }

  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }

  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 30 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 79 "/usr/include/glm/glm.hpp" 2 3 4




# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 84 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.8/climits" 1 3 4
# 39 "/usr/include/c++/4.8/climits" 3 4
       
# 40 "/usr/include/c++/4.8/climits" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 152 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 2 3 4
# 42 "/usr/include/c++/4.8/climits" 2 3
# 85 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.8/cfloat" 1 3 4
# 39 "/usr/include/c++/4.8/cfloat" 3 4
       
# 40 "/usr/include/c++/4.8/cfloat" 3

# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/float.h" 1 3 4
# 42 "/usr/include/c++/4.8/cfloat" 2 3
# 86 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.8/limits" 1 3 4
# 40 "/usr/include/c++/4.8/limits" 3 4
       
# 41 "/usr/include/c++/4.8/limits" 3
# 147 "/usr/include/c++/4.8/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "/usr/include/c++/4.8/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 277 "/usr/include/c++/4.8/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "/usr/include/c++/4.8/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -9223372036854775807L - 1; }

      static constexpr long
      max() noexcept { return 9223372036854775807L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 9223372036854775807L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1552 "/usr/include/c++/4.8/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 87 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/4.8/cassert" 1 3 4
# 41 "/usr/include/c++/4.8/cassert" 3 4
       
# 42 "/usr/include/c++/4.8/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 66 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
# 43 "/usr/include/c++/4.8/cassert" 2 3
# 88 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/fwd.hpp" 1 3 4
# 32 "/usr/include/glm/fwd.hpp" 3 4
# 1 "/usr/include/glm/detail/type_int.hpp" 1 3 4
# 32 "/usr/include/glm/detail/type_int.hpp" 3 4
# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 32 "/usr/include/glm/detail/setup.hpp" 3 4
# 1 "/usr/include/c++/4.8/cassert" 1 3 4
# 41 "/usr/include/c++/4.8/cassert" 3 4
       
# 42 "/usr/include/c++/4.8/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 43 "/usr/include/c++/4.8/cassert" 2 3
# 33 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 633 "/usr/include/glm/detail/setup.hpp" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/mmintrin.h" 1 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/mmintrin.h" 3 4
typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));


typedef int __v2si __attribute__ ((__vector_size__ (8)));
typedef short __v4hi __attribute__ ((__vector_size__ (8)));
typedef char __v8qi __attribute__ ((__vector_size__ (8)));
typedef long long __v1di __attribute__ ((__vector_size__ (8)));
typedef float __v2sf __attribute__ ((__vector_size__ (8)));


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_empty (void)
{
  __builtin_ia32_emms ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_empty (void)
{
  _mm_empty ();
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si64 (int __i)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int (int __i)
{
  return _mm_cvtsi32_si64 (__i);
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_from_int64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_m64 (long long __i)
{
  return (__m64) __i;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si64 (long long __i)
{
  return (__m64) __i;
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi64x (long long __i)
{
  return (__m64) __i;
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si32 (__m64 __i)
{
  return __builtin_ia32_vec_ext_v2si ((__v2si)__i, 0);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int (__m64 __i)
{
  return _mm_cvtsi64_si32 (__i);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_to_int64 (__m64 __i)
{
  return (long long)__i;
}

extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtm64_si64 (__m64 __i)
{
  return (long long)__i;
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si64x (__m64 __i)
{
  return (long long)__i;
}





extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packsswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packssdw (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pi32 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_packuswb (__m64 __m1, __m64 __m2)
{
  return _mm_packs_pu16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckhdq (__m64 __m1, __m64 __m2)
{
  return _mm_unpackhi_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklbw (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpcklwd (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_punpckldq (__m64 __m1, __m64 __m2)
{
  return _mm_unpacklo_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddb (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddw (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddd (__m64 __m1, __m64 __m2)
{
  return _mm_add_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddsw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusb (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_paddusw (__m64 __m1, __m64 __m2)
{
  return _mm_adds_pu16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubb (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi8 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubw (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubd (__m64 __m1, __m64 __m2)
{
  return _mm_sub_pi32 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_si64 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubsw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusb (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_pu16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psubusw (__m64 __m1, __m64 __m2)
{
  return _mm_subs_pu16 (__m1, __m2);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaddwd (__m64 __m1, __m64 __m2)
{
  return _mm_madd_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhw (__m64 __m1, __m64 __m2)
{
  return _mm_mulhi_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmullw (__m64 __m1, __m64 __m2)
{
  return _mm_mullo_pi16 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllw (__m64 __m, __m64 __count)
{
  return _mm_sll_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllwi (__m64 __m, int __count)
{
  return _mm_slli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_pslld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslld (__m64 __m, __m64 __count)
{
  return _mm_sll_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_pslldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pslldi (__m64 __m, int __count)
{
  return _mm_slli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psllq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllq (__m64 __m, __m64 __count)
{
  return _mm_sll_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psllqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psllqi (__m64 __m, int __count)
{
  return _mm_slli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psraw (__m64 __m, __m64 __count)
{
  return _mm_sra_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrawi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrawi (__m64 __m, int __count)
{
  return _mm_srai_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrad ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrad (__m64 __m, __m64 __count)
{
  return _mm_sra_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psradi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psradi (__m64 __m, int __count)
{
  return _mm_srai_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi16 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, (__v4hi)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlw (__m64 __m, __m64 __count)
{
  return _mm_srl_pi16 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi16 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlwi ((__v4hi)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlwi (__m64 __m, int __count)
{
  return _mm_srli_pi16 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_pi32 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrld ((__v2si)__m, (__v2si)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrld (__m64 __m, __m64 __count)
{
  return _mm_srl_pi32 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_pi32 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrldi ((__v2si)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrldi (__m64 __m, int __count)
{
  return _mm_srli_pi32 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_si64 (__m64 __m, __m64 __count)
{
  return (__m64) __builtin_ia32_psrlq ((__v1di)__m, (__v1di)__count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlq (__m64 __m, __m64 __count)
{
  return _mm_srl_si64 (__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_si64 (__m64 __m, int __count)
{
  return (__m64) __builtin_ia32_psrlqi ((__v1di)__m, __count);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psrlqi (__m64 __m, int __count)
{
  return _mm_srli_si64 (__m, __count);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pand (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pand (__m64 __m1, __m64 __m2)
{
  return _mm_and_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pandn (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pandn (__m64 __m1, __m64 __m2)
{
  return _mm_andnot_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_por (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_por (__m64 __m1, __m64 __m2)
{
  return _mm_or_si64 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si64 (__m64 __m1, __m64 __m2)
{
  return __builtin_ia32_pxor (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pxor (__m64 __m1, __m64 __m2)
{
  return _mm_xor_si64 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi8 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtb (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi8 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi16 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtw (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi16 (__m1, __m2);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpeqd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpeq_pi32 (__m1, __m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)
{
  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pcmpgtd (__m64 __m1, __m64 __m2)
{
  return _mm_cmpgt_pi32 (__m1, __m2);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si64 (void)
{
  return (__m64)0LL;
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi32 (int __i1, int __i0)
{
  return (__m64) __builtin_ia32_vec_init_v2si (__i0, __i1);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)
{
  return (__m64) __builtin_ia32_vec_init_v4hi (__w0, __w1, __w2, __w3);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,
      char __b3, char __b2, char __b1, char __b0)
{
  return (__m64) __builtin_ia32_vec_init_v8qi (__b0, __b1, __b2, __b3,
            __b4, __b5, __b6, __b7);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi32 (int __i0, int __i1)
{
  return _mm_set_pi32 (__i1, __i0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)
{
  return _mm_set_pi16 (__w3, __w2, __w1, __w0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,
       char __b4, char __b5, char __b6, char __b7)
{
  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi32 (int __i)
{
  return _mm_set_pi32 (__i, __i);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi16 (short __w)
{
  return _mm_set_pi16 (__w, __w, __w, __w);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pi8 (char __b)
{
  return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
}
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/mm_malloc.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/mm_malloc.h" 3 4
extern "C" int posix_memalign (void **, size_t, size_t) throw ();


static __inline void *
_mm_malloc (size_t size, size_t alignment)
{
  void *ptr;
  if (alignment == 1)
    return malloc (size);
  if (alignment == 2 || (sizeof (void *) == 8 && alignment == 4))
    alignment = sizeof (void *);
  if (posix_memalign (&ptr, alignment, size) == 0)
    return ptr;
  else
    return __null;
}

static __inline void
_mm_free (void * ptr)
{
  free (ptr);
}
# 39 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 2 3 4



typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));


typedef float __v4sf __attribute__ ((__vector_size__ (16)));






enum _mm_hint
{
  _MM_HINT_T0 = 3,
  _MM_HINT_T1 = 2,
  _MM_HINT_T2 = 1,
  _MM_HINT_NTA = 0
};
# 88 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_ps (void)
{
  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ss (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_addps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_subps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_mulps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_divps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rcp_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_rsqrt_ps (__m128 __A)
{
  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_andnps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_orps (__A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_ps (__m128 __A, __m128 __B)
{
  return __builtin_ia32_xorps (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpltss ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpless ((__v4sf) __B,
        (__v4sf)
        __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnltss ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf) __A,
     (__v4sf)
     __builtin_ia32_cmpnless ((__v4sf) __B,
         (__v4sf)
         __A));
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);
}




extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_ss (__m128 __A, __m128 __B)
{
  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);
}



extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si32 (__m128 __A)
{
  return __builtin_ia32_cvtss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ss2si (__m128 __A)
{
  return _mm_cvtss_si32 (__A);
}






extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64 (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_si64x (__m128 __A)
{
  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_ps2pi (__m128 __A)
{
  return _mm_cvtps_pi32 (__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si32 (__m128 __A)
{
  return __builtin_ia32_cvttss2si ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ss2si (__m128 __A)
{
  return _mm_cvttss_si32 (__A);
}





extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64 (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttss_si64x (__m128 __A)
{
  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_pi32 (__m128 __A)
{
  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtt_ps2pi (__m128 __A)
{
  return _mm_cvttps_pi32 (__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_ss (__m128 __A, int __B)
{
  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_si2ss (__m128 __A, int __B)
{
  return _mm_cvtsi32_ss (__A, __B);
}





extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_ss (__m128 __A, long long __B)
{
  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_ps (__m128 __A, __m64 __B)
{
  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvt_pi2ps (__m128 __A, __m64 __B)
{
  return _mm_cvtpi32_ps (__A, __B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi16_ps (__m64 __A)
{
  __v4hi __sign;
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;




  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu16_ps (__m64 __A)
{
  __v2si __hisi, __losi;
  __v4sf __zero, __ra, __rb;


  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);


  __zero = (__v4sf) _mm_setzero_ps ();
  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);

  return (__m128) __builtin_ia32_movlhps (__ra, __rb);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi8_ps (__m64 __A)
{
  __v8qi __sign;




  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);


  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);

  return _mm_cvtpi16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpu8_ps(__m64 __A)
{
  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);
  return _mm_cvtpu16_ps(__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)
{
  __v4sf __zero = (__v4sf) _mm_setzero_ps ();
  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);
  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);
  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi16(__m128 __A)
{
  __v4sf __hisf = (__v4sf)__A;
  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);
  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);
  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);
  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pi8(__m128 __A)
{
  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);
  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);
}
# 726 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movehl_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movelh_ps (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);
}



extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pi (__m128 __A, __m64 const *__P)
{
  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pi (__m64 *__P, __m128 __A)
{
  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_ps (__m128 __A)
{
  return __builtin_ia32_movmskps ((__v4sf)__A);
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_getcsr (void)
{
  return __builtin_ia32_stmxcsr ();
}


extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_STATE (void)
{
  return _mm_getcsr() & 0x003f;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_EXCEPTION_MASK (void)
{
  return _mm_getcsr() & 0x1f80;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_ROUNDING_MODE (void)
{
  return _mm_getcsr() & 0x6000;
}

extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_GET_FLUSH_ZERO_MODE (void)
{
  return _mm_getcsr() & 0x8000;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setcsr (unsigned int __I)
{
  __builtin_ia32_ldmxcsr (__I);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_STATE(unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x003f) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_EXCEPTION_MASK (unsigned int __mask)
{
  _mm_setcsr((_mm_getcsr() & ~0x1f80) | __mask);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_ROUNDING_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x6000) | __mode);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)
{
  _mm_setcsr((_mm_getcsr() & ~0x8000) | __mode);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ss (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_ps (float __F)
{
  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps1 (float __F)
{
  return _mm_set1_ps (__F);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ss (float const *__P)
{
  return _mm_set_ss (*__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_ps (float const *__P)
{
  return _mm_set1_ps (*__P);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps1 (float const *__P)
{
  return _mm_load1_ps (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_ps (float const *__P)
{
  return (__m128) *(__v4sf *)__P;
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_ps (float const *__P)
{
  return (__m128) __builtin_ia32_loadups (__P);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_ps (float const *__P)
{
  __v4sf __tmp = *(__v4sf *)__P;
  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)
{
  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_ps (float __Z, float __Y, float __X, float __W)
{
  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ss (float *__P, __m128 __A)
{
  *__P = __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}

extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_f32 (__m128 __A)
{
  return __builtin_ia32_vec_ext_v4sf ((__v4sf)__A, 0);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps (float *__P, __m128 __A)
{
  *(__v4sf *)__P = (__v4sf)__A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_ps (float *__P, __m128 __A)
{
  __builtin_ia32_storeups (__P, (__v4sf)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((0) << 4) | ((0) << 2) | (0)));
  _mm_storeu_ps (__P, __tmp);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_ps1 (float *__P, __m128 __A)
{
  _mm_store1_ps (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_ps (float *__P, __m128 __A)
{
  __v4sf __va = (__v4sf)__A;
  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, (((0) << 6) | ((1) << 4) | ((2) << 2) | (3)));
  _mm_store_ps (__P, __tmp);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_ss (__m128 __A, __m128 __B)
{
  return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);
}
# 1031 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxsw (__m64 __A, __m64 __B)
{
  return _mm_max_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmaxub (__m64 __A, __m64 __B)
{
  return _mm_max_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pi16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminsw (__m64 __A, __m64 __B)
{
  return _mm_min_pi16 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pminub (__m64 __A, __m64 __B)
{
  return _mm_min_pu8 (__A, __B);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pi8 (__m64 __A)
{
  return __builtin_ia32_pmovmskb ((__v8qi)__A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmovmskb (__m64 __A)
{
  return _mm_movemask_pi8 (__A);
}



extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pmulhuw (__m64 __A, __m64 __B)
{
  return _mm_mulhi_pu16 (__A, __B);
}
# 1133 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)
{
  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_maskmovq (__m64 __A, __m64 __N, char *__P)
{
  _mm_maskmove_si64 (__A, __N, __P);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgb (__m64 __A, __m64 __B)
{
  return _mm_avg_pu8 (__A, __B);
}


extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_pu16 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_pavgw (__m64 __A, __m64 __B)
{
  return _mm_avg_pu16 (__A, __B);
}




extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_pu8 (__m64 __A, __m64 __B)
{
  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_m_psadbw (__m64 __A, __m64 __B)
{
  return _mm_sad_pu8 (__A, __B);
}
# 1200 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pi (__m64 *__P, __m64 __A)
{
  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_ps (float *__P, __m128 __A)
{
  __builtin_ia32_movntps (__P, (__v4sf)__A);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sfence (void)
{
  __builtin_ia32_sfence ();
}




extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_pause (void)
{
  __builtin_ia32_pause ();
}
# 1246 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 1 3 4
# 1247 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/xmmintrin.h" 2 3 4
# 36 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 2 3 4


typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef int __v4si __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__ ((__vector_size__ (16)));
typedef char __v16qi __attribute__ ((__vector_size__ (16)));



typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));






extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_sd (double __F)
{
  return __extension__ (__m128d){ __F, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_pd (double __F)
{
  return __extension__ (__m128d){ __F, __F };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd1 (double __F)
{
  return _mm_set1_pd (__F);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __X, __W };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_pd (double __W, double __X)
{
  return __extension__ (__m128d){ __W, __X };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_pd (void)
{
  return __extension__ (__m128d){ 0.0, 0.0 };
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd (double const *__P)
{
  return *(__m128d *)__P;
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_pd (double const *__P)
{
  return __builtin_ia32_loadupd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load1_pd (double const *__P)
{
  return _mm_set1_pd (*__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_sd (double const *__P)
{
  return _mm_set_sd (*__P);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_pd1 (double const *__P)
{
  return _mm_load1_pd (__P);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadr_pd (double const *__P)
{
  __m128d __tmp = _mm_load_pd (__P);
  return __builtin_ia32_shufpd (__tmp, __tmp, (((0) << 1) | (1)));
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd (double *__P, __m128d __A)
{
  *(__m128d *)__P = __A;
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_pd (double *__P, __m128d __A)
{
  __builtin_ia32_storeupd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_sd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_f64 (__m128d __A)
{
  return __builtin_ia32_vec_ext_v2df (__A, 0);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_pd (double *__P, __m128d __A)
{
  _mm_store_sd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeh_pd (double *__P, __m128d __A)
{
  *__P = __builtin_ia32_vec_ext_v2df (__A, 1);
}



extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store1_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (0))));
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_pd1 (double *__P, __m128d __A)
{
  _mm_store1_pd (__P, __A);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storer_pd (double *__P, __m128d __A)
{
  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, (((0) << 1) | (1))));
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si32 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64 (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi128_si64x (__m128i __A)
{
  return __builtin_ia32_vec_ext_v2di ((__v2di)__A, 0);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_div_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_pd (__m128d __A)
{
  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sqrt_sd (__m128d __A, __m128d __B)
{
  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);
  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmple_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpltsd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmplesd ((__v2df) __B,
         (__v2df)
         __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpneq_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnlt_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnle_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpngt_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnltsd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpnge_sd (__m128d __A, __m128d __B)
{
  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,
      (__v2df)
      __builtin_ia32_cmpnlesd ((__v2df) __B,
          (__v2df)
          __A));
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpunord_sd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_comineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomieq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomilt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomile_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomigt_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomige_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_ucomineq_sd (__m128d __A, __m128d __B)
{
  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64x (long long __q1, long long __q0)
{
  return __extension__ (__m128i)(__v2di){ __q0, __q1 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi64 (__m64 __q1, __m64 __q0)
{
  return _mm_set_epi64x ((long long)__q1, (long long)__q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)
{
  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,
        short __q3, short __q2, short __q1, short __q0)
{
  return __extension__ (__m128i)(__v8hi){
    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,
       char __q11, char __q10, char __q09, char __q08,
       char __q07, char __q06, char __q05, char __q04,
       char __q03, char __q02, char __q01, char __q00)
{
  return __extension__ (__m128i)(__v16qi){
    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,
    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15
  };
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64x (long long __A)
{
  return _mm_set_epi64x (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi64 (__m64 __A)
{
  return _mm_set_epi64 (__A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi32 (int __A)
{
  return _mm_set_epi32 (__A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi16 (short __A)
{
  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_set1_epi8 (char __A)
{
  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,
         __A, __A, __A, __A, __A, __A, __A, __A);
}




extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi64 (__m64 __q0, __m64 __q1)
{
  return _mm_set_epi64 (__q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)
{
  return _mm_set_epi32 (__q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,
         short __q4, short __q5, short __q6, short __q7)
{
  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,
        char __q04, char __q05, char __q06, char __q07,
        char __q08, char __q09, char __q10, char __q11,
        char __q12, char __q13, char __q14, char __q15)
{
  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,
         __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_load_si128 (__m128i const *__P)
{
  return *__P;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadu_si128 (__m128i const *__P)
{
  return (__m128i) __builtin_ia32_loaddqu ((char const *)__P);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_epi64 (__m128i const *__P)
{
  return _mm_set_epi64 ((__m64)0LL, *(__m64 *)__P);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_store_si128 (__m128i *__P, __m128i __B)
{
  *__P = __B;
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storeu_si128 (__m128i *__P, __m128i __B)
{
  __builtin_ia32_storedqu ((char *)__P, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_storel_epi64 (__m128i *__P, __m128i __B)
{
  *(long long *)__P = __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movepi64_pi64 (__m128i __B)
{
  return (__m64) __builtin_ia32_vec_ext_v2di ((__v2di)__B, 0);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movpi64_epi64 (__m64 __A)
{
  return _mm_set_epi64 ((__m64)0LL, __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_move_epi64 (__m128i __A)
{
  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_setzero_si128 (void)
{
  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_pd (__m128i __A)
{
  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtepi32_ps (__m128i __A)
{
  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpd_ps (__m128d __A)
{
  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_epi32 (__m128d __A)
{
  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttpd_pi32 (__m128d __A)
{
  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtpi32_pd (__m64 __A)
{
  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttps_epi32 (__m128 __A)
{
  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtps_pd (__m128 __A)
{
  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);
}


extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si32 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si ((__v2df) __A);
}



extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64 (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvttsd_si64x (__m128d __A)
{
  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);
}


extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsd_ss (__m128 __A, __m128d __B)
{
  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_sd (__m128d __A, int __B)
{
  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);
}



extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_sd (__m128d __A, long long __B)
{
  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);
}


extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtss_sd (__m128d __A, __m128 __B)
{
  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);
}
# 892 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 3 4
extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_pd (__m128d __A, __m128d __B)
{
  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadh_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_loadl_pd (__m128d __A, double const *__B)
{
  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_pd (__m128d __A)
{
  return __builtin_ia32_movmskpd ((__v2df)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packs_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_packus_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpackhi_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_unpacklo_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_add_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_adds_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sub_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_subs_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_madd_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmullw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_su32 (__m64 __A, __m64 __B)
{
  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mul_epu32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_slli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srai_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);
}
# 1179 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi16 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi32 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srli_epi64 (__m128i __A, int __B)
{
  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sll_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sra_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_srl_epi64 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_and_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pand128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_andnot_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_or_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_por128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_xor_si128 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pxor128 ((__v2di)__A, (__v2di)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpeq_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpeqd128 ((__v4si)__A, (__v4si)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__B, (__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__B, (__v8hi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmplt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__B, (__v4si)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cmpgt_epi32 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pcmpgtd128 ((__v4si)__A, (__v4si)__B);
}
# 1343 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 3 4
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_max_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epi16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_min_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_movemask_epi8 (__m128i __A)
{
  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mulhi_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);
}
# 1406 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/emmintrin.h" 3 4
extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)
{
  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_avg_epu16 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_sad_epu8 (__m128i __A, __m128i __B)
{
  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si32 (int *__A, int __B)
{
  __builtin_ia32_movnti (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si64 (long long int *__A, long long int __B)
{
  __builtin_ia32_movnti64 (__A, __B);
}


extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_si128 (__m128i *__A, __m128i __B)
{
  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_stream_pd (double *__A, __m128d __B)
{
  __builtin_ia32_movntpd (__A, (__v2df)__B);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_clflush (void const *__A)
{
  __builtin_ia32_clflush (__A);
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_lfence (void)
{
  __builtin_ia32_lfence ();
}

extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mfence (void)
{
  __builtin_ia32_mfence ();
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi32_si128 (int __A)
{
  return _mm_set_epi32 (0, 0, 0, __A);
}



extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}


extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_cvtsi64x_si128 (long long __A)
{
  return _mm_set_epi64x (0, __A);
}




extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_ps(__m128d __A)
{
  return (__m128) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castpd_si128(__m128d __A)
{
  return (__m128i) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_pd(__m128 __A)
{
  return (__m128d) __A;
}

extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castps_si128(__m128 __A)
{
  return (__m128i) __A;
}

extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_ps(__m128i __A)
{
  return (__m128) __A;
}

extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_castsi128_pd(__m128i __A)
{
  return (__m128d) __A;
}
# 634 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 736 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm
{



 typedef int length_t;

}
# 33 "/usr/include/glm/detail/type_int.hpp" 2 3 4





namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;
  typedef std::int64_t int64;

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;
  typedef std::uint64_t uint64;
# 80 "/usr/include/glm/detail/type_int.hpp" 3 4
 typedef signed int lowp_int_t;
 typedef signed int mediump_int_t;
 typedef signed int highp_int_t;

 typedef unsigned int lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef unsigned int highp_uint_t;
}

 typedef detail::int8 int8;
 typedef detail::int16 int16;
 typedef detail::int32 int32;
 typedef detail::int64 int64;

 typedef detail::uint8 uint8;
 typedef detail::uint16 uint16;
 typedef detail::uint32 uint32;
 typedef detail::uint64 uint64;
# 107 "/usr/include/glm/detail/type_int.hpp" 3 4
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 157 "/usr/include/glm/detail/type_int.hpp" 3 4
 typedef mediump_uint uint_t;
# 171 "/usr/include/glm/detail/type_int.hpp" 3 4
 typedef unsigned int uint;






 static_assert(sizeof(glm::int8) == 1, "int8 size isn't 1 byte on this platform");
 static_assert(sizeof(glm::int16) == 2, "int16 size isn't 2 bytes on this platform");
 static_assert(sizeof(glm::int32) == 4, "int32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::int64) == 8, "int64 size isn't 8 bytes on this platform");

 static_assert(sizeof(glm::uint8) == 1, "uint8 size isn't 1 byte on this platform");
 static_assert(sizeof(glm::uint16) == 2, "uint16 size isn't 2 bytes on this platform");
 static_assert(sizeof(glm::uint32) == 4, "uint32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::uint64) == 8, "uint64 size isn't 8 bytes on this platform");


}
# 33 "/usr/include/glm/fwd.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_float.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_float.hpp" 3 4
namespace glm{
namespace detail
{
 typedef float float32;
 typedef double float64;
}

 typedef float lowp_float_t;
 typedef float mediump_float_t;
 typedef double highp_float_t;
# 53 "/usr/include/glm/detail/type_float.hpp" 3 4
 typedef lowp_float_t lowp_float;






 typedef mediump_float_t mediump_float;






 typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 81 "/usr/include/glm/detail/type_float.hpp" 3 4
 typedef float float32;
 typedef double float64;




 static_assert(sizeof(glm::float32) == 4, "float32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::float64) == 8, "float64 size isn't 8 bytes on this platform");




}
# 34 "/usr/include/glm/fwd.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_vec.hpp" 1 3 4
# 32 "/usr/include/glm/detail/type_vec.hpp" 3 4
# 1 "/usr/include/glm/detail/precision.hpp" 1 3 4
# 32 "/usr/include/glm/detail/precision.hpp" 3 4
namespace glm
{
 enum precision
 {
  highp,
  mediump,
  lowp,
  defaultp = highp
 };
}
# 33 "/usr/include/glm/detail/type_vec.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_int.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_vec.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P> struct tvec1;
 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;
}

 typedef detail::tvec1<float, highp> highp_vec1_t;
 typedef detail::tvec1<float, mediump> mediump_vec1_t;
 typedef detail::tvec1<float, lowp> lowp_vec1_t;
 typedef detail::tvec1<int, highp> highp_ivec1_t;
 typedef detail::tvec1<int, mediump> mediump_ivec1_t;
 typedef detail::tvec1<int, lowp> lowp_ivec1_t;
 typedef detail::tvec1<uint, highp> highp_uvec1_t;
 typedef detail::tvec1<uint, mediump> mediump_uvec1_t;
 typedef detail::tvec1<uint, lowp> lowp_uvec1_t;
 typedef detail::tvec1<bool, highp> highp_bvec1_t;
 typedef detail::tvec1<bool, mediump> mediump_bvec1_t;
 typedef detail::tvec1<bool, lowp> lowp_bvec1_t;
# 65 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef detail::tvec2<float, highp> highp_vec2;






 typedef detail::tvec2<float, mediump> mediump_vec2;






 typedef detail::tvec2<float, lowp> lowp_vec2;






 typedef detail::tvec2<double, highp> highp_dvec2;






 typedef detail::tvec2<double, mediump> mediump_dvec2;






 typedef detail::tvec2<double, lowp> lowp_dvec2;






 typedef detail::tvec2<int, highp> highp_ivec2;






 typedef detail::tvec2<int, mediump> mediump_ivec2;






 typedef detail::tvec2<int, lowp> lowp_ivec2;






 typedef detail::tvec2<uint, highp> highp_uvec2;






 typedef detail::tvec2<uint, mediump> mediump_uvec2;






 typedef detail::tvec2<uint, lowp> lowp_uvec2;






 typedef detail::tvec2<bool, highp> highp_bvec2;






 typedef detail::tvec2<bool, mediump> mediump_bvec2;






 typedef detail::tvec2<bool, lowp> lowp_bvec2;
# 176 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef detail::tvec3<float, highp> highp_vec3;






 typedef detail::tvec3<float, mediump> mediump_vec3;






 typedef detail::tvec3<float, lowp> lowp_vec3;






 typedef detail::tvec3<double, highp> highp_dvec3;






 typedef detail::tvec3<double, mediump> mediump_dvec3;






 typedef detail::tvec3<double, lowp> lowp_dvec3;






 typedef detail::tvec3<int, highp> highp_ivec3;






 typedef detail::tvec3<int, mediump> mediump_ivec3;






 typedef detail::tvec3<int, lowp> lowp_ivec3;






 typedef detail::tvec3<uint, highp> highp_uvec3;






 typedef detail::tvec3<uint, mediump> mediump_uvec3;






 typedef detail::tvec3<uint, lowp> lowp_uvec3;





 typedef detail::tvec3<bool, highp> highp_bvec3;





 typedef detail::tvec3<bool, mediump> mediump_bvec3;





 typedef detail::tvec3<bool, lowp> lowp_bvec3;
# 282 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef detail::tvec4<float, highp> highp_vec4;





 typedef detail::tvec4<float, mediump> mediump_vec4;





 typedef detail::tvec4<float, lowp> lowp_vec4;





 typedef detail::tvec4<double, highp> highp_dvec4;





 typedef detail::tvec4<double, mediump> mediump_dvec4;





 typedef detail::tvec4<double, lowp> lowp_dvec4;





 typedef detail::tvec4<int, highp> highp_ivec4;





 typedef detail::tvec4<int, mediump> mediump_ivec4;





 typedef detail::tvec4<int, lowp> lowp_ivec4;





 typedef detail::tvec4<uint, highp> highp_uvec4;





 typedef detail::tvec4<uint, mediump> mediump_uvec4;





 typedef detail::tvec4<uint, lowp> lowp_uvec4;





 typedef detail::tvec4<bool, highp> highp_bvec4;





 typedef detail::tvec4<bool, mediump> mediump_bvec4;





 typedef detail::tvec4<bool, lowp> lowp_bvec4;
# 388 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef highp_vec2 vec2;




 typedef highp_vec3 vec3;




 typedef highp_vec4 vec4;
# 416 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef highp_dvec2 dvec2;




 typedef highp_dvec3 dvec3;




 typedef highp_dvec4 dvec4;
# 444 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef highp_ivec2 ivec2;




 typedef highp_ivec3 ivec3;




 typedef highp_ivec4 ivec4;
# 472 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef highp_uvec2 uvec2;




 typedef highp_uvec3 uvec3;




 typedef highp_uvec4 uvec4;
# 500 "/usr/include/glm/detail/type_vec.hpp" 3 4
 typedef highp_bvec2 bvec2;




 typedef highp_bvec3 bvec3;




 typedef highp_bvec4 bvec4;



}
# 35 "/usr/include/glm/fwd.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_mat.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_mat.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;
 template <typename T, precision P> struct tmat2x2;
 template <typename T, precision P> struct tmat2x3;
 template <typename T, precision P> struct tmat2x4;
 template <typename T, precision P> struct tmat3x2;
 template <typename T, precision P> struct tmat3x3;
 template <typename T, precision P> struct tmat3x4;
 template <typename T, precision P> struct tmat4x2;
 template <typename T, precision P> struct tmat4x3;
 template <typename T, precision P> struct tmat4x4;

 template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
 struct outerProduct_trait{};

 template <template <class, precision> class matType, typename T, precision P>
 struct compute_inverse{};
}
# 65 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x2<float, lowp> lowp_mat2;






 typedef detail::tmat2x2<float, mediump> mediump_mat2;






 typedef detail::tmat2x2<float, highp> highp_mat2;






 typedef detail::tmat2x2<float, lowp> lowp_mat2x2;






 typedef detail::tmat2x2<float, mediump> mediump_mat2x2;






 typedef detail::tmat2x2<float, highp> highp_mat2x2;
# 112 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x3<float, lowp> lowp_mat2x3;






 typedef detail::tmat2x3<float, mediump> mediump_mat2x3;






 typedef detail::tmat2x3<float, highp> highp_mat2x3;
# 138 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x4<float, lowp> lowp_mat2x4;






 typedef detail::tmat2x4<float, mediump> mediump_mat2x4;






 typedef detail::tmat2x4<float, highp> highp_mat2x4;
# 164 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x2<float, lowp> lowp_mat3x2;






 typedef detail::tmat3x2<float, mediump> mediump_mat3x2;






 typedef detail::tmat3x2<float, highp> highp_mat3x2;
# 190 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x3<float, lowp> lowp_mat3;






 typedef detail::tmat3x3<float, mediump> mediump_mat3;






 typedef detail::tmat3x3<float, highp> highp_mat3;






 typedef detail::tmat3x3<float, lowp> lowp_mat3x3;






 typedef detail::tmat3x3<float, mediump> mediump_mat3x3;






 typedef detail::tmat3x3<float, highp> highp_mat3x3;
# 237 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x4<float, lowp> lowp_mat3x4;






 typedef detail::tmat3x4<float, mediump> mediump_mat3x4;






 typedef detail::tmat3x4<float, highp> highp_mat3x4;
# 263 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x2<float, lowp> lowp_mat4x2;






 typedef detail::tmat4x2<float, mediump> mediump_mat4x2;






 typedef detail::tmat4x2<float, highp> highp_mat4x2;
# 289 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x3<float, lowp> lowp_mat4x3;






 typedef detail::tmat4x3<float, mediump> mediump_mat4x3;






 typedef detail::tmat4x3<float, highp> highp_mat4x3;
# 316 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x4<float, lowp> lowp_mat4;






 typedef detail::tmat4x4<float, mediump> mediump_mat4;






 typedef detail::tmat4x4<float, highp> highp_mat4;






 typedef detail::tmat4x4<float, lowp> lowp_mat4x4;






 typedef detail::tmat4x4<float, mediump> mediump_mat4x4;






 typedef detail::tmat4x4<float, highp> highp_mat4x4;
# 385 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef highp_mat2x2 mat2x2;




 typedef highp_mat2x3 mat2x3;




 typedef highp_mat2x4 mat2x4;




 typedef highp_mat3x2 mat3x2;




 typedef highp_mat3x3 mat3x3;




 typedef highp_mat3x4 mat3x4;




 typedef highp_mat4x2 mat4x2;




 typedef highp_mat4x3 mat4x3;




 typedef highp_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 454 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x2<double, lowp> lowp_dmat2;





 typedef detail::tmat2x2<double, mediump> mediump_dmat2;





 typedef detail::tmat2x2<double, highp> highp_dmat2;





 typedef detail::tmat2x2<double, lowp> lowp_dmat2x2;





 typedef detail::tmat2x2<double, mediump> mediump_dmat2x2;





 typedef detail::tmat2x2<double, highp> highp_dmat2x2;
# 495 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x3<double, lowp> lowp_dmat2x3;





 typedef detail::tmat2x3<double, mediump> mediump_dmat2x3;





 typedef detail::tmat2x3<double, highp> highp_dmat2x3;
# 518 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat2x4<double, lowp> lowp_dmat2x4;





 typedef detail::tmat2x4<double, mediump> mediump_dmat2x4;





 typedef detail::tmat2x4<double, highp> highp_dmat2x4;
# 541 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x2<double, lowp> lowp_dmat3x2;





 typedef detail::tmat3x2<double, mediump> mediump_dmat3x2;





 typedef detail::tmat3x2<double, highp> highp_dmat3x2;
# 564 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x3<float, lowp> lowp_dmat3;





 typedef detail::tmat3x3<double, mediump> mediump_dmat3;





 typedef detail::tmat3x3<double, highp> highp_dmat3;





 typedef detail::tmat3x3<double, lowp> lowp_dmat3x3;





 typedef detail::tmat3x3<double, mediump> mediump_dmat3x3;





 typedef detail::tmat3x3<double, highp> highp_dmat3x3;
# 605 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat3x4<double, lowp> lowp_dmat3x4;





 typedef detail::tmat3x4<double, mediump> mediump_dmat3x4;





 typedef detail::tmat3x4<double, highp> highp_dmat3x4;
# 628 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x2<double, lowp> lowp_dmat4x2;





 typedef detail::tmat4x2<double, mediump> mediump_dmat4x2;





 typedef detail::tmat4x2<double, highp> highp_dmat4x2;
# 651 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x3<double, lowp> lowp_dmat4x3;





 typedef detail::tmat4x3<double, mediump> mediump_dmat4x3;





 typedef detail::tmat4x3<double, highp> highp_dmat4x3;
# 674 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef detail::tmat4x4<double, lowp> lowp_dmat4;





 typedef detail::tmat4x4<double, mediump> mediump_dmat4;





 typedef detail::tmat4x4<double, highp> highp_dmat4;





 typedef detail::tmat4x4<double, lowp> lowp_dmat4x4;





 typedef detail::tmat4x4<double, mediump> mediump_dmat4x4;





 typedef detail::tmat4x4<double, highp> highp_dmat4x4;
# 733 "/usr/include/glm/detail/type_mat.hpp" 3 4
 typedef highp_dmat2x2 dmat2;




 typedef highp_dmat3x3 dmat3;




 typedef highp_dmat4x4 dmat4;




 typedef highp_dmat2x2 dmat2x2;




 typedef highp_dmat2x3 dmat2x3;




 typedef highp_dmat2x4 dmat2x4;




 typedef highp_dmat3x2 dmat3x2;




 typedef highp_dmat3x3 dmat3x3;




 typedef highp_dmat3x4 dmat3x4;




 typedef highp_dmat4x2 dmat4x2;




 typedef highp_dmat4x3 dmat4x3;




 typedef highp_dmat4x4 dmat4x4;




}
# 36 "/usr/include/glm/fwd.hpp" 2 3 4



namespace glm{
namespace detail
{
 template <typename T, precision P> struct tquat;
}





 typedef detail::tquat<float, lowp> lowp_quat;




 typedef detail::tquat<float, mediump> mediump_quat;




 typedef detail::tquat<float, highp> highp_quat;
# 69 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_quat quat;





 typedef lowp_quat lowp_fquat;




 typedef mediump_quat mediump_fquat;




 typedef highp_quat highp_fquat;




 typedef quat fquat;





 typedef detail::tquat<double, lowp> lowp_dquat;




 typedef detail::tquat<double, mediump> mediump_dquat;




 typedef detail::tquat<double, highp> highp_dquat;
# 118 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_dquat dquat;


}



namespace glm
{





 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;



 typedef detail::int8 int8_t;



 typedef detail::int16 int16_t;



 typedef detail::int32 int32_t;



 typedef detail::int64 int64_t;



 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;





 typedef detail::tvec1<i8, lowp> lowp_i8vec1;



 typedef detail::tvec2<i8, lowp> lowp_i8vec2;



 typedef detail::tvec3<i8, lowp> lowp_i8vec3;



 typedef detail::tvec4<i8, lowp> lowp_i8vec4;




 typedef detail::tvec1<i8, mediump> mediump_i8vec1;



 typedef detail::tvec2<i8, mediump> mediump_i8vec2;



 typedef detail::tvec3<i8, mediump> mediump_i8vec3;



 typedef detail::tvec4<i8, mediump> mediump_i8vec4;




 typedef detail::tvec1<i8, highp> highp_i8vec1;



 typedef detail::tvec2<i8, highp> highp_i8vec2;



 typedef detail::tvec3<i8, highp> highp_i8vec3;



 typedef detail::tvec4<i8, highp> highp_i8vec4;
# 388 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_i8vec1 i8vec1;



 typedef highp_i8vec2 i8vec2;



 typedef highp_i8vec3 i8vec3;



 typedef highp_i8vec4 i8vec4;





 typedef detail::tvec1<i16, lowp> lowp_i16vec1;



 typedef detail::tvec2<i16, lowp> lowp_i16vec2;



 typedef detail::tvec3<i16, lowp> lowp_i16vec3;



 typedef detail::tvec4<i16, lowp> lowp_i16vec4;




 typedef detail::tvec1<i16, mediump> mediump_i16vec1;



 typedef detail::tvec2<i16, mediump> mediump_i16vec2;



 typedef detail::tvec3<i16, mediump> mediump_i16vec3;



 typedef detail::tvec4<i16, mediump> mediump_i16vec4;




 typedef detail::tvec1<i16, highp> highp_i16vec1;



 typedef detail::tvec2<i16, highp> highp_i16vec2;



 typedef detail::tvec3<i16, highp> highp_i16vec3;



 typedef detail::tvec4<i16, highp> highp_i16vec4;
# 468 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_i16vec1 i16vec1;



 typedef highp_i16vec2 i16vec2;



 typedef highp_i16vec3 i16vec3;



 typedef highp_i16vec4 i16vec4;





 typedef detail::tvec1<i32, lowp> lowp_i32vec1;



 typedef detail::tvec2<i32, lowp> lowp_i32vec2;



 typedef detail::tvec3<i32, lowp> lowp_i32vec3;



 typedef detail::tvec4<i32, lowp> lowp_i32vec4;




 typedef detail::tvec1<i32, mediump> mediump_i32vec1;



 typedef detail::tvec2<i32, mediump> mediump_i32vec2;



 typedef detail::tvec3<i32, mediump> mediump_i32vec3;



 typedef detail::tvec4<i32, mediump> mediump_i32vec4;




 typedef detail::tvec1<i32, highp> highp_i32vec1;



 typedef detail::tvec2<i32, highp> highp_i32vec2;



 typedef detail::tvec3<i32, highp> highp_i32vec3;



 typedef detail::tvec4<i32, highp> highp_i32vec4;
# 547 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;





 typedef detail::tvec1<i32, lowp> lowp_i32vec1;



 typedef detail::tvec2<i32, lowp> lowp_i32vec2;



 typedef detail::tvec3<i32, lowp> lowp_i32vec3;



 typedef detail::tvec4<i32, lowp> lowp_i32vec4;




 typedef detail::tvec1<i32, mediump> mediump_i32vec1;



 typedef detail::tvec2<i32, mediump> mediump_i32vec2;



 typedef detail::tvec3<i32, mediump> mediump_i32vec3;



 typedef detail::tvec4<i32, mediump> mediump_i32vec4;




 typedef detail::tvec1<i32, highp> highp_i32vec1;



 typedef detail::tvec2<i32, highp> highp_i32vec2;



 typedef detail::tvec3<i32, highp> highp_i32vec3;



 typedef detail::tvec4<i32, highp> highp_i32vec4;
# 626 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;






 typedef detail::tvec1<i64, lowp> lowp_i64vec1;



 typedef detail::tvec2<i64, lowp> lowp_i64vec2;



 typedef detail::tvec3<i64, lowp> lowp_i64vec3;



 typedef detail::tvec4<i64, lowp> lowp_i64vec4;




 typedef detail::tvec1<i64, mediump> mediump_i64vec1;



 typedef detail::tvec2<i64, mediump> mediump_i64vec2;



 typedef detail::tvec3<i64, mediump> mediump_i64vec3;



 typedef detail::tvec4<i64, mediump> mediump_i64vec4;




 typedef detail::tvec1<i64, highp> highp_i64vec1;



 typedef detail::tvec2<i64, highp> highp_i64vec2;



 typedef detail::tvec3<i64, highp> highp_i64vec3;



 typedef detail::tvec4<i64, highp> highp_i64vec4;
# 706 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_i64vec1 i64vec1;



 typedef highp_i64vec2 i64vec2;



 typedef highp_i64vec3 i64vec3;



 typedef highp_i64vec4 i64vec4;
# 727 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;




 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;




 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;





 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;





 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;





 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;



 typedef detail::uint8 uint8_t;



 typedef detail::uint16 uint16_t;



 typedef detail::uint32 uint32_t;



 typedef detail::uint64 uint64_t;



 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;






 typedef detail::tvec1<u8, lowp> lowp_u8vec1;



 typedef detail::tvec2<u8, lowp> lowp_u8vec2;



 typedef detail::tvec3<u8, lowp> lowp_u8vec3;



 typedef detail::tvec4<u8, lowp> lowp_u8vec4;




 typedef detail::tvec1<u8, mediump> mediump_u8vec1;



 typedef detail::tvec2<u8, mediump> mediump_u8vec2;



 typedef detail::tvec3<u8, mediump> mediump_u8vec3;



 typedef detail::tvec4<u8, mediump> mediump_u8vec4;




 typedef detail::tvec1<u8, highp> highp_u8vec1;



 typedef detail::tvec2<u8, highp> highp_u8vec2;



 typedef detail::tvec3<u8, highp> highp_u8vec3;



 typedef detail::tvec4<u8, highp> highp_u8vec4;
# 991 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_u8vec1 u8vec1;



 typedef highp_u8vec2 u8vec2;



 typedef highp_u8vec3 u8vec3;



 typedef highp_u8vec4 u8vec4;





 typedef detail::tvec1<u16, lowp> lowp_u16vec1;



 typedef detail::tvec2<u16, lowp> lowp_u16vec2;



 typedef detail::tvec3<u16, lowp> lowp_u16vec3;



 typedef detail::tvec4<u16, lowp> lowp_u16vec4;




 typedef detail::tvec1<u16, mediump> mediump_u16vec1;



 typedef detail::tvec2<u16, mediump> mediump_u16vec2;



 typedef detail::tvec3<u16, mediump> mediump_u16vec3;



 typedef detail::tvec4<u16, mediump> mediump_u16vec4;




 typedef detail::tvec1<u16, highp> highp_u16vec1;



 typedef detail::tvec2<u16, highp> highp_u16vec2;



 typedef detail::tvec3<u16, highp> highp_u16vec3;



 typedef detail::tvec4<u16, highp> highp_u16vec4;
# 1071 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_u16vec1 u16vec1;



 typedef highp_u16vec2 u16vec2;



 typedef highp_u16vec3 u16vec3;



 typedef highp_u16vec4 u16vec4;





 typedef detail::tvec1<u32, lowp> lowp_u32vec1;



 typedef detail::tvec2<u32, lowp> lowp_u32vec2;



 typedef detail::tvec3<u32, lowp> lowp_u32vec3;



 typedef detail::tvec4<u32, lowp> lowp_u32vec4;




 typedef detail::tvec1<u32, mediump> mediump_u32vec1;



 typedef detail::tvec2<u32, mediump> mediump_u32vec2;



 typedef detail::tvec3<u32, mediump> mediump_u32vec3;



 typedef detail::tvec4<u32, mediump> mediump_u32vec4;




 typedef detail::tvec1<u32, highp> highp_u32vec1;



 typedef detail::tvec2<u32, highp> highp_u32vec2;



 typedef detail::tvec3<u32, highp> highp_u32vec3;



 typedef detail::tvec4<u32, highp> highp_u32vec4;
# 1150 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;





 typedef detail::tvec1<u32, lowp> lowp_u32vec1;



 typedef detail::tvec2<u32, lowp> lowp_u32vec2;



 typedef detail::tvec3<u32, lowp> lowp_u32vec3;



 typedef detail::tvec4<u32, lowp> lowp_u32vec4;




 typedef detail::tvec1<u32, mediump> mediump_u32vec1;



 typedef detail::tvec2<u32, mediump> mediump_u32vec2;



 typedef detail::tvec3<u32, mediump> mediump_u32vec3;



 typedef detail::tvec4<u32, mediump> mediump_u32vec4;




 typedef detail::tvec1<u32, highp> highp_u32vec1;



 typedef detail::tvec2<u32, highp> highp_u32vec2;



 typedef detail::tvec3<u32, highp> highp_u32vec3;



 typedef detail::tvec4<u32, highp> highp_u32vec4;
# 1229 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;






 typedef detail::tvec1<u64, lowp> lowp_u64vec1;



 typedef detail::tvec2<u64, lowp> lowp_u64vec2;



 typedef detail::tvec3<u64, lowp> lowp_u64vec3;



 typedef detail::tvec4<u64, lowp> lowp_u64vec4;




 typedef detail::tvec1<u64, mediump> mediump_u64vec1;



 typedef detail::tvec2<u64, mediump> mediump_u64vec2;



 typedef detail::tvec3<u64, mediump> mediump_u64vec3;



 typedef detail::tvec4<u64, mediump> mediump_u64vec4;




 typedef detail::tvec1<u64, highp> highp_u64vec1;



 typedef detail::tvec2<u64, highp> highp_u64vec2;



 typedef detail::tvec3<u64, highp> highp_u64vec3;



 typedef detail::tvec4<u64, highp> highp_u64vec4;
# 1309 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_u64vec1 u64vec1;



 typedef highp_u64vec2 u64vec2;



 typedef highp_u64vec3 u64vec3;



 typedef highp_u64vec4 u64vec4;
# 1330 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 mediump_float32;



 typedef detail::float64 mediump_float64;



 typedef detail::float32 mediump_float32_t;



 typedef detail::float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef detail::float32 highp_float32;



 typedef detail::float64 highp_float64;



 typedef detail::float32 highp_float32_t;



 typedef detail::float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 1507 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_float32 float32;



 typedef highp_float64 float64;



 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef detail::tvec1<float, lowp> lowp_vec1;



 typedef detail::tvec2<float, lowp> lowp_vec2;



 typedef detail::tvec3<float, lowp> lowp_vec3;



 typedef detail::tvec4<float, lowp> lowp_vec4;



 typedef detail::tvec1<float, lowp> lowp_fvec1;



 typedef detail::tvec2<float, lowp> lowp_fvec2;



 typedef detail::tvec3<float, lowp> lowp_fvec3;



 typedef detail::tvec4<float, lowp> lowp_fvec4;





 typedef detail::tvec1<float, mediump> mediump_vec1;



 typedef detail::tvec2<float, mediump> mediump_vec2;



 typedef detail::tvec3<float, mediump> mediump_vec3;



 typedef detail::tvec4<float, mediump> mediump_vec4;



 typedef detail::tvec1<float, mediump> mediump_fvec1;



 typedef detail::tvec2<float, mediump> mediump_fvec2;



 typedef detail::tvec3<float, mediump> mediump_fvec3;



 typedef detail::tvec4<float, mediump> mediump_fvec4;





 typedef detail::tvec1<float, highp> highp_vec1;



 typedef detail::tvec2<float, highp> highp_vec2;



 typedef detail::tvec3<float, highp> highp_vec3;



 typedef detail::tvec4<float, highp> highp_vec4;



 typedef detail::tvec1<float, highp> highp_fvec1;



 typedef detail::tvec2<float, highp> highp_fvec2;



 typedef detail::tvec3<float, highp> highp_fvec3;



 typedef detail::tvec4<float, highp> highp_fvec4;




 typedef detail::tvec1<f32, lowp> lowp_f32vec1;



 typedef detail::tvec2<f32, lowp> lowp_f32vec2;



 typedef detail::tvec3<f32, lowp> lowp_f32vec3;



 typedef detail::tvec4<f32, lowp> lowp_f32vec4;



 typedef detail::tvec1<f32, mediump> mediump_f32vec1;



 typedef detail::tvec2<f32, mediump> mediump_f32vec2;



 typedef detail::tvec3<f32, mediump> mediump_f32vec3;



 typedef detail::tvec4<f32, mediump> mediump_f32vec4;



 typedef detail::tvec1<f32, highp> highp_f32vec1;



 typedef detail::tvec2<f32, highp> highp_f32vec2;



 typedef detail::tvec3<f32, highp> highp_f32vec3;



 typedef detail::tvec4<f32, highp> highp_f32vec4;




 typedef detail::tvec1<f64, lowp> lowp_f64vec1;



 typedef detail::tvec2<f64, lowp> lowp_f64vec2;



 typedef detail::tvec3<f64, lowp> lowp_f64vec3;



 typedef detail::tvec4<f64, lowp> lowp_f64vec4;



 typedef detail::tvec1<f64, mediump> mediump_f64vec1;



 typedef detail::tvec2<f64, mediump> mediump_f64vec2;



 typedef detail::tvec3<f64, mediump> mediump_f64vec3;



 typedef detail::tvec4<f64, mediump> mediump_f64vec4;



 typedef detail::tvec1<f64, highp> highp_f64vec1;



 typedef detail::tvec2<f64, highp> highp_f64vec2;



 typedef detail::tvec3<f64, highp> highp_f64vec3;



 typedef detail::tvec4<f64, highp> highp_f64vec4;
# 1739 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, lowp> lowp_fmat2x2;



 typedef detail::tmat2x3<f32, lowp> lowp_fmat2x3;



 typedef detail::tmat2x4<f32, lowp> lowp_fmat2x4;



 typedef detail::tmat3x2<f32, lowp> lowp_fmat3x2;



 typedef detail::tmat3x3<f32, lowp> lowp_fmat3x3;



 typedef detail::tmat3x4<f32, lowp> lowp_fmat3x4;



 typedef detail::tmat4x2<f32, lowp> lowp_fmat4x2;



 typedef detail::tmat4x3<f32, lowp> lowp_fmat4x3;



 typedef detail::tmat4x4<f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 1796 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, mediump> mediump_fmat2x2;



 typedef detail::tmat2x3<f32, mediump> mediump_fmat2x3;



 typedef detail::tmat2x4<f32, mediump> mediump_fmat2x4;



 typedef detail::tmat3x2<f32, mediump> mediump_fmat3x2;



 typedef detail::tmat3x3<f32, mediump> mediump_fmat3x3;



 typedef detail::tmat3x4<f32, mediump> mediump_fmat3x4;



 typedef detail::tmat4x2<f32, mediump> mediump_fmat4x2;



 typedef detail::tmat4x3<f32, mediump> mediump_fmat4x3;



 typedef detail::tmat4x4<f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 1854 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, highp> highp_fmat2x2;



 typedef detail::tmat2x3<f32, highp> highp_fmat2x3;



 typedef detail::tmat2x4<f32, highp> highp_fmat2x4;



 typedef detail::tmat3x2<f32, highp> highp_fmat3x2;



 typedef detail::tmat3x3<f32, highp> highp_fmat3x3;



 typedef detail::tmat3x4<f32, highp> highp_fmat3x4;



 typedef detail::tmat4x2<f32, highp> highp_fmat4x2;



 typedef detail::tmat4x3<f32, highp> highp_fmat4x3;



 typedef detail::tmat4x4<f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 1911 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, lowp> lowp_f32mat2x2;



 typedef detail::tmat2x3<f32, lowp> lowp_f32mat2x3;



 typedef detail::tmat2x4<f32, lowp> lowp_f32mat2x4;



 typedef detail::tmat3x2<f32, lowp> lowp_f32mat3x2;



 typedef detail::tmat3x3<f32, lowp> lowp_f32mat3x3;



 typedef detail::tmat3x4<f32, lowp> lowp_f32mat3x4;



 typedef detail::tmat4x2<f32, lowp> lowp_f32mat4x2;



 typedef detail::tmat4x3<f32, lowp> lowp_f32mat4x3;



 typedef detail::tmat4x4<f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1969 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, mediump> mediump_f32mat2x2;



 typedef detail::tmat2x3<f32, mediump> mediump_f32mat2x3;



 typedef detail::tmat2x4<f32, mediump> mediump_f32mat2x4;



 typedef detail::tmat3x2<f32, mediump> mediump_f32mat3x2;



 typedef detail::tmat3x3<f32, mediump> mediump_f32mat3x3;



 typedef detail::tmat3x4<f32, mediump> mediump_f32mat3x4;



 typedef detail::tmat4x2<f32, mediump> mediump_f32mat4x2;



 typedef detail::tmat4x3<f32, mediump> mediump_f32mat4x3;



 typedef detail::tmat4x4<f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 2028 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f32, highp> highp_f32mat2x2;



 typedef detail::tmat2x3<f32, highp> highp_f32mat2x3;



 typedef detail::tmat2x4<f32, highp> highp_f32mat2x4;



 typedef detail::tmat3x2<f32, highp> highp_f32mat3x2;



 typedef detail::tmat3x3<f32, highp> highp_f32mat3x3;



 typedef detail::tmat3x4<f32, highp> highp_f32mat3x4;



 typedef detail::tmat4x2<f32, highp> highp_f32mat4x2;



 typedef detail::tmat4x3<f32, highp> highp_f32mat4x3;



 typedef detail::tmat4x4<f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 2086 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f64, lowp> lowp_f64mat2x2;



 typedef detail::tmat2x3<f64, lowp> lowp_f64mat2x3;



 typedef detail::tmat2x4<f64, lowp> lowp_f64mat2x4;



 typedef detail::tmat3x2<f64, lowp> lowp_f64mat3x2;



 typedef detail::tmat3x3<f64, lowp> lowp_f64mat3x3;



 typedef detail::tmat3x4<f64, lowp> lowp_f64mat3x4;



 typedef detail::tmat4x2<f64, lowp> lowp_f64mat4x2;



 typedef detail::tmat4x3<f64, lowp> lowp_f64mat4x3;



 typedef detail::tmat4x4<f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 2144 "/usr/include/glm/fwd.hpp" 3 4
 typedef detail::tmat2x2<f64, mediump> mediump_f64mat2x2;



 typedef detail::tmat2x3<f64, mediump> mediump_f64mat2x3;



 typedef detail::tmat2x4<f64, mediump> mediump_f64mat2x4;



 typedef detail::tmat3x2<f64, mediump> mediump_f64mat3x2;



 typedef detail::tmat3x3<f64, mediump> mediump_f64mat3x3;



 typedef detail::tmat3x4<f64, mediump> mediump_f64mat3x4;



 typedef detail::tmat4x2<f64, mediump> mediump_f64mat4x2;



 typedef detail::tmat4x3<f64, mediump> mediump_f64mat4x3;



 typedef detail::tmat4x4<f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef detail::tmat2x2<f64, highp> highp_f64mat2x2;



 typedef detail::tmat2x3<f64, highp> highp_f64mat2x3;



 typedef detail::tmat2x4<f64, highp> highp_f64mat2x4;



 typedef detail::tmat3x2<f64, highp> highp_f64mat3x2;



 typedef detail::tmat3x3<f64, highp> highp_f64mat3x3;



 typedef detail::tmat3x4<f64, highp> highp_f64mat3x4;



 typedef detail::tmat4x2<f64, highp> highp_f64mat4x2;



 typedef detail::tmat4x3<f64, highp> highp_f64mat4x3;



 typedef detail::tmat4x4<f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;






 typedef detail::tquat<f32, lowp> lowp_f32quat;



 typedef detail::tquat<f64, lowp> lowp_f64quat;



 typedef detail::tquat<f32, mediump> mediump_f32quat;



 typedef detail::tquat<f64, mediump> mediump_f64quat;



 typedef detail::tquat<f32, highp> highp_f32quat;



 typedef detail::tquat<f64, highp> highp_f64quat;
# 2353 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_f32vec1 fvec1;



 typedef highp_f32vec2 fvec2;



 typedef highp_f32vec3 fvec3;



 typedef highp_f32vec4 fvec4;



 typedef highp_f32mat2x2 fmat2x2;



 typedef highp_f32mat2x3 fmat2x3;



 typedef highp_f32mat2x4 fmat2x4;



 typedef highp_f32mat3x2 fmat3x2;



 typedef highp_f32mat3x3 fmat3x3;



 typedef highp_f32mat3x4 fmat3x4;



 typedef highp_f32mat4x2 fmat4x2;



 typedef highp_f32mat4x3 fmat4x3;



 typedef highp_f32mat4x4 fmat4x4;



 typedef fmat2x2 fmat2;



 typedef fmat3x3 fmat3;



 typedef fmat4x4 fmat4;



 typedef highp_fquat fquat;





 typedef highp_f32vec1 f32vec1;



 typedef highp_f32vec2 f32vec2;



 typedef highp_f32vec3 f32vec3;



 typedef highp_f32vec4 f32vec4;



 typedef highp_f32mat2x2 f32mat2x2;



 typedef highp_f32mat2x3 f32mat2x3;



 typedef highp_f32mat2x4 f32mat2x4;



 typedef highp_f32mat3x2 f32mat3x2;



 typedef highp_f32mat3x3 f32mat3x3;



 typedef highp_f32mat3x4 f32mat3x4;



 typedef highp_f32mat4x2 f32mat4x2;



 typedef highp_f32mat4x3 f32mat4x3;



 typedef highp_f32mat4x4 f32mat4x4;



 typedef f32mat2x2 f32mat2;



 typedef f32mat3x3 f32mat3;



 typedef f32mat4x4 f32mat4;



 typedef highp_f32quat f32quat;
# 2530 "/usr/include/glm/fwd.hpp" 3 4
 typedef highp_f64vec1 f64vec1;



 typedef highp_f64vec2 f64vec2;



 typedef highp_f64vec3 f64vec3;



 typedef highp_f64vec4 f64vec4;



 typedef highp_f64mat2x2 f64mat2x2;



 typedef highp_f64mat2x3 f64mat2x3;



 typedef highp_f64mat2x4 f64mat2x4;



 typedef highp_f64mat3x2 f64mat3x2;



 typedef highp_f64mat3x3 f64mat3x3;



 typedef highp_f64mat3x4 f64mat3x4;



 typedef highp_f64mat4x2 f64mat4x2;



 typedef highp_f64mat4x3 f64mat4x3;



 typedef highp_f64mat4x4 f64mat4x4;



 typedef f64mat2x2 f64mat2;



 typedef f64mat3x3 f64mat3;



 typedef f64mat4x4 f64mat4;



 typedef highp_f64quat f64quat;

}
# 89 "/usr/include/glm/glm.hpp" 2 3 4






# 1 "/usr/include/glm/vec2.hpp" 1 3 4
# 32 "/usr/include/glm/vec2.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec2.hpp" 1 3 4
# 33 "/usr/include/glm/detail/type_vec2.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_vec2.hpp" 2 3 4
# 44 "/usr/include/glm/detail/type_vec2.hpp" 3 4
# 1 "/usr/include/c++/4.8/cstddef" 1 3 4
# 39 "/usr/include/c++/4.8/cstddef" 3 4
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 45 "/usr/include/glm/detail/type_vec2.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tvec2
 {



  enum ctor{_null};

  typedef tvec2<T, P> type;
  typedef tvec2<bool, P> bool_type;
  typedef T value_type;
  typedef int size_type;




  constexpr length_t length() const;
# 88 "/usr/include/glm/detail/type_vec2.hpp" 3 4
   union {T x, r, s;};
   union {T y, g, t;};
# 99 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  T & operator[](length_t i);
  T const & operator[](length_t i) const;




  tvec2();
  tvec2(tvec2<T, P> const & v);
  template <precision Q>
  tvec2(tvec2<T, Q> const & v);


  template <typename U>
  tvec2(std::initializer_list<U> const & v);





  explicit tvec2(
   ctor);
  explicit tvec2(
   T const & s);
  explicit tvec2(
   T const & s1,
   T const & s2);
# 141 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  template <typename U, typename V>
  explicit tvec2(
   U const & x,
   V const & y);





  template <typename U, precision Q>
  explicit tvec2(tvec2<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec2(tvec3<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec2(tvec4<U, Q> const & v);




  tvec2<T, P> & operator= (tvec2<T, P> const & v);
  template <typename U>
  tvec2<T, P> & operator= (tvec2<U, P> const & v);

  template <typename U>
  tvec2<T, P> & operator+=(U s);
  template <typename U>
  tvec2<T, P> & operator+=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator-=(U s);
  template <typename U>
  tvec2<T, P> & operator-=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator*=(U s);
  template <typename U>
  tvec2<T, P> & operator*=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator/=(U s);
  template <typename U>
  tvec2<T, P> & operator/=(tvec2<U, P> const & v);




  tvec2<T, P> & operator++();
  tvec2<T, P> & operator--();
  tvec2<T, P> operator++(int);
  tvec2<T, P> operator--(int);




  template <typename U>
  tvec2<T, P> & operator%= (U s);
  template <typename U>
  tvec2<T, P> & operator%= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator&= (U s);
  template <typename U>
  tvec2<T, P> & operator&= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator|= (U s);
  template <typename U>
  tvec2<T, P> & operator|= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator^= (U s);
  template <typename U>
  tvec2<T, P> & operator^= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator<<=(U s);
  template <typename U>
  tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator>>=(U s);
  template <typename U>
  tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
 };

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator+(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator-(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator- (tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator*(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator/(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator%(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator&(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator|(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator^(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator<<(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator>>(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator~(tvec2<T, P> const & v);

}
}


# 1 "/usr/include/glm/detail/type_vec2.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_vec2.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tvec2<T, P>::length() const
 {
  return 2;
 }




 template <typename T, precision P>
 inline T & tvec2<T, P>::operator[](length_t i)
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec2.inl", 44, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T, precision P>
 inline T const & tvec2<T, P>::operator[](length_t i) const
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec2.inl", 51, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T, precision P>
 inline tvec2<T, P>::tvec2() :
  x(0),
  y(0)
 {}

 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(tvec2<T, P> const & v) :
  x(v.x),
  y(v.y)
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec2<T, P>::tvec2(tvec2<T, Q> const & v) :
  x(v.x),
  y(v.y)
 {}


 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P>::tvec2(std::initializer_list<U> const & v) :
  x(static_cast<T>(v.begin()[0])),
  y(static_cast<T>(v.begin()[1]))
 {
  ((v.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("v.size() == this->length()", "/usr/include/glm/detail/type_vec2.inl", 84, __PRETTY_FUNCTION__));
 }





 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(ctor)
 {}

 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(T const & s) :
  x(s),
  y(s)
 {}

 template <typename T, precision P>
 inline tvec2<T, P>::tvec2
 (
  T const & s1,
  T const & s2
 ) :
  x(s1),
  y(s2)
 {}




 template <typename T, precision P>
 template <typename U, typename V>
 inline tvec2<T, P>::tvec2
 (
  U const & a,
  V const & b
 ) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b))
 {}




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2
 (
  tvec2<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2
 (
  tvec3<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2
 (
  tvec4<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y))
 {}




 template <typename T, precision P>
 inline tvec2<T, P> & tvec2<T, P>::operator=
 (
  tvec2<T, P> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator=
 (
  tvec2<U, P> const & v
 )
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator+=
 (
  U s
 )
 {
  this->x += static_cast<T>(s);
  this->y += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator+=
 (
  tvec2<U, P> const & v
 )
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator-=
 (
  U s
 )
 {
  this->x -= static_cast<T>(s);
  this->y -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator-=
 (
  tvec2<U, P> const & v
 )
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator*=
 (
  U s
 )
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator*=
 (
  tvec2<U, P> const & v
 )
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator/=
 (
  U s
 )
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator/=
 (
  tvec2<U, P> const & v
 )
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }




 template <typename T, precision P>
 inline tvec2<T, P> & tvec2<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T, precision P>
 inline tvec2<T, P> & tvec2<T, P>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template <typename T, precision P>
 inline tvec2<T, P> tvec2<T, P>::operator++(int)
 {
  tvec2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec2<T, P> tvec2<T, P>::operator--(int)
 {
  tvec2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator%= (U s)
 {
  this->x %= static_cast<T>(s);
  this->y %= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator%= (tvec2<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator&= (U s)
 {
  this->x &= static_cast<T>(s);
  this->y &= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator&= (tvec2<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator|= (U s)
 {
  this->x |= static_cast<T>(s);
  this->y |= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator|= (tvec2<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator^= (U s)
 {
  this->x ^= static_cast<T>(s);
  this->y ^= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator^= (tvec2<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator<<= (U s)
 {
  this->x <<= static_cast<T>(s);
  this->y <<= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator<<= (tvec2<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator>>= (U s)
 {
  this->x >>= static_cast<T>(s);
  this->y >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator>>= (tvec2<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }




 template <typename T, precision P>
 inline tvec2<T, P> operator+
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x + s,
   v.y + s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s + v.x,
   s + v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator-
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x - s,
   v.y - s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s - v.x,
   s - v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator*
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x * s,
   v.y * s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s * v.x,
   s * v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator/
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x / s,
   v.y / s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s / v.x,
   s / v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator-
 (
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   -v.x,
   -v.y);
 }




 template <typename T, precision P>
 inline tvec2<T, P> operator%
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x % s,
   v.y % s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s % v.x,
   s % v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x & s,
   v.y & s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s & v.x,
   s & v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x | s,
   v.y | s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s | v.x,
   s | v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x ^ s,
   v.y ^ s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s ^ v.x,
   s ^ v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x << s,
   v.y << s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s << v.x,
   s << v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>
 (
  tvec2<T, P> const & v,
  T const & s
 )
 {
  return tvec2<T, P>(
   v.x >> s,
   v.y >> s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>
 (
  T const & s,
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   s >> v.x,
   s >> v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>
 (
  tvec2<T, P> const & v1,
  tvec2<T, P> const & v2
 )
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator~
 (
  tvec2<T, P> const & v
 )
 {
  return tvec2<T, P>(
   ~v.x,
   ~v.y);
 }

}
}
# 321 "/usr/include/glm/detail/type_vec2.hpp" 2 3 4
# 33 "/usr/include/glm/vec2.hpp" 2 3 4
# 96 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec3.hpp" 1 3 4
# 32 "/usr/include/glm/vec3.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec3.hpp" 1 3 4
# 44 "/usr/include/glm/detail/type_vec3.hpp" 3 4
# 1 "/usr/include/c++/4.8/cstddef" 1 3 4
# 39 "/usr/include/c++/4.8/cstddef" 3 4
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 45 "/usr/include/glm/detail/type_vec3.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tvec3
 {



  enum ctor{_null};

  typedef tvec3<T, P> type;
  typedef tvec3<bool, P> bool_type;
  typedef T value_type;
  typedef int size_type;




  constexpr length_t length() const;
# 88 "/usr/include/glm/detail/type_vec3.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 100 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  T & operator[](length_t i);
  T const & operator[](length_t i) const;




  tvec3();
  tvec3(tvec3<T, P> const & v);
  template <precision Q>
  tvec3(tvec3<T, Q> const & v);


  template <typename U>
  tvec3(std::initializer_list<U> const & v);





  explicit tvec3(
   ctor);
  explicit tvec3(
   T const & s);
  explicit tvec3(
   T const & s1,
   T const & s2,
   T const & s3);





  template <typename U, typename V, typename W>
  explicit tvec3(
   U const & x,
   V const & y,
   W const & z);





  template <typename A, typename B, precision Q>
  explicit tvec3(tvec2<A, Q> const & v, B const & s);

  template <typename A, typename B, precision Q>
  explicit tvec3(A const & s, tvec2<B, Q> const & v);

  template <typename U, precision Q>
  explicit tvec3(tvec3<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec3(tvec4<U, Q> const & v);
# 180 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  tvec3<T, P> & operator= (tvec3<T, P> const & v);
  template <typename U>
  tvec3<T, P> & operator= (tvec3<U, P> const & v);

  template <typename U>
  tvec3<T, P> & operator+=(U s);
  template <typename U>
  tvec3<T, P> & operator+=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator-=(U s);
  template <typename U>
  tvec3<T, P> & operator-=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator*=(U s);
  template <typename U>
  tvec3<T, P> & operator*=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator/=(U s);
  template <typename U>
  tvec3<T, P> & operator/=(tvec3<U, P> const & v);




  tvec3<T, P> & operator++();
  tvec3<T, P> & operator--();
  tvec3<T, P> operator++(int);
  tvec3<T, P> operator--(int);




  template <typename U>
  tvec3<T, P> & operator%= (U s);
  template <typename U>
  tvec3<T, P> & operator%= (tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator&= (U s);
  template <typename U>
  tvec3<T, P> & operator&= (tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator|= (U s);
  template <typename U>
  tvec3<T, P> & operator|= (tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator^= (U s);
  template <typename U>
  tvec3<T, P> & operator^= (tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator<<=(U s);
  template <typename U>
  tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator>>=(U s);
  template <typename U>
  tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
 };

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator+(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator-(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator- (tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator*(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator/(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator%(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator&(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator|(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator^(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator<<(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator>>(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator~(tvec3<T, P> const & v);

}
}


# 1 "/usr/include/glm/detail/type_vec3.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_vec3.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tvec3<T, P>::length() const
 {
  return 3;
 }




 template <typename T, precision P>
 inline T & tvec3<T, P>::operator[](length_t i)
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec3.inl", 44, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T, precision P>
 inline T const & tvec3<T, P>::operator[](length_t i) const
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec3.inl", 51, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T, precision P>
 inline tvec3<T, P>::tvec3() :
  x(0),
  y(0),
  z(0)
 {}

 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(tvec3<T, P> const & v) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec3<T, P>::tvec3(tvec3<T, Q> const & v) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}


 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P>::tvec3(std::initializer_list<U> const & v) :
  x(static_cast<T>(v.begin()[0])),
  y(static_cast<T>(v.begin()[1])),
  z(static_cast<T>(v.begin()[2]))
 {
  ((v.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("v.size() == this->length()", "/usr/include/glm/detail/type_vec3.inl", 88, __PRETTY_FUNCTION__));
 }





 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(ctor)
 {}

 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(T const & s) :
  x(s),
  y(s),
  z(s)
 {}

 template <typename T, precision P>
 inline tvec3<T, P>::tvec3
 (
  T const & s0,
  T const & s1,
  T const & s2
 ) :
  x(s0),
  y(s1),
  z(s2)
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C>
 inline tvec3<T, P>::tvec3
 (
  A const & x,
  B const & y,
  C const & z
 ) :
  x(static_cast<T>(x)),
  y(static_cast<T>(y)),
  z(static_cast<T>(z))
 {}




 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3
 (
  tvec2<A, Q> const & v,
  B const & s
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(s))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3
 (
  A const & s,
  tvec2<B, Q> const & v
 ) :
  x(static_cast<T>(s)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec3<T, P>::tvec3
 (
  tvec3<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec3<T, P>::tvec3
 (
  tvec4<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}




 template <typename T, precision P>
 inline tvec3<T, P>& tvec3<T, P>::operator= (tvec3<T, P> const & v)
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P>& tvec3<T, P>::operator= (tvec3<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator+= (U s)
 {
  this->x += static_cast<T>(s);
  this->y += static_cast<T>(s);
  this->z += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator+= (tvec3<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator-= (U s)
 {
  this->x -= static_cast<T>(s);
  this->y -= static_cast<T>(s);
  this->z -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator-= (tvec3<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator*= (U s)
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  this->z *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator*= (tvec3<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator/= (U s)
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  this->z /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator/= (tvec3<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }




 template <typename T, precision P>
 inline tvec3<T, P> & tvec3<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T, precision P>
 inline tvec3<T, P> & tvec3<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template <typename T, precision P>
 inline tvec3<T, P> tvec3<T, P>::operator++(int)
 {
  tvec3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec3<T, P> tvec3<T, P>::operator--(int)
 {
  tvec3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator%= (U s)
 {
  this->x %= s;
  this->y %= s;
  this->z %= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator%= (tvec3<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator&= (U s)
 {
  this->x &= s;
  this->y &= s;
  this->z &= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator&= (tvec3<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator|= (U s)
 {
  this->x |= s;
  this->y |= s;
  this->z |= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator|= (tvec3<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator^= (U s)
 {
  this->x ^= s;
  this->y ^= s;
  this->z ^= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator^= (tvec3<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator<<= (U s)
 {
  this->x <<= s;
  this->y <<= s;
  this->z <<= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator<<= (tvec3<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator>>= (U s)
 {
  this->x >>= static_cast<T>(s);
  this->y >>= static_cast<T>(s);
  this->z >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator>>= (tvec3<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }




 template <typename T, precision P>
 inline tvec3<T, P> operator+
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x + s,
   v.y + s,
   v.z + s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s + v.x,
   s + v.y,
   s + v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator-
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x - s,
   v.y - s,
   v.z - s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s - v.x,
   s - v.y,
   s - v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator*
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x * s,
   v.y * s,
   v.z * s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s * v.x,
   s * v.y,
   s * v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator/
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x / s,
   v.y / s,
   v.z / s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s / v.x,
   s / v.y,
   s / v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator-
 (
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   -v.x,
   -v.y,
   -v.z);
 }




 template <typename T, precision P>
 inline tvec3<T, P> operator%
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x % s,
   v.y % s,
   v.z % s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s % v.x,
   s % v.y,
   s % v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x & s,
   v.y & s,
   v.z & s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s & v.x,
   s & v.y,
   s & v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x | s,
   v.y | s,
   v.z | s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s | v.x,
   s | v.y,
   s | v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   T(s) ^ v.x,
   T(s) ^ v.y,
   T(s) ^ v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x ^ T(v2.x),
   v1.y ^ T(v2.y),
   v1.z ^ T(v2.z));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x << T(s),
   v.y << T(s),
   v.z << T(s));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   T(s) << v.x,
   T(s) << v.y,
   T(s) << v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x << T(v2.x),
   v1.y << T(v2.y),
   v1.z << T(v2.z));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>
 (
  tvec3<T, P> const & v,
  T const & s
 )
 {
  return tvec3<T, P>(
   v.x >> T(s),
   v.y >> T(s),
   v.z >> T(s));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>
 (
  T const & s,
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   s >> T(v.x),
   s >> T(v.y),
   s >> T(v.z));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>
 (
  tvec3<T, P> const & v1,
  tvec3<T, P> const & v2
 )
 {
  return tvec3<T, P>(
   v1.x >> T(v2.x),
   v1.y >> T(v2.y),
   v1.z >> T(v2.z));
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator~
 (
  tvec3<T, P> const & v
 )
 {
  return tvec3<T, P>(
   ~v.x,
   ~v.y,
   ~v.z);
 }

}
}
# 339 "/usr/include/glm/detail/type_vec3.hpp" 2 3 4
# 33 "/usr/include/glm/vec3.hpp" 2 3 4
# 97 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec4.hpp" 1 3 4
# 32 "/usr/include/glm/vec4.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec4.hpp" 1 3 4
# 45 "/usr/include/glm/detail/type_vec4.hpp" 3 4
# 1 "/usr/include/c++/4.8/cstddef" 1 3 4
# 39 "/usr/include/c++/4.8/cstddef" 3 4
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 46 "/usr/include/glm/detail/type_vec4.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tvec4
 {



  enum ctor{_null};

  typedef tvec4<T, P> type;
  typedef tvec4<bool, P> bool_type;
  typedef T value_type;
  typedef int size_type;




  constexpr length_t length() const;
# 89 "/usr/include/glm/detail/type_vec4.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 102 "/usr/include/glm/detail/type_vec4.hpp" 3 4
  T & operator[](length_t i);
  T const & operator[](length_t i) const;




  tvec4();
  tvec4(type const & v);
  template <precision Q>
  tvec4(tvec4<T, Q> const & v);


  template <typename U>
  tvec4(std::initializer_list<U> l);





  explicit tvec4(
   ctor);
  explicit tvec4(
   T const & s);
  explicit tvec4(
   T const & s0,
   T const & s1,
   T const & s2,
   T const & s3);





  template <typename A, typename B, typename C, typename D>
  explicit tvec4(
   A const & x,
   B const & y,
   C const & z,
   D const & w);





  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(tvec2<A, Q> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(A const & s1, tvec2<B, Q> const & v, C const & s2);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(A const & s1, B const & s2, tvec2<C, Q> const & v);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec3<A, Q> const & v, B const & s);

  template <typename A, typename B, precision Q>
  explicit tvec4(A const & s, tvec3<B, Q> const & v);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec2<A, Q> const & v1, tvec2<B, Q> const & v2);

  template <typename U, precision Q>
  explicit tvec4(tvec4<U, Q> const & v);
# 217 "/usr/include/glm/detail/type_vec4.hpp" 3 4
  tvec4<T, P> & operator= (tvec4<T, P> const & v);
  template <typename U, precision Q>
  tvec4<T, P> & operator= (tvec4<U, Q> const & v);

  template <typename U>
  tvec4<T, P> & operator+=(U s);
  template <typename U>
  tvec4<T, P> & operator+=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator-=(U s);
  template <typename U>
  tvec4<T, P> & operator-=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator*=(U s);
  template <typename U>
  tvec4<T, P> & operator*=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator/=(U s);
  template <typename U>
  tvec4<T, P> & operator/=(tvec4<U, P> const & v);




  tvec4<T, P> & operator++();
  tvec4<T, P> & operator--();
  tvec4<T, P> operator++(int);
  tvec4<T, P> operator--(int);




  template <typename U>
  tvec4<T, P> & operator%= (U s);
  template <typename U>
  tvec4<T, P> & operator%= (tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator&= (U s);
  template <typename U>
  tvec4<T, P> & operator&= (tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator|= (U s);
  template <typename U>
  tvec4<T, P> & operator|= (tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator^= (U s);
  template <typename U>
  tvec4<T, P> & operator^= (tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator<<=(U s);
  template <typename U>
  tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator>>=(U s);
  template <typename U>
  tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
 };

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator+(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator-(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator- (tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator*(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator/(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v);

 template <typename T, precision P>
 bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator%(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator&(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator|(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator^(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator<<(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec4<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec4<T, P> operator>>(T const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator~(tvec4<T, P> const & v);

}
}


# 1 "/usr/include/glm/detail/type_vec4.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_vec4.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tvec4<T, P>::length() const
 {
  return 4;
 }




 template <typename T, precision P>
 inline T & tvec4<T, P>::operator[](length_t i)
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec4.inl", 44, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T, precision P>
 inline T const & tvec4<T, P>::operator[](length_t i) const
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec4.inl", 51, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T, precision P>
 inline tvec4<T, P>::tvec4() :
  x(0),
  y(0),
  z(0),
  w(0)
 {}

 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(tvec4<T, P> const & v) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec4<T, P>::tvec4(tvec4<T, Q> const & v) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}


 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P>::tvec4(std::initializer_list<U> v) :
  x(static_cast<T>(v.begin()[0])),
  y(static_cast<T>(v.begin()[1])),
  z(static_cast<T>(v.begin()[2])),
  w(static_cast<T>(v.begin()[3]))
 {
  ((v.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("v.size() == this->length()", "/usr/include/glm/detail/type_vec4.inl", 92, __PRETTY_FUNCTION__));
 }





 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(ctor)
 {}

 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(T const & s) :
  x(s),
  y(s),
  z(s),
  w(s)
 {}

 template <typename T, precision P>
 inline tvec4<T, P>::tvec4
 (
  T const & s1,
  T const & s2,
  T const & s3,
  T const & s4
 ) :
  x(s1),
  y(s2),
  z(s3),
  w(s4)
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D>
 inline tvec4<T, P>::tvec4
 (
  A const & x,
  B const & y,
  C const & z,
  D const & w
 ) :
  x(static_cast<T>(x)),
  y(static_cast<T>(y)),
  z(static_cast<T>(z)),
  w(static_cast<T>(w))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec4<T, P>::tvec4
 (
  tvec4<U, Q> const & v
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z)),
  w(static_cast<T>(v.w))
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4
 (
  tvec2<A, Q> const & v,
  B const & s1,
  C const & s2
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(s1)),
  w(static_cast<T>(s2))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4
 (
  A const & s1,
  tvec2<B, Q> const & v,
  C const & s2
 ) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y)),
  w(static_cast<T>(s2))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4
 (
  A const & s1,
  B const & s2,
  tvec2<C, Q> const & v
 ) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(s2)),
  z(static_cast<T>(v.x)),
  w(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4
 (
  tvec3<A, Q> const & v,
  B const & s
 ) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z)),
  w(static_cast<T>(s))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4
 (
  A const & s,
  tvec3<B, Q> const & v
 ) :
  x(static_cast<T>(s)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y)),
  w(static_cast<T>(v.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4
 (
  tvec2<A, Q> const & v1,
  tvec2<B, Q> const & v2
 ) :
  x(static_cast<T>(v1.x)),
  y(static_cast<T>(v1.y)),
  z(static_cast<T>(v2.x)),
  w(static_cast<T>(v2.y))
 {}




 template <typename T, precision P>
 inline tvec4<T, P> & tvec4<T, P>::operator= (tvec4<T, P> const & v)
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  this->w = v.w;
  return *this;
 }

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec4<T, P> & tvec4<T, P>::operator= (tvec4<U, Q> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator+= (U s)
 {
  this->x += static_cast<T>(s);
  this->y += static_cast<T>(s);
  this->z += static_cast<T>(s);
  this->w += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator+= (tvec4<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  this->w += static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator-= (U s)
 {
  this->x -= static_cast<T>(s);
  this->y -= static_cast<T>(s);
  this->z -= static_cast<T>(s);
  this->w -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator-= (tvec4<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  this->w -= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator*= (U s)
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  this->z *= static_cast<T>(s);
  this->w *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator*= (tvec4<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  this->w *= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator/= (U s)
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  this->z /= static_cast<T>(s);
  this->w /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator/= (tvec4<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  this->w /= static_cast<T>(v.w);
  return *this;
 }




 template <typename T, precision P>
 inline tvec4<T, P> & tvec4<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T, precision P>
 inline tvec4<T, P> & tvec4<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template <typename T, precision P>
 inline tvec4<T, P> tvec4<T, P>::operator++(int)
 {
  tvec4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec4<T, P> tvec4<T, P>::operator--(int)
 {
  tvec4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator%= (U s)
 {
  this->x %= static_cast<T>(s);
  this->y %= static_cast<T>(s);
  this->z %= static_cast<T>(s);
  this->w %= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator%= (tvec4<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  this->z %= static_cast<T>(v.z);
  this->w %= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator&= (U s)
 {
  this->x &= static_cast<T>(s);
  this->y &= static_cast<T>(s);
  this->z &= static_cast<T>(s);
  this->w &= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator&= (tvec4<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  this->z &= static_cast<T>(v.z);
  this->w &= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator|= (U s)
 {
  this->x |= static_cast<T>(s);
  this->y |= static_cast<T>(s);
  this->z |= static_cast<T>(s);
  this->w |= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator|= (tvec4<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  this->z |= static_cast<T>(v.z);
  this->w |= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator^= (U s)
 {
  this->x ^= static_cast<T>(s);
  this->y ^= static_cast<T>(s);
  this->z ^= static_cast<T>(s);
  this->w ^= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator^= (tvec4<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  this->z ^= static_cast<T>(v.z);
  this->w ^= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator<<= (U s)
 {
  this->x <<= static_cast<T>(s);
  this->y <<= static_cast<T>(s);
  this->z <<= static_cast<T>(s);
  this->w <<= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator<<= (tvec4<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  this->w <<= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator>>= (U s)
 {
  this->x >>= static_cast<T>(s);
  this->y >>= static_cast<T>(s);
  this->z >>= static_cast<T>(s);
  this->w >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator>>= (tvec4<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  this->w >>= static_cast<T>(v.w);
  return *this;
 }




 template <typename T, precision P>
 inline tvec4<T, P> operator+
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x + s,
   v.y + s,
   v.z + s,
   v.w + s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator+
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s + v.x,
   s + v.y,
   s + v.z,
   s + v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator+
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z,
   v1.w + v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator-
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x - s,
   v.y - s,
   v.z - s,
   v.w - s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator-
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s - v.x,
   s - v.y,
   s - v.z,
   s - v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator-
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z,
   v1.w - v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator*
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x * s,
   v.y * s,
   v.z * s,
   v.w * s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator*
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s * v.x,
   s * v.y,
   s * v.z,
   s * v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator*
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z,
   v1.w * v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator/
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x / s,
   v.y / s,
   v.z / s,
   v.w / s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator/
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s / v.x,
   s / v.y,
   s / v.z,
   s / v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator/
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z,
   v1.w / v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator-
 (
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   -v.x,
   -v.y,
   -v.z,
   -v.w);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
 }




 template <typename T, precision P>
 inline tvec4<T, P> operator%
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x % s,
   v.y % s,
   v.z % s,
   v.w % s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s % v.x,
   s % v.y,
   s % v.z,
   s % v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z,
   v1.w % v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x & s,
   v.y & s,
   v.z & s,
   v.w & s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s & v.x,
   s & v.y,
   s & v.z,
   s & v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z,
   v1.w & v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x | s,
   v.y | s,
   v.z | s,
   v.w | s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s | v.x,
   s | v.y,
   s | v.z,
   s | v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z,
   v1.w | v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s,
   v.w ^ s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s ^ v.x,
   s ^ v.y,
   s ^ v.z,
   s ^ v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z,
   v1.w ^ v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x << s,
   v.y << s,
   v.z << s,
   v.w << s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s << v.x,
   s << v.y,
   s << v.z,
   s << v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z,
   v1.w << v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>
 (
  tvec4<T, P> const & v,
  T const & s
 )
 {
  return tvec4<T, P>(
   v.x >> s,
   v.y >> s,
   v.z >> s,
   v.w >> s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>
 (
  T const & s,
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   s >> v.x,
   s >> v.y,
   s >> v.z,
   s >> v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>
 (
  tvec4<T, P> const & v1,
  tvec4<T, P> const & v2
 )
 {
  return tvec4<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z,
   v1.w >> v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator~
 (
  tvec4<T, P> const & v
 )
 {
  return tvec4<T, P>(
   ~v.x,
   ~v.y,
   ~v.z,
   ~v.w);
 }

}
}
# 382 "/usr/include/glm/detail/type_vec4.hpp" 2 3 4
# 33 "/usr/include/glm/vec4.hpp" 2 3 4
# 98 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x2.hpp" 1 3 4
# 32 "/usr/include/glm/mat2x2.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat2x2.hpp" 1 3 4
# 32 "/usr/include/glm/detail/type_mat2x2.hpp" 3 4
# 1 "/usr/include/glm/fwd.hpp" 1 3 4
# 33 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_vec2.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_mat.hpp" 1 3 4
# 35 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4


namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat2x2
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x2<T, P> type;
  typedef tmat2x2<T, P> transpose_type;

  constexpr length_t length() const;

  template <typename U, precision Q>
  friend tvec2<U, Q> operator/(tmat2x2<U, Q> const & m, tvec2<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec2<U, Q> operator/(tvec2<U, Q> const & v, tmat2x2<U, Q> const & m);

 private:

  col_type value[2];


 public:


  tmat2x2();
  tmat2x2(tmat2x2<T, P> const & m);
  template <precision Q>
  tmat2x2(tmat2x2<T, Q> const & m);

  explicit tmat2x2(
   ctor Null);
  explicit tmat2x2(
   T const & x);
  explicit tmat2x2(
   T const & x1, T const & y1,
   T const & x2, T const & y2);
  explicit tmat2x2(
   col_type const & v1,
   col_type const & v2);


  template <typename U>
  tmat2x2(std::initializer_list<U> m);

  tmat2x2(std::initializer_list<tvec2<T, P> > m);




  template <typename U, typename V, typename M, typename N>
  explicit tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
  explicit tmat2x2(
   tvec2<U, P> const & v1,
   tvec2<V, P> const & v2);



  template <typename U, precision Q>
  explicit tmat2x2(tmat2x2<U, Q> const & m);

  explicit tmat2x2(tmat3x3<T, P> const & x);
  explicit tmat2x2(tmat4x4<T, P> const & x);
  explicit tmat2x2(tmat2x3<T, P> const & x);
  explicit tmat2x2(tmat3x2<T, P> const & x);
  explicit tmat2x2(tmat2x4<T, P> const & x);
  explicit tmat2x2(tmat4x2<T, P> const & x);
  explicit tmat2x2(tmat3x4<T, P> const & x);
  explicit tmat2x2(tmat4x3<T, P> const & x);




  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat2x2<T, P> & operator=(tmat2x2<T, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator+=(U s);
  template <typename U>
  tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator-=(U s);
  template <typename U>
  tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator*=(U s);
  template <typename U>
  tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator/=(U s);
  template <typename U>
  tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);




  tmat2x2<T, P> & operator++ ();
  tmat2x2<T, P> & operator-- ();
  tmat2x2<T, P> operator++(int);
  tmat2x2<T, P> operator--(int);
 };

 template <typename T, precision P>
 tmat2x2<T, P> compute_inverse_mat2(tmat2x2<T, P> const & m);


 template <typename T, precision P>
 tmat2x2<T, P> operator+ (
  tmat2x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator+ (
  T const & s,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator+ (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator- (
  tmat2x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator- (
  T const & s,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator- (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator* (
  tmat2x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator* (
  T const & s,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x2<T, P>::col_type operator* (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x2<T, P>::row_type operator* (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator* (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat2x2<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  tmat2x2<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator/ (
  tmat2x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator/ (
  T const & s,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x2<T, P>::col_type operator/ (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x2<T, P>::row_type operator/ (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator/ (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2);


 template <typename T, precision P>
 tmat2x2<T, P> const operator-(
  tmat2x2<T, P> const & m);
}
}


# 1 "/usr/include/glm/detail/type_mat2x2.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat2x2.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat2x2<T, P>::length() const
 {
  return 2;
 }




 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type &
 tmat2x2<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x2.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type const &
 tmat2x2<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x2.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2()
 {
  this->value[0] = col_type(1, 0);
  this->value[1] = col_type(0, 1);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x2<T, P>::tmat2x2(
  tmat2x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero);
  this->value[1] = col_type(Zero, s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>::tmat2x2(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat2x2.inl", 137, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec2<T, P>(*(p + 0), *(p + 1));
  this->value[1] = tvec2<T, P>(*(p + 2), *(p + 3));
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(std::initializer_list<tvec2<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat2x2.inl", 148, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
 }




 template <typename T, precision P>
 template <typename X1, typename Y1, typename X2, typename Y2>
 inline tmat2x2<T, P>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x2<T, P>::tmat2x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat2x2<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }





 template <typename T, precision P>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator= (tmat2x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator= (tmat2x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+= (tmat2x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-= (tmat2x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*= (tmat2x2<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/= (tmat2x2<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<detail::tmat2x2, T, P>::call(m));
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
 {
  tmat2x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
 {
  tmat2x2<T, P> Result(*this);
  --*this;
  return Result;
 }

 template <typename T, precision P>
 struct compute_inverse<detail::tmat2x2, T, P>
 {
  inline static detail::tmat2x2<T, P> call(detail::tmat2x2<T, P> const & m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   detail::tmat2x2<T, P> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };




 template <typename T, precision P>
 inline tmat2x2<T, P> operator+
 (
  tmat2x2<T, P> const & m,
  T const & s
 )
 {
  return tmat2x2<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator+
 (
  T const & s,
  tmat2x2<T, P> const & m
 )
 {
  return tmat2x2<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator+
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return tmat2x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-
 (
  tmat2x2<T, P> const & m,
  T const & s
 )
 {
  return tmat2x2<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-
 (
  T const & s,
  tmat2x2<T, P> const & m
 )
 {
  return tmat2x2<T, P>(
   s - m[0],
   s - m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return tmat2x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*
 (
  tmat2x2<T, P> const & m,
  T const & s
 )
 {
  return tmat2x2<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*
 (
  T const & s,
  tmat2x2<T, P> const & m
 )
 {
  return tmat2x2<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type operator*
 (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v
 )
 {
  return detail::tvec2<T, P>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::row_type operator*
 (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m
 )
 {
  return detail::tvec2<T, P>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return tmat2x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*
 (
  tmat2x2<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*
 (
  tmat2x2<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/
 (
  tmat2x2<T, P> const & m,
  T const & s
 )
 {
  return tmat2x2<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/
 (
  T const & s,
  tmat2x2<T, P> const & m
 )
 {
  return tmat2x2<T, P>(
   s / m[0],
   s / m[1]);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type operator/
 (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type & v
 )
 {
  return detail::compute_inverse<detail::tmat2x2, T, P>::call(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::row_type operator/
 (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m
 )
 {
  return v * detail::compute_inverse<detail::tmat2x2, T, P>::call(m);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  tmat2x2<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat2x2<T, P> const operator-
 (
  tmat2x2<T, P> const & m
 )
 {
  return tmat2x2<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat2x2<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }

}
}
# 254 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4
# 33 "/usr/include/glm/mat2x2.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat2x2<float, lowp> lowp_mat2;






 typedef detail::tmat2x2<float, mediump> mediump_mat2;






 typedef detail::tmat2x2<float, highp> highp_mat2;






 typedef detail::tmat2x2<float, lowp> lowp_mat2x2;






 typedef detail::tmat2x2<float, mediump> mediump_mat2x2;






 typedef detail::tmat2x2<float, highp> highp_mat2x2;

}
# 99 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x3.hpp" 1 3 4
# 32 "/usr/include/glm/mat2x3.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat2x3.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_mat2x3.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec3.hpp" 1 3 4
# 35 "/usr/include/glm/detail/type_mat2x3.hpp" 2 3 4



namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat2x3
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x3<T, P> type;
  typedef tmat3x2<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[2];

 public:

  tmat2x3();
  tmat2x3(tmat2x3<T, P> const & m);
  template <precision Q>
  tmat2x3(tmat2x3<T, Q> const & m);

  explicit tmat2x3(
   ctor);
  explicit tmat2x3(
   T const & s);
  explicit tmat2x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1);
  explicit tmat2x3(
   col_type const & v0,
   col_type const & v1);


  template <typename U>
  tmat2x3(std::initializer_list<U> m);

  tmat2x3(std::initializer_list<tvec3<T, P> > m);




  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  explicit tmat2x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2);

  template <typename U, typename V>
  explicit tmat2x3(
   tvec3<U, P> const & v1,
   tvec3<V, P> const & v2);



  template <typename U, precision Q>
  explicit tmat2x3(tmat2x3<U, Q> const & m);

  explicit tmat2x3(tmat2x2<T, P> const & x);
  explicit tmat2x3(tmat3x3<T, P> const & x);
  explicit tmat2x3(tmat4x4<T, P> const & x);
  explicit tmat2x3(tmat2x4<T, P> const & x);
  explicit tmat2x3(tmat3x2<T, P> const & x);
  explicit tmat2x3(tmat3x4<T, P> const & x);
  explicit tmat2x3(tmat4x2<T, P> const & x);
  explicit tmat2x3(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat2x3<T, P> & operator= (tmat2x3<T, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator+= (U s);
  template <typename U>
  tmat2x3<T, P> & operator+= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator-= (U s);
  template <typename U>
  tmat2x3<T, P> & operator-= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator*= (U s);
  template <typename U>
  tmat2x3<T, P> & operator/= (U s);




  tmat2x3<T, P> & operator++ ();
  tmat2x3<T, P> & operator-- ();
  tmat2x3<T, P> operator++(int);
  tmat2x3<T, P> operator--(int);
 };



 template <typename T, precision P>
 tmat2x3<T, P> operator+ (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator+ (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator- (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator- (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  T const & s,
  tmat2x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x3<T, P>::col_type operator* (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x3<T, P>::row_type operator* (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator/ (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator/ (
  T const & s,
  tmat2x3<T, P> const & m);


 template <typename T, precision P>
 tmat2x3<T, P> const operator- (
  tmat2x3<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat2x3.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat2x3.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat2x3<T, P>::length() const
 {
  return 2;
 }




 template <typename T, precision P>
 inline typename tmat2x3<T, P>::col_type &
 tmat2x3<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x3.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat2x3<T, P>::col_type const &
 tmat2x3<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x3.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3()
 {
  this->value[0] = col_type(T(1), T(0), T(0));
  this->value[1] = col_type(T(0), T(1), T(0));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x3<T, P>::tmat2x3(
  tmat2x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  T const & s
 )
 {
  this->value[0] = col_type(s, T(0), T(0));
  this->value[1] = col_type(T(0), s, T(0));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>::tmat2x3(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat2x3.inl", 136, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec3<T, P>(*(p + 0), *(p + 1), *(p + 2));
  this->value[1] = tvec3<T, P>(*(p + 3), *(p + 4), *(p + 5));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(std::initializer_list<tvec3<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat2x3.inl", 147, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline tmat2x3<T, P>::tmat2x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x3<T, P>::tmat2x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat2x3<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }




 template <typename T, precision P>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator= (tmat2x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator= (tmat2x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator+= (tmat2x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-= (tmat2x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
 {
  tmat2x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
 {
  tmat2x3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat2x3<T, P> operator+
 (
  tmat2x3<T, P> const & m,
  T const & s
 )
 {
  return tmat2x3<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator+
 (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return tmat2x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator-
 (
  tmat2x3<T, P> const & m,
  T const & s
 )
 {
  return tmat2x3<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator-
 (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return tmat2x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*
 (
  tmat2x3<T, P> const & m,
  T const & s
 )
 {
  return tmat2x3<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*
 (
  T const & s,
  tmat2x3<T, P> const & m
 )
 {
  return tmat2x3<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x3<T, P>::col_type operator*
 (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v)
 {
  return typename tmat2x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x3<T, P>::row_type operator*
 (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m)
 {
  return typename tmat2x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*
 (
  tmat2x3<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*
 (
  tmat2x3<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  tmat3x3<T, P> Result(tmat3x3<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*
 (
  tmat2x3<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator/
 (
  tmat2x3<T, P> const & m,
  T const & s
 )
 {
  return tmat2x3<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator/
 (
  T const & s,
  tmat2x3<T, P> const & m
 )
 {
  return tmat2x3<T, P>(
   s / m[0],
   s / m[1]);
 }


 template <typename T, precision P>
 inline tmat2x3<T, P> const operator-
 (
  tmat2x3<T, P> const & m
 )
 {
  return tmat2x3<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
}
# 216 "/usr/include/glm/detail/type_mat2x3.hpp" 2 3 4
# 33 "/usr/include/glm/mat2x3.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat2x3<float, lowp> lowp_mat2x3;






 typedef detail::tmat2x3<float, mediump> mediump_mat2x3;






 typedef detail::tmat2x3<float, highp> highp_mat2x3;

}
# 100 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x4.hpp" 1 3 4
# 32 "/usr/include/glm/mat2x4.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat2x4.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_mat2x4.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec4.hpp" 1 3 4
# 35 "/usr/include/glm/detail/type_mat2x4.hpp" 2 3 4



namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat2x4
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x4<T, P> type;
  typedef tmat4x2<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[2];

 public:

  tmat2x4();
  tmat2x4(tmat2x4<T, P> const & m);
  template <precision Q>
  tmat2x4(tmat2x4<T, Q> const & m);

  explicit tmat2x4(
   ctor);
  explicit tmat2x4(
   T const & s);
  explicit tmat2x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1);
  explicit tmat2x4(
   col_type const & v0,
   col_type const & v1);


  template <typename U>
  tmat2x4(std::initializer_list<U> m);

  tmat2x4(std::initializer_list<tvec4<T, P> > m);




  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  explicit tmat2x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);

  template <typename U, typename V>
  explicit tmat2x4(
   tvec4<U, P> const & v1,
   tvec4<V, P> const & v2);



  template <typename U, precision Q>
  explicit tmat2x4(tmat2x4<U, Q> const & m);

  explicit tmat2x4(tmat2x2<T, P> const & x);
  explicit tmat2x4(tmat3x3<T, P> const & x);
  explicit tmat2x4(tmat4x4<T, P> const & x);
  explicit tmat2x4(tmat2x3<T, P> const & x);
  explicit tmat2x4(tmat3x2<T, P> const & x);
  explicit tmat2x4(tmat3x4<T, P> const & x);
  explicit tmat2x4(tmat4x2<T, P> const & x);
  explicit tmat2x4(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat2x4<T, P>& operator= (tmat2x4<T, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator+= (U s);
  template <typename U>
  tmat2x4<T, P>& operator+= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator-= (U s);
  template <typename U>
  tmat2x4<T, P>& operator-= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator*= (U s);
  template <typename U>
  tmat2x4<T, P>& operator/= (U s);




  tmat2x4<T, P> & operator++ ();
  tmat2x4<T, P> & operator-- ();
  tmat2x4<T, P> operator++(int);
  tmat2x4<T, P> operator--(int);
 };



 template <typename T, precision P>
 tmat2x4<T, P> operator+ (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator+ (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator- (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator- (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  T const & s,
  tmat2x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x4<T, P>::col_type operator* (
  tmat2x4<T, P> const & m,
  typename tmat2x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x4<T, P>::row_type operator* (
  typename tmat2x4<T, P>::col_type const & v,
  tmat2x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator/ (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator/ (
  T const & s,
  tmat2x4<T, P> const & m);


 template <typename T, precision P>
 tmat2x4<T, P> const operator- (
  tmat2x4<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat2x4.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat2x4.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat2x4<T, P>::length() const
 {
  return 2;
 }




 template <typename T, precision P>
 inline typename tmat2x4<T, P>::col_type &
 tmat2x4<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x4.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat2x4<T, P>::col_type const &
 tmat2x4<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat2x4.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x4<T, P>::tmat2x4(
  tmat2x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>::tmat2x4(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat2x4.inl", 139, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec4<T, P>(*(p + 0), *(p + 1), *(p + 2), *(p + 3));
  this->value[1] = tvec4<T, P>(*(p + 4), *(p + 5), *(p + 6), *(p + 7));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(std::initializer_list<tvec4<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat2x4.inl", 150, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline tmat2x4<T, P>::tmat2x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x4<T, P>::tmat2x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat2x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(T(0)));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(T(0)));
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }




 template <typename T, precision P>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator= (tmat2x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator= (tmat2x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+= (tmat2x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-= (tmat2x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P> & tmat2x4<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
 {
  tmat2x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
 {
  tmat2x4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat2x4<T, P> operator+
 (
  tmat2x4<T, P> const & m,
  T const & s
 )
 {
  return tmat2x4<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator+
 (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return tmat2x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator-
 (
  tmat2x4<T, P> const & m,
  T const & s
 )
 {
  return tmat2x4<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator-
 (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return tmat2x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*
 (
  tmat2x4<T, P> const & m,
  T const & s
 )
 {
  return tmat2x4<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*
 (
  T const & s,
  tmat2x4<T, P> const & m
 )
 {
  return tmat2x4<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x4<T, P>::col_type operator*
 (
  tmat2x4<T, P> const & m,
  typename tmat2x4<T, P>::row_type const & v
 )
 {
  return typename tmat2x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x4<T, P>::row_type operator*
 (
  typename tmat2x4<T, P>::col_type const & v,
  tmat2x4<T, P> const & m
 )
 {
  return typename tmat2x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*
 (
  tmat2x4<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  tmat4x4<T, P> Result(tmat4x4<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*
 (
  tmat2x4<T, P> const & m1,
  tmat2x2<T, P> const & m2
 )
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*
 (
  tmat2x4<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator/
 (
  tmat2x4<T, P> const & m,
  T const & s
 )
 {
  return tmat2x4<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator/
 (
  T const & s,
  tmat2x4<T, P> const & m
 )
 {
  return tmat2x4<T, P>(
   s / m[0],
   s / m[1]);
 }


 template <typename T, precision P>
 inline tmat2x4<T, P> const operator-
 (
  tmat2x4<T, P> const & m
 )
 {
  return tmat2x4<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
}
# 218 "/usr/include/glm/detail/type_mat2x4.hpp" 2 3 4
# 33 "/usr/include/glm/mat2x4.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat2x4<float, lowp> lowp_mat2x4;






 typedef detail::tmat2x4<float, mediump> mediump_mat2x4;






 typedef detail::tmat2x4<float, highp> highp_mat2x4;

}
# 101 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x2.hpp" 1 3 4
# 32 "/usr/include/glm/mat3x2.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat3x2.hpp" 1 3 4
# 38 "/usr/include/glm/detail/type_mat3x2.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat3x2
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x2<T, P> type;
  typedef tmat2x3<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[3];

 public:

  tmat3x2();
  tmat3x2(tmat3x2<T, P> const & m);
  template <precision Q>
  tmat3x2(tmat3x2<T, Q> const & m);

  explicit tmat3x2(
   ctor);
  explicit tmat3x2(
   T const & s);
  explicit tmat3x2(
   T const & x0, T const & y0,
   T const & x1, T const & y1,
   T const & x2, T const & y2);
  explicit tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);


  template <typename U>
  tmat3x2(std::initializer_list<U> l);

  tmat3x2(std::initializer_list<tvec2<T, P> > l);




  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  explicit tmat3x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3);


  template <typename U, precision Q>
  explicit tmat3x2(tmat3x2<U, Q> const & m);

  explicit tmat3x2(tmat2x2<T, P> const & x);
  explicit tmat3x2(tmat3x3<T, P> const & x);
  explicit tmat3x2(tmat4x4<T, P> const & x);
  explicit tmat3x2(tmat2x3<T, P> const & x);
  explicit tmat3x2(tmat2x4<T, P> const & x);
  explicit tmat3x2(tmat3x4<T, P> const & x);
  explicit tmat3x2(tmat4x2<T, P> const & x);
  explicit tmat3x2(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat3x2<T, P> & operator= (tmat3x2<T, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator+= (U s);
  template <typename U>
  tmat3x2<T, P> & operator+= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator-= (U s);
  template <typename U>
  tmat3x2<T, P> & operator-= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator*= (U s);
  template <typename U>
  tmat3x2<T, P> & operator/= (U s);




  tmat3x2<T, P> & operator++ ();
  tmat3x2<T, P> & operator-- ();
  tmat3x2<T, P> operator++(int);
  tmat3x2<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat3x2<T, P> operator+ (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator+ (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator- (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator- (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  T const & s,
  tmat3x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x2<T, P>::col_type operator* (
  tmat3x2<T, P> const & m,
  typename tmat3x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x2<T, P>::row_type operator* (
  typename tmat3x2<T, P>::col_type const & v,
  tmat3x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator/ (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator/ (
  T const & s,
  tmat3x2<T, P> const & m);


 template <typename T, precision P>
 tmat3x2<T, P> const operator-(
  tmat3x2<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat3x2.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat3x2.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat3x2<T, P>::length() const
 {
  return 3;
 }




 template <typename T, precision P>
 inline typename tmat3x2<T, P>::col_type &
 tmat3x2<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x2.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat3x2<T, P>::col_type const &
 tmat3x2<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x2.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2()
 {
  this->value[0] = col_type(1, 0);
  this->value[1] = col_type(0, 1);
  this->value[2] = col_type(0, 0);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x2<T, P>::tmat3x2(
  tmat3x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  T const & s
 )
 {
  this->value[0] = col_type(s, 0);
  this->value[1] = col_type(0, s);
  this->value[2] = col_type(0, 0);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1,
  T const & x2, T const & y2
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>::tmat3x2(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat3x2.inl", 144, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec2<T, P>(*(p + 0), *(p + 1));
  this->value[1] = tvec2<T, P>(*(p + 2), *(p + 3));
  this->value[2] = tvec2<T, P>(*(p + 4), *(p + 5));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(std::initializer_list<tvec2<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat3x2.inl", 156, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline tmat3x2<T, P>::tmat3x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x2<T, P>::tmat3x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat3x2<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }




 template <typename T, precision P>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator= (tmat3x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator= (tmat3x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+= (tmat3x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-= (tmat3x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P> & tmat3x2<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
 {
  tmat3x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
 {
  tmat3x2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat3x2<T, P> operator+
 (
  tmat3x2<T, P> const & m,
  T const & s
 )
 {
  return tmat3x2<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator+
 (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return tmat3x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator-
 (
  tmat3x2<T, P> const & m,
  T const & s
 )
 {
  return tmat3x2<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator-
 (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return tmat3x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*
 (
  tmat3x2<T, P> const & m,
  T const & s
 )
 {
  return tmat3x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*
 (
  T const & s,
  tmat3x2<T, P> const & m
 )
 {
  return tmat3x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x2<T, P>::col_type operator*
 (
  tmat3x2<T, P> const & m,
  typename tmat3x2<T, P>::row_type const & v)
 {
  return typename tmat3x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x2<T, P>::row_type operator*
 (
  typename tmat3x2<T, P>::col_type const & v,
  tmat3x2<T, P> const & m)
 {
  return typename tmat3x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*
 (
  tmat3x2<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  tmat2x2<T, P> Result(tmat2x2<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*
 (
  tmat3x2<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*
 (
  tmat3x2<T, P> const & m1,
  tmat4x3<T, P> const & m2
 )
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator/
 (
  tmat3x2<T, P> const & m,
  T const & s
 )
 {
  return tmat3x2<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator/
 (
  T const & s,
  tmat3x2<T, P> const & m
 )
 {
  return tmat3x2<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T, precision P>
 inline tmat3x2<T, P> const operator-
 (
  tmat3x2<T, P> const & m
 )
 {
  return tmat3x2<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 221 "/usr/include/glm/detail/type_mat3x2.hpp" 2 3 4
# 33 "/usr/include/glm/mat3x2.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat3x2<float, lowp> lowp_mat3x2;






 typedef detail::tmat3x2<float, mediump> mediump_mat3x2;






 typedef detail::tmat3x2<float, highp> highp_mat3x2;

}
# 102 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x3.hpp" 1 3 4
# 32 "/usr/include/glm/mat3x3.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat3x3.hpp" 1 3 4
# 37 "/usr/include/glm/detail/type_mat3x3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat3x3
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x3<T, P> type;
  typedef tmat3x3<T, P> transpose_type;

  constexpr length_t length() const;

  template <typename U, precision Q>
  friend tvec3<U, Q> operator/(tmat3x3<U, Q> const & m, tvec3<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec3<U, Q> operator/(tvec3<U, Q> const & v, tmat3x3<U, Q> const & m);

 private:

  col_type value[3];


 public:

  tmat3x3();
  tmat3x3(tmat3x3<T, P> const & m);
  template <precision Q>
  tmat3x3(tmat3x3<T, Q> const & m);

  explicit tmat3x3(
   ctor Null);
  explicit tmat3x3(
   T const & s);
  explicit tmat3x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2);
  explicit tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);


  template <typename U>
  tmat3x3(std::initializer_list<U> m);

  tmat3x3(std::initializer_list<tvec3<T, P> > m);




  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  explicit tmat3x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3);


  template <typename U, precision Q>
  explicit tmat3x3(tmat3x3<U, Q> const & m);

  explicit tmat3x3(tmat2x2<T, P> const & x);
  explicit tmat3x3(tmat4x4<T, P> const & x);
  explicit tmat3x3(tmat2x3<T, P> const & x);
  explicit tmat3x3(tmat3x2<T, P> const & x);
  explicit tmat3x3(tmat2x4<T, P> const & x);
  explicit tmat3x3(tmat4x2<T, P> const & x);
  explicit tmat3x3(tmat3x4<T, P> const & x);
  explicit tmat3x3(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat3x3<T, P>& operator= (tmat3x3<T, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator+= (U s);
  template <typename U>
  tmat3x3<T, P>& operator+= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator-= (U s);
  template <typename U>
  tmat3x3<T, P>& operator-= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator*= (U s);
  template <typename U>
  tmat3x3<T, P>& operator*= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator/= (U s);
  template <typename U>
  tmat3x3<T, P>& operator/= (tmat3x3<U, P> const & m);




  tmat3x3<T, P> & operator++ ();
  tmat3x3<T, P> & operator-- ();
  tmat3x3<T, P> operator++(int);
  tmat3x3<T, P> operator--(int);
 };

 template <typename T, precision P>
 tmat3x3<T, P> compute_inverse_mat3(tmat3x3<T, P> const & m);


 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x3<T, P>::col_type operator* (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x3<T, P>::row_type operator* (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x3<T, P>::col_type operator/ (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x3<T, P>::row_type operator/ (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);


 template <typename T, precision P>
 tmat3x3<T, P> const operator-(
  tmat3x3<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat3x3.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat3x3.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat3x3<T, P>::length() const
 {
  return 3;
 }




 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type &
 tmat3x3<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x3.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type const &
 tmat3x3<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x3.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero);
  this->value[2] = col_type(Zero, Zero, One);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  ctor
 )
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x3<T, P>::tmat3x3(
  tmat3x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero);
  this->value[2] = col_type(Zero, Zero, s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P>::tmat3x3(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat3x3.inl", 147, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec3<T, P>(*(p + 0), *(p + 1), *(p + 2));
  this->value[1] = tvec3<T, P>(*(p + 3), *(p + 4), *(p + 5));
  this->value[2] = tvec3<T, P>(*(p + 6), *(p + 7), *(p + 8));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(std::initializer_list<tvec3<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat3x3.inl", 159, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline tmat3x3<T, P>::tmat3x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x3<T, P>::tmat3x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat3x3<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(detail::tvec2<T, P>(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(detail::tvec2<T, P>(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(detail::tvec2<T, P>(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }




 template <typename T, precision P>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator= (tmat3x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator= (tmat3x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+= (tmat3x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-= (tmat3x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*= (tmat3x3<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/= (tmat3x3<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<detail::tmat3x3, T, P>::call(m));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
 {
  tmat3x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
 {
  tmat3x3<T, P> Result(*this);
  --*this;
  return Result;
 }

 template <typename T, precision P>
 struct compute_inverse<detail::tmat3x3, T, P>
 {
  static detail::tmat3x3<T, P> call(detail::tmat3x3<T, P> const & m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   detail::tmat3x3<T, P> Inverse(detail::tmat3x3<T, P>::_null);
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template <typename T, precision P>
 inline tmat3x3<T, P> compute_inverse_mat3(tmat3x3<T, P> const & m)
 {
  T S00 = m[0][0];
  T S01 = m[0][1];
  T S02 = m[0][2];

  T S10 = m[1][0];
  T S11 = m[1][1];
  T S12 = m[1][2];

  T S20 = m[2][0];
  T S21 = m[2][1];
  T S22 = m[2][2];
# 484 "/usr/include/glm/detail/type_mat3x3.inl" 3 4
  tmat3x3<T, P> Inverse(
   S11 * S22 - S21 * S12,
   S12 * S20 - S22 * S10,
   S10 * S21 - S20 * S11,
   S02 * S21 - S01 * S22,
   S00 * S22 - S02 * S20,
   S01 * S20 - S00 * S21,
   S12 * S01 - S11 * S02,
   S10 * S02 - S12 * S00,
   S11 * S00 - S10 * S01);

  T Determinant =
   + S00 * (S11 * S22 - S21 * S12)
   - S10 * (S01 * S22 - S21 * S02)
   + S20 * (S01 * S12 - S11 * S02);

  Inverse /= Determinant;
  return Inverse;
 }




 template <typename T, precision P>
 inline tmat3x3<T, P> operator+
 (
  tmat3x3<T, P> const & m,
  T const & s
 )
 {
  return tmat3x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator+
 (
  T const & s,
  tmat3x3<T, P> const & m
 )
 {
  return tmat3x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator+
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return tmat3x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-
 (
  tmat3x3<T, P> const & m,
  T const & s
 )
 {
  return tmat3x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-
 (
  T const & s,
  tmat3x3<T, P> const & m
 )
 {
  return tmat3x3<T, P>(
   s - m[0],
   s - m[1],
   s - m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return tmat3x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*
 (
  tmat3x3<T, P> const & m,
  T const & s
 )
 {
  return tmat3x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*
 (
  T const & s,
  tmat3x3<T, P> const & m
 )
 {
  return tmat3x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type operator*
 (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v
 )
 {
  return typename tmat3x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::row_type operator*
 (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m
 )
 {
  return typename tmat3x3<T, P>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  tmat3x3<T, P> Result(tmat3x3<T, P>::_null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*
 (
  tmat3x3<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*
 (
  tmat3x3<T, P> const & m1,
  tmat4x3<T, P> const & m2
 )
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/
 (
  tmat3x3<T, P> const & m,
  T const & s
 )
 {
  return tmat3x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/
 (
  T const & s,
  tmat3x3<T, P> const & m
 )
 {
  return tmat3x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type operator/
 (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v
 )
 {
  return detail::compute_inverse<detail::tmat3x3, T, P>::call(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::row_type operator/
 (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m
 )
 {
  return v * detail::compute_inverse<detail::tmat3x3, T, P>::call(m);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  tmat3x3<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat3x3<T, P> const operator-
 (
  tmat3x3<T, P> const & m
 )
 {
  return tmat3x3<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 258 "/usr/include/glm/detail/type_mat3x3.hpp" 2 3 4
# 33 "/usr/include/glm/mat3x3.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat3x3<float, lowp> lowp_mat3;






 typedef detail::tmat3x3<float, mediump> mediump_mat3;






 typedef detail::tmat3x3<float, highp> highp_mat3;






 typedef detail::tmat3x3<float, lowp> lowp_mat3x3;






 typedef detail::tmat3x3<float, mediump> mediump_mat3x3;






 typedef detail::tmat3x3<float, highp> highp_mat3x3;

}
# 103 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x4.hpp" 1 3 4
# 32 "/usr/include/glm/mat3x4.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat3x4.hpp" 1 3 4
# 38 "/usr/include/glm/detail/type_mat3x4.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat3x4
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x4<T, P> type;
  typedef tmat4x3<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[3];

 public:

  tmat3x4();
  tmat3x4(tmat3x4<T, P> const & m);
  template <precision Q>
  tmat3x4(tmat3x4<T, Q> const & m);

  explicit tmat3x4(
   ctor Null);
  explicit tmat3x4(
   T const & s);
  explicit tmat3x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2);
  explicit tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);


  template <typename U>
  tmat3x4(std::initializer_list<U> m);

  tmat3x4(std::initializer_list<tvec4<T, P> > m);




  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  explicit tmat3x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);

  template <typename V1, typename V2, typename V3>
  explicit tmat3x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3);


  template <typename U, precision Q>
  explicit tmat3x4(tmat3x4<U, Q> const & m);

  explicit tmat3x4(tmat2x2<T, P> const & x);
  explicit tmat3x4(tmat3x3<T, P> const & x);
  explicit tmat3x4(tmat4x4<T, P> const & x);
  explicit tmat3x4(tmat2x3<T, P> const & x);
  explicit tmat3x4(tmat3x2<T, P> const & x);
  explicit tmat3x4(tmat2x4<T, P> const & x);
  explicit tmat3x4(tmat4x2<T, P> const & x);
  explicit tmat3x4(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat3x4<T, P> & operator= (tmat3x4<T, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator= (tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator+= (U s);
  template <typename U>
  tmat3x4<T, P> & operator+= (tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator-= (U s);
  template <typename U>
  tmat3x4<T, P> & operator-= (tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator*= (U s);
  template <typename U>
  tmat3x4<T, P> & operator/= (U s);




  tmat3x4<T, P> & operator++ ();
  tmat3x4<T, P> & operator-- ();
  tmat3x4<T, P> operator++(int);
  tmat3x4<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat3x4<T, P> operator+ (
  tmat3x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator+ (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator- (
  tmat3x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator- (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  tmat3x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  T const & s,
  tmat3x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x4<T, P>::col_type operator* (
  tmat3x4<T, P> const & m,
  typename tmat3x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x4<T, P>::row_type operator* (
  typename tmat3x4<T, P>::col_type const & v,
  tmat3x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  tmat3x4<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat3x4<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  tmat3x4<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator/ (
  tmat3x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator/ (
  T const & s,
  tmat3x4<T, P> const & m);


 template <typename T, precision P>
 tmat3x4<T, P> const operator-(
  tmat3x4<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat3x4.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat3x4.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat3x4<T, P>::length() const
 {
  return 3;
 }




 template <typename T, precision P>
 inline typename tmat3x4<T, P>::col_type &
 tmat3x4<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x4.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat3x4<T, P>::col_type const &
 tmat3x4<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat3x4.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4()
 {
  this->value[0] = col_type(1, 0, 0, 0);
  this->value[1] = col_type(0, 1, 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x4<T, P>::tmat3x4(
  tmat3x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, s, Zero);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3>
 inline tmat3x4<T, P>::tmat3x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x4<T, P>::tmat3x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>::tmat3x4(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat3x4.inl", 178, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec4<T, P>(*(p + 0), *(p + 1), *(p + 2), *(p + 3));
  this->value[1] = tvec4<T, P>(*(p + 4), *(p + 5), *(p + 6), *(p + 7));
  this->value[2] = tvec4<T, P>(*(p + 8), *(p + 9), *(p + 10), *(p + 11));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(std::initializer_list<tvec4<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat3x4.inl", 190, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
 }



 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat3x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
  this->value[2] = col_type(m[2], T(0), T(1));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(T(0)));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(T(0)));
  this->value[2] = col_type(m[2], detail::tvec2<T, P>(T(1), T(0)));
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
 }




 template <typename T, precision P>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator= (tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator= (tmat3x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+= (tmat3x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-= (tmat3x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P> & tmat3x4<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
 {
  tmat3x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
 {
  tmat3x4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat3x4<T, P> operator+
 (
  tmat3x4<T, P> const & m,
  T const & s
 )
 {
  return tmat3x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator+
 (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return tmat3x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator-
 (
  tmat3x4<T, P> const & m,
  T const & s
 )
 {
  return tmat3x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator-
 (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return tmat3x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*
 (
  tmat3x4<T, P> const & m,
  T const & s
 )
 {
  return tmat3x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*
 (
  T const & s,
  tmat3x4<T, P> const & m
 )
 {
  return tmat3x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x4<T, P>::col_type operator*
 (
  tmat3x4<T, P> const & m,
  typename tmat3x4<T, P>::row_type const & v
 )
 {
  return typename tmat3x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x4<T, P>::row_type operator*
 (
  typename tmat3x4<T, P>::col_type const & v,
  tmat3x4<T, P> const & m
 )
 {
  return typename tmat3x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*
 (
  tmat3x4<T, P> const & m1,
  tmat4x3<T, P> const & m2
 )
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  tmat4x4<T, P> Result(tmat4x4<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*
 (
  tmat3x4<T, P> const & m1,
  tmat2x3<T, P> const & m2
 )
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*
 (
  tmat3x4<T, P> const & m1,
  tmat3x3<T, P> const & m2
 )
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator/
 (
  tmat3x4<T, P> const & m,
  T const & s
 )
 {
  return tmat3x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator/
 (
  T const & s,
  tmat3x4<T, P> const & m
 )
 {
  return tmat3x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T, precision P>
 inline tmat3x4<T, P> const operator-
 (
  tmat3x4<T, P> const & m
 )
 {
  return tmat3x4<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat3x4<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
}
# 221 "/usr/include/glm/detail/type_mat3x4.hpp" 2 3 4
# 33 "/usr/include/glm/mat3x4.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat3x4<float, lowp> lowp_mat3x4;






 typedef detail::tmat3x4<float, mediump> mediump_mat3x4;






 typedef detail::tmat3x4<float, highp> highp_mat3x4;

}
# 104 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x2.hpp" 1 3 4
# 32 "/usr/include/glm/mat4x2.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat4x2.hpp" 1 3 4
# 38 "/usr/include/glm/detail/type_mat4x2.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat4x2
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x2<T, P> type;
  typedef tmat2x4<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[4];

 public:

  tmat4x2();
  tmat4x2(tmat4x2<T, P> const & m);
  template <precision Q>
  tmat4x2(tmat4x2<T, Q> const & m);

  explicit tmat4x2(
   ctor Null);
  explicit tmat4x2(
   T const & x);
  explicit tmat4x2(
   T const & x0, T const & y0,
   T const & x1, T const & y1,
   T const & x2, T const & y2,
   T const & x3, T const & y3);
  explicit tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);


  template <typename U>
  tmat4x2(std::initializer_list<U> m);

  tmat4x2(std::initializer_list<tvec2<T, P> > m);





  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3,
   typename X4, typename Y4>
  explicit tmat4x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3,
   X4 const & x4, Y4 const & y4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3,
   tvec2<V4, P> const & v4);


  template <typename U, precision Q>
  explicit tmat4x2(tmat4x2<U, Q> const & m);

  explicit tmat4x2(tmat2x2<T, P> const & x);
  explicit tmat4x2(tmat3x3<T, P> const & x);
  explicit tmat4x2(tmat4x4<T, P> const & x);
  explicit tmat4x2(tmat2x3<T, P> const & x);
  explicit tmat4x2(tmat3x2<T, P> const & x);
  explicit tmat4x2(tmat2x4<T, P> const & x);
  explicit tmat4x2(tmat4x3<T, P> const & x);
  explicit tmat4x2(tmat3x4<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat4x2<T, P>& operator= (tmat4x2<T, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator= (tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator+= (U s);
  template <typename U>
  tmat4x2<T, P>& operator+= (tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator-= (U s);
  template <typename U>
  tmat4x2<T, P>& operator-= (tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator*= (U s);
  template <typename U>
  tmat4x2<T, P>& operator/= (U s);




  tmat4x2<T, P> & operator++ ();
  tmat4x2<T, P> & operator-- ();
  tmat4x2<T, P> operator++(int);
  tmat4x2<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat4x2<T, P> operator+ (
  tmat4x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator+ (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator- (
  tmat4x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator- (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  tmat4x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  T const & s,
  tmat4x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x2<T, P>::col_type operator* (
  tmat4x2<T, P> const & m,
  typename tmat4x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x2<T, P>::row_type operator* (
  typename tmat4x2<T, P>::col_type const & v,
  tmat4x2<T, P> const & m);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat4x2<T, P> const & m1,
  tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  tmat4x2<T, P> const & m1,
  tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat4x3<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator/ (
  tmat4x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator/ (
  T const & s,
  tmat4x2<T, P> const & m);


 template <typename T, precision P>
 tmat4x2<T, P> const operator-(
  tmat4x2<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat4x2.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat4x2.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat4x2<T, P>::length() const
 {
  return 4;
 }




 template <typename T, precision P>
 inline typename tmat4x2<T, P>::col_type &
 tmat4x2<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x2.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat4x2<T, P>::col_type const &
 tmat4x2<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x2.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero);
  this->value[1] = col_type(Zero, One);
  this->value[2] = col_type(Zero, Zero);
  this->value[3] = col_type(Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(
  tmat4x2<T, P> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x2<T, P>::tmat4x2(
  tmat4x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(ctor)
 {}

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero);
  this->value[1] = col_type(Zero, s);
  this->value[2] = col_type(Zero, Zero);
  this->value[3] = col_type(Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1,
  T const & x2, T const & y2,
  T const & x3, T const & y3
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
  this->value[3] = col_type(x3, y3);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4>
 inline tmat4x2<T, P>::tmat4x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3,
  X4 const & x4, Y4 const & y4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x2<T, P>::tmat4x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3,
  tvec2<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P>::tmat4x2(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat4x2.inl", 189, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec2<T, P>(*(p + 0), *(p + 1));
  this->value[1] = tvec2<T, P>(*(p + 2), *(p + 3));
  this->value[2] = tvec2<T, P>(*(p + 4), *(p + 5));
  this->value[3] = tvec2<T, P>(*(p + 6), *(p + 7));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(std::initializer_list<tvec2<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat4x2.inl", 202, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
  this->value[3] = l.begin()[3];
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat4x2<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(static_cast<T>(0));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(static_cast<T>(0));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(static_cast<T>(0));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(static_cast<T>(0));
 }




 template <typename T, precision P>
 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=
 (
  tmat4x2<U, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+= (tmat4x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-= (tmat4x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
 {
  tmat4x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
 {
  tmat4x2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat4x2<T, P> operator+
 (
  tmat4x2<T, P> const & m,
  T const & s
 )
 {
  return tmat4x2<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator+
 (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return tmat4x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator-
 (
  tmat4x2<T, P> const & m,
  T const & s
 )
 {
  return tmat4x2<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator-
 (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return tmat4x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*
 (
  tmat4x2<T, P> const & m,
  T const & s
 )
 {
  return tmat4x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*
 (
  T const & s,
  tmat4x2<T, P> const & m
 )
 {
  return tmat4x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x2<T, P>::col_type operator*
 (
  tmat4x2<T, P> const & m,
  typename tmat4x2<T, P>::row_type const & v
 )
 {
  return typename tmat4x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template <typename T, precision P>
 inline typename tmat4x2<T, P>::row_type operator*
 (
  typename tmat4x2<T, P>::col_type const & v,
  tmat4x2<T, P> const & m
 )
 {
  return typename tmat4x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*
 (
  tmat4x2<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  tmat2x2<T, P> Result(tmat2x2<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*
 (
  tmat4x2<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*
 (
  tmat4x2<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator/
 (
  tmat4x2<T, P> const & m,
  T const & s
 )
 {
  return tmat4x2<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator/
 (
  T const & s,
  tmat4x2<T, P> const & m
 )
 {
  return tmat4x2<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T, precision P>
 inline tmat4x2<T, P> const operator-
 (
  tmat4x2<T, P> const & m
 )
 {
  return tmat4x2<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat4x2<T, P> const & m1,
  tmat4x2<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
}
# 227 "/usr/include/glm/detail/type_mat4x2.hpp" 2 3 4
# 33 "/usr/include/glm/mat4x2.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat4x2<float, lowp> lowp_mat4x2;






 typedef detail::tmat4x2<float, mediump> mediump_mat4x2;






 typedef detail::tmat4x2<float, highp> highp_mat4x2;

}
# 105 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x3.hpp" 1 3 4
# 32 "/usr/include/glm/mat4x3.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat4x3.hpp" 1 3 4
# 38 "/usr/include/glm/detail/type_mat4x3.hpp" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat4x3
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x3<T, P> type;
  typedef tmat3x4<T, P> transpose_type;

  constexpr length_t length() const;

 private:

  col_type value[4];

 public:

  tmat4x3();
  tmat4x3(tmat4x3<T, P> const & m);
  template <precision Q>
  tmat4x3(tmat4x3<T, Q> const & m);

  explicit tmat4x3(
   ctor Null);
  explicit tmat4x3(
   T const & x);
  explicit tmat4x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2,
   T const & x3, T const & y3, T const & z3);
  explicit tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);


  template <typename U>
  tmat4x3(std::initializer_list<U> m);

  tmat4x3(std::initializer_list<tvec3<T, P> > m);





  template <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  explicit tmat4x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3,
   X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3,
   tvec3<V4, P> const & v4);


  template <typename U, precision Q>
  explicit tmat4x3(tmat4x3<U, Q> const & m);

  explicit tmat4x3(tmat2x2<T, P> const & x);
  explicit tmat4x3(tmat3x3<T, P> const & x);
  explicit tmat4x3(tmat4x4<T, P> const & x);
  explicit tmat4x3(tmat2x3<T, P> const & x);
  explicit tmat4x3(tmat3x2<T, P> const & x);
  explicit tmat4x3(tmat2x4<T, P> const & x);
  explicit tmat4x3(tmat4x2<T, P> const & x);
  explicit tmat4x3(tmat3x4<T, P> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


  tmat4x3<T, P> & operator= (tmat4x3<T, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator= (tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator+= (U s);
  template <typename U>
  tmat4x3<T, P> & operator+= (tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator-= (U s);
  template <typename U>
  tmat4x3<T, P> & operator-= (tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator*= (U s);
  template <typename U>
  tmat4x3<T, P> & operator/= (U s);




  tmat4x3<T, P> & operator++ ();
  tmat4x3<T, P> & operator-- ();
  tmat4x3<T, P> operator++(int);
  tmat4x3<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat4x3<T, P> operator+ (
  tmat4x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator+ (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator- (
  tmat4x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator- (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat4x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  T const & s,
  tmat4x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x3<T, P>::col_type operator* (
  tmat4x3<T, P> const & m,
  typename tmat4x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x3<T, P>::row_type operator* (
  typename tmat4x3<T, P>::col_type const & v,
  tmat4x3<T, P> const & m);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat4x3<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat4x3<T, P> const & m1,
  tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat4x3<T, P> const & m1,
  tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator/ (
  tmat4x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator/ (
  T const & s,
  tmat4x3<T, P> const & m);


 template <typename T, precision P>
 tmat4x3<T, P> const operator- (
  tmat4x3<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat4x3.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat4x3.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat4x3<T, P>::length() const
 {
  return 4;
 }




 template <typename T, precision P>
 inline typename tmat4x3<T, P>::col_type &
 tmat4x3<T, P>::operator[]
 (
  size_type i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x3.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat4x3<T, P>::col_type const &
 tmat4x3<T, P>::operator[]
 (
  size_type i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x3.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero);
  this->value[2] = col_type(Zero, Zero, One);
  this->value[3] = col_type(Zero, Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(
  tmat4x3<T, P> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x3<T, P>::tmat4x3(
  tmat4x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(ctor)
 {}

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(
  T const & s)
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero);
  this->value[2] = col_type(Zero, Zero, s);
  this->value[3] = col_type(Zero, Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2,
  T const & x3, T const & y3, T const & z3
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
  this->value[3] = col_type(x3, y3, z3);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P>::tmat4x3(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat4x3.inl", 148, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec3<T, P>(*(p + 0), *(p + 1), *(p + 2));
  this->value[1] = tvec3<T, P>(*(p + 3), *(p + 4), *(p + 5));
  this->value[2] = tvec3<T, P>(*(p + 6), *(p + 7), *(p + 8));
  this->value[3] = tvec3<T, P>(*(p + 9), *(p + 10), *(p + 11));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(std::initializer_list<tvec3<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat4x3.inl", 161, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
  this->value[3] = l.begin()[3];
 }





 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4>
 inline tmat4x3<T, P>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x3<T, P>::tmat4x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3,
  tvec3<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat4x3<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(static_cast<T>(0), value_type(0), value_type(1));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(static_cast<T>(0), value_type(0), value_type(1));
  this->value[3] = col_type(static_cast<T>(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(m[3], value_type(0));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(static_cast<T>(0));
 }




 template <typename T, precision P>
 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=
 (
  tmat4x3<U, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+= (tmat4x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-= (tmat4x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }




 template <typename T, precision P>
 inline tmat4x3<T, P> operator+ (
  tmat4x3<T, P> const & m,
  T const & s)
 {
  return tmat4x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator+ (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator- (
  tmat4x3<T, P> const & m,
  T const & s)
 {
  return tmat4x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator- (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator* (
  tmat4x3<T, P> const & m,
  T const & s)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator* (
  T const & s,
  tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x3<T, P>::col_type operator*
 (
  tmat4x3<T, P> const & m,
  typename tmat4x3<T, P>::row_type const & v)
 {
  return typename tmat4x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template <typename T, precision P>
 inline typename tmat4x3<T, P>::row_type operator*
 (
  typename tmat4x3<T, P>::col_type const & v,
  tmat4x3<T, P> const & m)
 {
  return typename tmat4x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*
 (
  tmat4x3<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*
 (
  tmat4x3<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  tmat3x3<T, P> Result(tmat3x3<T, P>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*
 (
  tmat4x3<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator/
 (
  tmat4x3<T, P> const & m,
  T const & s
 )
 {
  return tmat4x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator/
 (
  T const & s,
  tmat4x3<T, P> const & m
 )
 {
  return tmat4x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T, precision P>
 inline tmat4x3<T, P> const operator-
 (
  tmat4x3<T, P> const & m
 )
 {
  return tmat4x3<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> const operator++
 (
  tmat4x3<T, P> const & m,
  int
 )
 {
  return tmat4x3<T, P>(
   m[0] + T(1),
   m[1] + T(1),
   m[2] + T(1),
   m[3] + T(1));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> const operator--
 (
  tmat4x3<T, P> const & m,
  int
 )
 {
  return tmat4x3<T, P>(
   m[0] - T(1),
   m[1] - T(1),
   m[2] - T(1),
   m[3] - T(1));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
 {
  tmat4x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
 {
  tmat4x3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat4x3<T, P> const & m1,
  tmat4x3<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
}
# 227 "/usr/include/glm/detail/type_mat4x3.hpp" 2 3 4
# 33 "/usr/include/glm/mat4x3.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat4x3<float, lowp> lowp_mat4x3;






 typedef detail::tmat4x3<float, mediump> mediump_mat4x3;






 typedef detail::tmat4x3<float, highp> highp_mat4x3;

}
# 106 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x4.hpp" 1 3 4
# 32 "/usr/include/glm/mat4x4.hpp" 3 4
# 1 "/usr/include/glm/detail/type_mat4x4.hpp" 1 3 4
# 39 "/usr/include/glm/detail/type_mat4x4.hpp" 3 4
# 1 "/usr/include/c++/4.8/cstddef" 1 3 4
# 39 "/usr/include/c++/4.8/cstddef" 3 4
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 40 "/usr/include/glm/detail/type_mat4x4.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tmat4x4
 {
  enum ctor{_null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x4<T, P> type;
  typedef tmat4x4<T, P> transpose_type;

  constexpr length_t length() const;

  template <typename U, precision Q>
  friend tvec4<U, Q> operator/(tmat4x4<U, Q> const & m, tvec4<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec4<U, Q> operator/(tvec4<U, Q> const & v, tmat4x4<U, Q> const & m);

 private:

  col_type value[4];

 public:

  tmat4x4();
  tmat4x4(tmat4x4<T, P> const & m);
  template <precision Q>
  tmat4x4(tmat4x4<T, Q> const & m);

  explicit tmat4x4(
   ctor Null);
  explicit tmat4x4(
   T const & x);
  explicit tmat4x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2,
   T const & x3, T const & y3, T const & z3, T const & w3);
  explicit tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);


  template <typename U>
  tmat4x4(std::initializer_list<U> m);

  tmat4x4(std::initializer_list<tvec4<T, P> > m);





  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  explicit tmat4x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
   X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
  explicit tmat4x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3,
   tvec4<V4, P> const & v4);


  template <typename U, precision Q>
  explicit tmat4x4(tmat4x4<U, Q> const & m);

  explicit tmat4x4(tmat2x2<T, P> const & x);
  explicit tmat4x4(tmat3x3<T, P> const & x);
  explicit tmat4x4(tmat2x3<T, P> const & x);
  explicit tmat4x4(tmat3x2<T, P> const & x);
  explicit tmat4x4(tmat2x4<T, P> const & x);
  explicit tmat4x4(tmat4x2<T, P> const & x);
  explicit tmat4x4(tmat3x4<T, P> const & x);
  explicit tmat4x4(tmat4x3<T, P> const & x);


  col_type & operator[](length_t i);
  col_type const & operator[](length_t i) const;


  tmat4x4<T, P> & operator= (tmat4x4<T, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator= (tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator+= (U s);
  template <typename U>
  tmat4x4<T, P> & operator+= (tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator-= (U s);
  template <typename U>
  tmat4x4<T, P> & operator-= (tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator*= (U s);
  template <typename U>
  tmat4x4<T, P> & operator*= (tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator/= (U s);
  template <typename U>
  tmat4x4<T, P> & operator/= (tmat4x4<U, P> const & m);




  tmat4x4<T, P> & operator++ ();
  tmat4x4<T, P> & operator-- ();
  tmat4x4<T, P> operator++(int);
  tmat4x4<T, P> operator--(int);
 };

 template <typename T, precision P>
 tmat4x4<T, P> compute_inverse_mat4(tmat4x4<T, P> const & m);


 template <typename T, precision P>
 tmat4x4<T, P> operator+ (
  tmat4x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator+ (
  T const & s,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator+ (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator- (
  tmat4x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator- (
  T const & s,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator- (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  tmat4x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  T const & s,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x4<T, P>::col_type operator* (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x4<T, P>::row_type operator* (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat4x4<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  tmat4x4<T, P> const & m1,
  tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator/ (
  tmat4x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator/ (
  T const & s,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x4<T, P>::col_type operator/ (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x4<T, P>::row_type operator/ (
  typename tmat4x4<T, P>::col_type & v,
  tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator/ (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2);


 template <typename T, precision P>
 tmat4x4<T, P> const operator- (
  tmat4x4<T, P> const & m);

}
}


# 1 "/usr/include/glm/detail/type_mat4x4.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tmat4x4<T, P>::length() const
 {
  return 4;
 }




 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type &
 tmat4x4<T, P>::operator[]
 (
  length_t i
 )
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x4.inl", 48, __PRETTY_FUNCTION__));
  return this->value[i];
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type const &
 tmat4x4<T, P>::operator[]
 (
  length_t i
 ) const
 {
  ((i < this->length()) ? static_cast<void> (0) : __assert_fail ("i < this->length()", "/usr/include/glm/detail/type_mat4x4.inl", 59, __PRETTY_FUNCTION__));
  return this->value[i];
 }




 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4()
 {
  T Zero(0);
  T One(1);
  this->value[0] = col_type(One, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, One, Zero);
  this->value[3] = col_type(Zero, Zero, Zero, One);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<T, Q> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  ctor
 )
 {}

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  T const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, s, Zero);
  this->value[3] = col_type(Zero, Zero, Zero, s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2,
  T const & x3, T const & y3, T const & z3, T const & w3
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
  this->value[3] = col_type(x3, y3, z3, w3);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }


 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>::tmat4x4(std::initializer_list<U> l)
 {
  ((l.size() == this->length() * this->value[0].length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length() * this->value[0].length()", "/usr/include/glm/detail/type_mat4x4.inl", 170, __PRETTY_FUNCTION__));

  typename std::initializer_list<U>::iterator p = l.begin();

  this->value[0] = tvec4<T, P>(*(p + 0), *(p + 1), *(p + 2), *(p + 3));
  this->value[1] = tvec4<T, P>(*(p + 4), *(p + 5), *(p + 6), *(p + 7));
  this->value[2] = tvec4<T, P>(*(p + 8), *(p + 9), *(p + 10), *(p + 11));
  this->value[3] = tvec4<T, P>(*(p + 12), *(p + 13), *(p + 14), *(p + 15));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(std::initializer_list<tvec4<T, P> > l)
 {
  ((l.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("l.size() == this->length()", "/usr/include/glm/detail/type_mat4x4.inl", 183, __PRETTY_FUNCTION__));

  this->value[0] = l.begin()[0];
  this->value[1] = l.begin()[1];
  this->value[2] = l.begin()[2];
  this->value[3] = l.begin()[3];
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline tmat4x4<T, P>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");

  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x4<T, P>::tmat4x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3,
  tvec4<V4, P> const & v4
 )
 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat2x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
  this->value[2] = col_type(static_cast<T>(0));
  this->value[3] = col_type(static_cast<T>(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat3x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(0));
  this->value[3] = col_type(static_cast<T>(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat2x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(static_cast<T>(0));
  this->value[3] = col_type(static_cast<T>(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat3x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
  this->value[2] = col_type(m[2], detail::tvec2<T, P>(0));
  this->value[3] = col_type(static_cast<T>(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat2x4<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(T(0));
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x2<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T, P>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T, P>(0));
  this->value[2] = col_type(T(0));
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat3x4<T, P> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x3<T, P> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
  this->value[3] = col_type(m[3], T(1));
 }




 template <typename T, precision P>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=
 (
  tmat4x4<T, P> const & m
 )
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=
 (
  tmat4x4<U, P> const & m
 )
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+= (U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+= (tmat4x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-= (U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-= (tmat4x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*= (U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*= (tmat4x4<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/= (U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/= (tmat4x4<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<detail::tmat4x4, T, P>::call(m));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
 {
  tmat4x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
 {
  tmat4x4<T, P> Result(*this);
  --*this;
  return Result;
 }

 template <typename T, precision P>
 struct compute_inverse<detail::tmat4x4, T, P>
 {
  static detail::tmat4x4<T, P> call(detail::tmat4x4<T, P> const & m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   detail::tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
   detail::tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
   detail::tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
   detail::tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
   detail::tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
   detail::tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

   detail::tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   detail::tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   detail::tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   detail::tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   detail::tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   detail::tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   detail::tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   detail::tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   detail::tvec4<T, P> SignA(+1, -1, +1, -1);
   detail::tvec4<T, P> SignB(-1, +1, -1, +1);
   detail::tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   detail::tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   detail::tvec4<T, P> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };


 template <typename T, precision P>
 inline tmat4x4<T, P> operator+
 (
  tmat4x4<T, P> const & m,
  T const & s
 )
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator+
 (
  T const & s,
  tmat4x4<T, P> const & m
 )
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator+
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return tmat4x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-
 (
  tmat4x4<T, P> const & m,
  T const & s
 )
 {
  return tmat4x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-
 (
  T const & s,
  tmat4x4<T, P> const & m
 )
 {
  return tmat4x4<T, P>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return tmat4x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*
 (
  tmat4x4<T, P> const & m,
  T const & s
 )
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*
 (
  T const & s,
  tmat4x4<T, P> const & m
 )
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type operator*
 (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v
 )
 {
# 703 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
  typename tmat4x4<T, P>::col_type const Mov0(v[0]);
  typename tmat4x4<T, P>::col_type const Mov1(v[1]);
  typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
  typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
  typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
  typename tmat4x4<T, P>::col_type const Mov2(v[2]);
  typename tmat4x4<T, P>::col_type const Mov3(v[3]);
  typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
  typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
  typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
  typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 723 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::row_type operator*
 (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m
 )
 {
  return typename tmat4x4<T, P>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*
 (
  tmat4x4<T, P> const & m1,
  tmat2x4<T, P> const & m2
 )
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*
 (
  tmat4x4<T, P> const & m1,
  tmat3x4<T, P> const & m2
 )
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

  tmat4x4<T, P> Result(tmat4x4<T, P>::_null);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/
 (
  tmat4x4<T, P> const & m,
  T const & s
 )
 {
  return tmat4x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/
 (
  T const & s,
  tmat4x4<T, P> const & m
 )
 {
  return tmat4x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type operator/
 (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v
 )
 {
  return detail::compute_inverse<detail::tmat4x4, T, P>::call(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::row_type operator/
 (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m
 )
 {
  return v * detail::compute_inverse<detail::tmat4x4, T, P>::call(m);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  tmat4x4<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat4x4<T, P> const operator-
 (
  tmat4x4<T, P> const & m
 )
 {
  return tmat4x4<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> const operator++
 (
  tmat4x4<T, P> const & m,
  int
 )
 {
  return tmat4x4<T, P>(
   m[0] + static_cast<T>(1),
   m[1] + static_cast<T>(1),
   m[2] + static_cast<T>(1),
   m[3] + static_cast<T>(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> const operator--
 (
  tmat4x4<T, P> const & m,
  int
 )
 {
  return tmat4x4<T, P>(
   m[0] - static_cast<T>(1),
   m[1] - static_cast<T>(1),
   m[2] - static_cast<T>(1),
   m[3] - static_cast<T>(1));
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tmat4x4<T, P> const & m1,
  tmat4x4<T, P> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }

}
}
# 267 "/usr/include/glm/detail/type_mat4x4.hpp" 2 3 4
# 33 "/usr/include/glm/mat4x4.hpp" 2 3 4

namespace glm
{





 typedef detail::tmat4x4<float, lowp> lowp_mat4;






 typedef detail::tmat4x4<float, mediump> mediump_mat4;






 typedef detail::tmat4x4<float, highp> highp_mat4;






 typedef detail::tmat4x4<float, lowp> lowp_mat4x4;






 typedef detail::tmat4x4<float, mediump> mediump_mat4x4;






 typedef detail::tmat4x4<float, highp> highp_mat4x4;

}
# 107 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/glm/trigonometric.hpp" 1 3 4
# 32 "/usr/include/glm/trigonometric.hpp" 3 4
# 1 "/usr/include/glm/detail/func_trigonometric.hpp" 1 3 4
# 43 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
namespace glm
{
# 54 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType radians(genType const & degrees);







 template <typename genType>
 genType degrees(genType const & radians);
# 73 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType sin(genType const & angle);
# 83 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType cos(genType const & angle);







 template <typename genType>
 genType tan(genType const & angle);
# 103 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType asin(genType const & x);
# 114 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType acos(genType const & x);
# 127 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atan(genType const & y, genType const & x);
# 137 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atan(genType const & y_over_x);







 template <typename genType>
 genType sinh(genType const & angle);







 template <typename genType>
 genType cosh(genType const & angle);







 template <typename genType>
 genType tanh(genType const & angle);







 template <typename genType>
 genType asinh(genType const & x);
# 183 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType acosh(genType const & x);
# 193 "/usr/include/glm/detail/func_trigonometric.hpp" 3 4
 template <typename genType>
 genType atanh(genType const & x);


}

# 1 "/usr/include/glm/detail/func_trigonometric.inl" 1 3 4
# 29 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
# 1 "/usr/include/glm/detail/_vectorize.hpp" 1 3 4
# 168 "/usr/include/glm/detail/_vectorize.hpp" 3 4
namespace glm{
namespace detail
{
 template<bool C>
 struct If
 {
  template<typename F, typename T>
  static inline T apply(F functor, const T& val)
  {
   return functor(val);
  }
 };

 template<>
 struct If<false>
 {
  template<typename F, typename T>
  static inline T apply(F, const T& val)
  {
   return val;
  }
 };
}
}
# 30 "/usr/include/glm/detail/func_trigonometric.inl" 2 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 31 "/usr/include/glm/detail/func_trigonometric.inl" 2 3 4


namespace glm
{

 template <typename genType>
 inline genType radians
 (
  genType const & degrees
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");

  return degrees * genType(0.01745329251994329576923690768489);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> radians( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( radians(v.x), radians(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> radians( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( radians(v.x), radians(v.y), radians(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> radians( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( radians(v.x), radians(v.y), radians(v.z), radians(v.w)); }


 template <typename genType>
 inline genType degrees
 (
  genType const & radians
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");

  return radians * genType(57.295779513082320876798154814105);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> degrees( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( degrees(v.x), degrees(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> degrees( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( degrees(v.x), degrees(v.y), degrees(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> degrees( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( degrees(v.x), degrees(v.y), degrees(v.z), degrees(v.w)); }


 template <typename genType>
 inline genType sin
 (
  genType const & angle
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'sin' only accept floating-point input");

  return genType(::std::sin(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> sin( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( sin(v.x), sin(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> sin( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( sin(v.x), sin(v.y), sin(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> sin( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( sin(v.x), sin(v.y), sin(v.z), sin(v.w)); }


 template <typename genType>
 inline genType cos(genType const & angle)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'cos' only accept floating-point input");

  return genType(::std::cos(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> cos( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( cos(v.x), cos(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> cos( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( cos(v.x), cos(v.y), cos(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> cos( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( cos(v.x), cos(v.y), cos(v.z), cos(v.w)); }


 template <typename genType>
 inline genType tan
 (
  genType const & angle
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'tan' only accept floating-point input");

  return genType(::std::tan(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> tan( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( tan(v.x), tan(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> tan( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( tan(v.x), tan(v.y), tan(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> tan( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( tan(v.x), tan(v.y), tan(v.z), tan(v.w)); }


 template <typename genType>
 inline genType asin
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'asin' only accept floating-point input");

  return genType(::std::asin(x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> asin( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( asin(v.x), asin(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> asin( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( asin(v.x), asin(v.y), asin(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> asin( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( asin(v.x), asin(v.y), asin(v.z), asin(v.w)); }


 template <typename genType>
 inline genType acos
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'acos' only accept floating-point input");

  return genType(::std::acos(x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> acos( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( acos(v.x), acos(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> acos( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( acos(v.x), acos(v.y), acos(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> acos( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( acos(v.x), acos(v.y), acos(v.z), acos(v.w)); }


 template <typename genType>
 inline genType atan
 (
  genType const & y,
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

  return genType(::std::atan2(y, x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> atan ( detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y ) { return detail::tvec2<T, P>( atan(x.x, y.x), atan(x.y, y.y)); } template <typename T, precision P> inline detail::tvec3<T, P> atan ( detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y ) { return detail::tvec3<T, P>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z)); } template <typename T, precision P> inline detail::tvec4<T, P> atan ( detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y ) { return detail::tvec4<T, P>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z), atan(x.w, y.w)); }

 template <typename genType>
 inline genType atan
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

  return genType(::std::atan(x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> atan( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( atan(v.x), atan(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> atan( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( atan(v.x), atan(v.y), atan(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> atan( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( atan(v.x), atan(v.y), atan(v.z), atan(v.w)); }


 template <typename genType>
 inline genType sinh
 (
  genType const & angle
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'sinh' only accept floating-point input");

  return genType(std::sinh(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> sinh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( sinh(v.x), sinh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> sinh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( sinh(v.x), sinh(v.y), sinh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> sinh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( sinh(v.x), sinh(v.y), sinh(v.z), sinh(v.w)); }


 template <typename genType>
 inline genType cosh
 (
  genType const & angle
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'cosh' only accept floating-point input");

  return genType(std::cosh(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> cosh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( cosh(v.x), cosh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> cosh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( cosh(v.x), cosh(v.y), cosh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> cosh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( cosh(v.x), cosh(v.y), cosh(v.z), cosh(v.w)); }


 template <typename genType>
 inline genType tanh
 (
  genType const & angle
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'tanh' only accept floating-point input");

  return genType(std::tanh(angle));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> tanh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( tanh(v.x), tanh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> tanh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( tanh(v.x), tanh(v.y), tanh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> tanh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( tanh(v.x), tanh(v.y), tanh(v.z), tanh(v.w)); }


 template <typename genType>
 inline genType asinh
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'asinh' only accept floating-point input");

  return (x < genType(0) ? genType(-1) : (x > genType(0) ? genType(1) : genType(0))) * log(abs(x) + sqrt(genType(1) + x * x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> asinh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( asinh(v.x), asinh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> asinh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( asinh(v.x), asinh(v.y), asinh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> asinh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( asinh(v.x), asinh(v.y), asinh(v.z), asinh(v.w)); }


 template <typename genType>
 inline genType acosh
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'acosh' only accept floating-point input");

  if(x < genType(1))
   return genType(0);
  return log(x + sqrt(x * x - genType(1)));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> acosh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( acosh(v.x), acosh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> acosh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( acosh(v.x), acosh(v.y), acosh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> acosh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( acosh(v.x), acosh(v.y), acosh(v.z), acosh(v.w)); }


 template <typename genType>
 inline genType atanh
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'atanh' only accept floating-point input");

  if(abs(x) >= genType(1))
   return 0;
  return genType(0.5) * log((genType(1) + x) / (genType(1) - x));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> atanh( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( atanh(v.x), atanh(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> atanh( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( atanh(v.x), atanh(v.y), atanh(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> atanh( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( atanh(v.x), atanh(v.y), atanh(v.z), atanh(v.w)); }

}
# 200 "/usr/include/glm/detail/func_trigonometric.hpp" 2 3 4
# 33 "/usr/include/glm/trigonometric.hpp" 2 3 4
# 109 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/exponential.hpp" 1 3 4
# 32 "/usr/include/glm/exponential.hpp" 3 4
# 1 "/usr/include/glm/detail/func_exponential.hpp" 1 3 4
# 39 "/usr/include/glm/detail/func_exponential.hpp" 3 4
# 1 "/usr/include/glm/detail/type_vec1.hpp" 1 3 4
# 44 "/usr/include/glm/detail/type_vec1.hpp" 3 4
# 1 "/usr/include/c++/4.8/cstddef" 1 3 4
# 39 "/usr/include/c++/4.8/cstddef" 3 4
       
# 40 "/usr/include/c++/4.8/cstddef" 3


# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 42 "/usr/include/c++/4.8/cstddef" 2 3
# 45 "/usr/include/glm/detail/type_vec1.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct tvec1
 {



  enum ctor{_null};

  typedef tvec1<T, P> type;
  typedef tvec1<bool, P> bool_type;
  typedef T value_type;




  constexpr length_t length() const;




  union {T x, r, s;};




  T & operator[](length_t i);
  T const & operator[](length_t i) const;




  tvec1();
  tvec1(tvec1<T, P> const & v);
  template <precision Q>
  tvec1(tvec1<T, Q> const & v);


  template <typename U>
  tvec1(std::initializer_list<U> const & v);





  explicit tvec1(
   ctor);
  tvec1(
   T const & s);





  template <typename U, precision Q>
  explicit tvec1(tvec1<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec1(tvec2<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec1(tvec3<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec1(tvec4<U, Q> const & v);




  tvec1<T, P> & operator= (tvec1<T, P> const & v);
  template <typename U>
  tvec1<T, P> & operator= (tvec1<U, P> const & v);

  template <typename U>
  tvec1<T, P> & operator+=(U const & s);
  template <typename U>
  tvec1<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator-=(U const & s);
  template <typename U>
  tvec1<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator*=(U const & s);
  template <typename U>
  tvec1<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator/=(U const & s);
  template <typename U>
  tvec1<T, P> & operator/=(tvec1<U, P> const & v);




  tvec1<T, P> & operator++();
  tvec1<T, P> & operator--();
  tvec1<T, P> operator++(int);
  tvec1<T, P> operator--(int);




  template <typename U>
  tvec1<T, P> & operator%=(U const & s);
  template <typename U>
  tvec1<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator&=(U const & s);
  template <typename U>
  tvec1<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator|=(U const & s);
  template <typename U>
  tvec1<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator^=(U const & s);
  template <typename U>
  tvec1<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator<<=(U const & s);
  template <typename U>
  tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator>>=(U const & s);
  template <typename U>
  tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
 };


 template <typename T, precision P>
 tvec1<T, P> operator+(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator+(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator-(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator-(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator- (tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator*(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator*(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator/(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator/(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator-(tvec1<T, P> const & v);

 template <typename T, precision P>
 bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator%(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator%(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator&(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator&(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator|(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator|(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator^(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator^(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator<<(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator<<(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator>>(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator>>(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator~(tvec1<T, P> const & v);

}
}


# 1 "/usr/include/glm/detail/type_vec1.inl" 1 3 4
# 29 "/usr/include/glm/detail/type_vec1.inl" 3 4
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline constexpr length_t tvec1<T, P>::length() const
 {
  return 1;
 }




 template <typename T, precision P>
 inline T & tvec1<T, P>::operator[](length_t i)
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec1.inl", 44, __PRETTY_FUNCTION__));
  return (&x)[i];
 }

 template <typename T, precision P>
 inline T const & tvec1<T, P>::operator[](length_t i) const
 {
  ((i >= 0 && i < this->length()) ? static_cast<void> (0) : __assert_fail ("i >= 0 && i < this->length()", "/usr/include/glm/detail/type_vec1.inl", 51, __PRETTY_FUNCTION__));
  return (&x)[i];
 }




 template <typename T, precision P>
 inline tvec1<T, P>::tvec1() :
  x(static_cast<T>(0))
 {}

 template <typename T, precision P>
 inline tvec1<T, P>::tvec1(tvec1<T, P> const & v) :
  x(v.x)
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec1<T, P>::tvec1(tvec1<T, Q> const & v) :
  x(v.x)
 {}


 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P>::tvec1(std::initializer_list<U> const & v) :
  x(static_cast<T>(v.begin()[0]))
 {
  ((v.size() == this->length()) ? static_cast<void> (0) : __assert_fail ("v.size() == this->length()", "/usr/include/glm/detail/type_vec1.inl", 80, __PRETTY_FUNCTION__));
 }





 template <typename T, precision P>
 inline tvec1<T, P>::tvec1(ctor)
 {}

 template <typename T, precision P>
 inline tvec1<T, P>::tvec1(T const & s) :
  x(s)
 {}




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1
 (
  tvec1<U, Q> const & v
 ) :
  x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1
 (
  tvec2<U, Q> const & v
 ) :
  x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1
 (
  tvec3<U, Q> const & v
 ) :
  x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1
 (
  tvec4<U, Q> const & v
 ) :
  x(static_cast<T>(v.x))
 {}




 template <typename T, precision P>
 inline tvec1<T, P> & tvec1<T, P>::operator=
 (
  tvec1<T, P> const & v
 )
 {
  this->x = v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator=
 (
  tvec1<U, P> const & v
 )
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator+=
 (
  U const & s
 )
 {
  this->x += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator+=
 (
  tvec1<U, P> const & v
 )
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator-=
 (
  U const & s
 )
 {
  this->x -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator-=
 (
  tvec1<U, P> const & v
 )
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator*=
 (
  U const & s
 )
 {
  this->x *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator*=
 (
  tvec1<U, P> const & v
 )
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator/=
 (
  U const & s
 )
 {
  this->x /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator/=
 (
  tvec1<U, P> const & v
 )
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }




 template <typename T, precision P>
 inline tvec1<T, P> & tvec1<T, P>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T, precision P>
 inline tvec1<T, P> & tvec1<T, P>::operator--()
 {
  --this->x;
  return *this;
 }

 template <typename T, precision P>
 inline tvec1<T, P> tvec1<T, P>::operator++(int)
 {
  tvec1<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec1<T, P> tvec1<T, P>::operator--(int)
 {
  tvec1<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return (v1.x == v2.x);
 }

 template <typename T, precision P>
 inline bool operator!=
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return (v1.x != v2.x);
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator%=
 (
  U const & s
 )
 {
  this->x %= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator%=
 (
  tvec1<U, P> const & v
 )
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator&=
 (
  U const & s
 )
 {
  this->x &= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator&=
 (
  tvec1<U, P> const & v
 )
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator|=
 (
  U const & s
 )
 {
  this->x |= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator|=
 (
  tvec1<U, P> const & v
 )
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator^=
 (
  U const & s
 )
 {
  this->x ^= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator^=
 (
  tvec1<U, P> const & v
 )
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator<<=
 (
  tvec1<U, P> const & v
 )
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator>>=
 (
  tvec1<U, P> const & v
 )
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }




 template <typename T, precision P>
 inline tvec1<T, P> operator+
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x + s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator+
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s + v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator+
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x + v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator-
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x - s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator-
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s - v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator-
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x - v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator*
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x * s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator*
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s * v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator*
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x * v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator/
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x / s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator/
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s / v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator/
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x / v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator-
 (
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   -v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator++
 (
  tvec1<T, P> const & v,
  int
 )
 {
  return tvec1<T, P>(
   v.x + T(1));
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator--
 (
  tvec1<T, P> const & v,
  int
 )
 {
  return tvec1<T, P>(
   v.x - T(1));
 }




 template <typename T, precision P>
 inline tvec1<T, P> operator%
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x % s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator%
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s % v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator%
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x % v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x & s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s & v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x & v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x | s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s | v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x | v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x ^ s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s ^ v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x ^ v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x << s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s << v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x << v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>
 (
  tvec1<T, P> const & v,
  T const & s
 )
 {
  return tvec1<T, P>(
   v.x >> s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>
 (
  T const & s,
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   s >> v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>
 (
  tvec1<T, P> const & v1,
  tvec1<T, P> const & v2
 )
 {
  return tvec1<T, P>(
   v1.x >> v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator~
 (
  tvec1<T, P> const & v
 )
 {
  return tvec1<T, P>(
   ~v.x);
 }

}
}
# 283 "/usr/include/glm/detail/type_vec1.hpp" 2 3 4
# 40 "/usr/include/glm/detail/func_exponential.hpp" 2 3 4



# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 44 "/usr/include/glm/detail/func_exponential.hpp" 2 3 4

namespace glm
{
# 58 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType pow(genType const & base, genType const & exponent);
# 68 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType exp(genType const & x);
# 80 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType log(genType const & x);
# 90 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType exp2(genType const & x);
# 101 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType log2(genType const & x);
# 111 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType sqrt(genType const & x);
# 121 "/usr/include/glm/detail/func_exponential.hpp" 3 4
 template <typename genType>
 genType inversesqrt(genType const & x);


}

# 1 "/usr/include/glm/detail/func_exponential.inl" 1 3 4
# 29 "/usr/include/glm/detail/func_exponential.inl" 3 4
# 1 "/usr/include/glm/detail/func_vector_relational.hpp" 1 3 4
# 49 "/usr/include/glm/detail/func_vector_relational.hpp" 3 4
namespace glm
{
# 70 "/usr/include/glm/detail/func_vector_relational.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class vecType>
 typename vecType<T, P>::bool_type lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 typename vecType<T, P>::bool_type greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 typename vecType<T, P>::bool_type greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);
# 107 "/usr/include/glm/detail/func_vector_relational.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class vecType>
 typename vecType<T, P>::bool_type notEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <precision P, template <typename, precision> class vecType>
 bool any(vecType<bool, P> const & v);







 template <precision P, template <typename, precision> class vecType>
 bool all(vecType<bool, P> const & v);
# 135 "/usr/include/glm/detail/func_vector_relational.hpp" 3 4
 template <precision P, template <typename, precision> class vecType>
 vecType<bool, P> not_(vecType<bool, P> const & v);


}



# 1 "/usr/include/glm/detail/func_vector_relational.inl" 1 3 4
# 31 "/usr/include/glm/detail/func_vector_relational.inl" 3 4
namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type lessThan
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "Invalid template instantiation of 'lessThan', GLM vector types required floating-point or integer value types vectors")
                                                                                                                           ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 42, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type lessThanEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "Invalid template instantiation of 'lessThanEqual', GLM vector types required floating-point or integer value types vectors")
                                                                                                                                ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 60, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type greaterThan
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "Invalid template instantiation of 'greaterThan', GLM vector types required floating-point or integer value types vectors")
                                                                                                                              ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 77, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type greaterThanEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "Invalid template instantiation of 'greaterThanEqual', GLM vector types required floating-point or integer value types vectors")
                                                                                                                                   ;
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 94, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type equal
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 109, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline typename vecType<T, P>::bool_type notEqual
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  ((x.length() == y.length()) ? static_cast<void> (0) : __assert_fail ("x.length() == y.length()", "/usr/include/glm/detail/func_vector_relational.inl", 124, __PRETTY_FUNCTION__));

  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline bool any(vecType<bool, P> const & v)
 {
  bool Result = false;
  for(int i = 0; i < v.length(); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline bool all(vecType<bool, P> const & v)
 {
  bool Result = true;
  for(int i = 0; i < v.length(); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> not_(vecType<bool, P> const & v)
 {
  typename vecType<bool, P>::bool_type Result(vecType<bool, P>::_null);
  for(int i = 0; i < v.length(); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 144 "/usr/include/glm/detail/func_vector_relational.hpp" 2 3 4
# 30 "/usr/include/glm/detail/func_exponential.inl" 2 3 4


# 1 "/usr/include/c++/4.8/cassert" 1 3 4
# 41 "/usr/include/c++/4.8/cassert" 3 4
       
# 42 "/usr/include/c++/4.8/cassert" 3

# 1 "/usr/include/assert.h" 1 3 4
# 43 "/usr/include/c++/4.8/cassert" 2 3
# 33 "/usr/include/glm/detail/func_exponential.inl" 2 3 4

namespace glm
{

 template <typename genType>
 inline genType pow
 (
  genType const & x,
  genType const & y
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'pow' only accept floating-point inputs")

                                             ;

  return std::pow(x, y);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> pow ( detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y ) { return detail::tvec2<T, P>( pow(x.x, y.x), pow(x.y, y.y)); } template <typename T, precision P> inline detail::tvec3<T, P> pow ( detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y ) { return detail::tvec3<T, P>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z)); } template <typename T, precision P> inline detail::tvec4<T, P> pow ( detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y ) { return detail::tvec4<T, P>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z), pow(x.w, y.w)); }


 template <typename genType>
 inline genType exp
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'exp' only accept floating-point inputs")

                                             ;

  return std::exp(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> exp( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( exp(v.x), exp(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> exp( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( exp(v.x), exp(v.y), exp(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> exp( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( exp(v.x), exp(v.y), exp(v.z), exp(v.w)); }


 template <typename genType>
 inline genType log
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'log' only accept floating-point inputs")

                                             ;

  return std::log(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> log( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( log(v.x), log(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> log( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( log(v.x), log(v.y), log(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> log( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( log(v.x), log(v.y), log(v.z), log(v.w)); }


 template <typename genType>
 inline genType exp2
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs")

                                              ;

  return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> exp2( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( exp2(v.x), exp2(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> exp2( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( exp2(v.x), exp2(v.y), exp2(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> exp2( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( exp2(v.x), exp2(v.y), exp2(v.z), exp2(v.w)); }

namespace detail
{
 template <bool isFloat>
 struct compute_log2
 {
  template <typename T>
  T operator() (T const & Value) const;
 };

 template <>
 struct compute_log2<true>
 {
  template <typename T>
  T operator() (T const & Value) const
  {
   return static_cast<T>(::std::log(Value)) * static_cast<T>(1.4426950408889634073599246810019);
  }
 };

}


 template <typename genType>
 inline genType log2
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "GLM core 'log2' only accept floating-point inputs. Include <glm/gtx/integer.hpp> for additional integer support.")
                                                                                                                      ;

  ((x > genType(0)) ? static_cast<void> (0) : __assert_fail ("x > genType(0)", "/usr/include/glm/detail/func_exponential.inl", 132, __PRETTY_FUNCTION__));
  return detail::compute_log2<std::numeric_limits<genType>::is_iec559>()(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> log2( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( log2(v.x), log2(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> log2( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( log2(v.x), log2(v.y), log2(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> log2( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( log2(v.x), log2(v.y), log2(v.z), log2(v.w)); }


 template <typename genType>
 inline genType sqrt
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'sqrt' only accept floating-point inputs")

                                              ;

  ((x >= genType(0)) ? static_cast<void> (0) : __assert_fail ("x >= genType(0)", "/usr/include/glm/detail/func_exponential.inl", 149, __PRETTY_FUNCTION__));

  return std::sqrt(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> sqrt( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( sqrt(v.x), sqrt(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> sqrt( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( sqrt(v.x), sqrt(v.y), sqrt(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> sqrt( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( sqrt(v.x), sqrt(v.y), sqrt(v.z), sqrt(v.w)); }

 namespace detail
 {
  template <template <class, precision> class vecType, typename T, precision P>
  struct compute_inversesqrt
  {
   static vecType<T, P> call(vecType<T, P> const & x)
   {
    return static_cast<T>(1) / sqrt(x);
   }
  };

  template <template <class, precision> class vecType>
  struct compute_inversesqrt<vecType, float, lowp>
  {
   static vecType<float, lowp> call(vecType<float, lowp> const & x)
   {
    vecType<float, lowp> tmp(x);
    vecType<float, lowp> xhalf(tmp * 0.5f);
    vecType<uint, lowp> i = *reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
    i = vecType<uint, lowp>(0x5f375a86) - (i >> vecType<uint, lowp>(1));
    tmp = *reinterpret_cast<vecType<float, lowp>*>(&i);
    tmp = tmp * (1.5f - xhalf * tmp * tmp);
    return tmp;
   }
  };
 }


 inline float inversesqrt(float const & x)
 {
  return 1.0f / sqrt(x);
 }

 inline double inversesqrt(double const & x)
 {
  return 1.0 / sqrt(x);
 }

 template <template <class, precision> class vecType, typename T, precision P>
 inline vecType<T, P> inversesqrt
 (
  vecType<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<vecType, T, P>::call(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> inversesqrt( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( inversesqrt(v.x), inversesqrt(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> inversesqrt( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> inversesqrt( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z), inversesqrt(v.w)); }
}
# 128 "/usr/include/glm/detail/func_exponential.hpp" 2 3 4
# 33 "/usr/include/glm/exponential.hpp" 2 3 4
# 110 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/common.hpp" 1 3 4
# 32 "/usr/include/glm/common.hpp" 3 4
# 1 "/usr/include/glm/detail/func_common.hpp" 1 3 4
# 42 "/usr/include/glm/detail/func_common.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 29 "/usr/include/glm/detail/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 30 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 43 "/usr/include/glm/detail/func_common.hpp" 2 3 4

namespace glm
{
# 55 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType abs(genType const & x);







 template <typename genType>
 genType sign(genType const & x);







 template <typename genType>
 genType floor(genType const & x);
# 83 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType trunc(genType const & x);
# 96 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType round(genType const & x);
# 108 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType roundEven(genType const & x);
# 118 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType ceil(genType const & x);







 template <typename genType>
 genType fract(genType const & x);
# 137 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType mod(
  genType const & x,
  genType const & y);
# 149 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType mod(
  genType const & x,
  typename genType::value_type const & y);
# 163 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType modf(
  genType const & x,
  genType & i);







 template <typename genType>
 genType min(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType min(
  genType const & x,
  typename genType::value_type const & y);







 template <typename genType>
 genType max(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType max(
  genType const & x,
  typename genType::value_type const & y);
# 207 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType clamp(
  genType const & x,
  genType const & minVal,
  genType const & maxVal);

 template <typename genType, precision P>
 genType clamp(
  genType const & x,
  typename genType::value_type const & minVal,
  typename genType::value_type const & maxVal);
# 261 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genTypeT, typename genTypeU>
 genTypeT mix(
  genTypeT const & x,
  genTypeT const & y,
  genTypeU const & a);





 template <typename genType>
 genType step(
  genType const & edge,
  genType const & x);





 template <template <typename, precision> class vecType, typename T, precision P>
 vecType<T, P> step(
  T const & edge,
  vecType<T, P> const & x);
# 299 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 genType smoothstep(
  genType const & edge0,
  genType const & edge1,
  genType const & x);

 template <typename genType>
 genType smoothstep(
  typename genType::value_type const & edge0,
  typename genType::value_type const & edge1,
  genType const & x);
# 323 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 typename genType::bool_type isnan(genType const & x);
# 336 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType>
 typename genType::bool_type isinf(genType const & x);







 int floatBitsToInt(float const & v);







 template <template <typename, precision> class vecType, precision P>
 vecType<int, P> floatBitsToInt(vecType<float, P> const & v);







 uint floatBitsToUint(float const & v);







 template <template <typename, precision> class vecType, precision P>
 vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);
# 381 "/usr/include/glm/detail/func_common.hpp" 3 4
 float intBitsToFloat(int const & v);
# 391 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <template <typename, precision> class vecType, precision P>
 vecType<float, P> intBitsToFloat(vecType<int, P> const & v);
# 402 "/usr/include/glm/detail/func_common.hpp" 3 4
 float uintBitsToFloat(uint const & v);
# 412 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <template <typename, precision> class vecType, precision P>
 vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);







 template <typename genType>
 genType fma(genType const & a, genType const & b, genType const & c);
# 438 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genType frexp(genType const & x, genIType & exp);
# 452 "/usr/include/glm/detail/func_common.hpp" 3 4
 template <typename genType, typename genIType>
 genType ldexp(genType const & x, genIType const & exp);


}

# 1 "/usr/include/glm/detail/func_common.inl" 1 3 4
# 36 "/usr/include/glm/detail/func_common.inl" 3 4
namespace glm{
namespace detail
{
 template <typename genFIType, bool >
 struct compute_abs
 {};

 template <typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline static genFIType call(genFIType const & x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x >= genFIType(0) ? x : -x;

  }
 };

 template <typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline static genFIType call(genFIType const & x)
  {
   static_assert(!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };
}


 template <typename genFIType>
 inline genFIType abs
 (
  genFIType const & x
 )
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> abs( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( abs(v.x), abs(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> abs( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( abs(v.x), abs(v.y), abs(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> abs( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( abs(v.x), abs(v.y), abs(v.z), abs(v.w)); }



 template <typename genFIType>
 inline genFIType sign
 (
  genFIType const & x
 )
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer, "'sign' only accept signed inputs")

                                                                                                                               ;

  genFIType result;
  if(x > genFIType(0))
   result = genFIType(1);
  else if(x < genFIType(0))
   result = genFIType(-1);
  else
   result = genFIType(0);
  return result;
 }

 template <typename T, precision P> inline detail::tvec2<T, P> sign( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( sign(v.x), sign(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> sign( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( sign(v.x), sign(v.y), sign(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> sign( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( sign(v.x), sign(v.y), sign(v.z), sign(v.w)); }


 template <typename genType>
 inline genType floor(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'floor' only accept floating-point inputs")

                                               ;

  return ::std::floor(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> floor( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( floor(v.x), floor(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> floor( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( floor(v.x), floor(v.y), floor(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> floor( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( floor(v.x), floor(v.y), floor(v.z), floor(v.w)); }


 template <typename genType>
 inline genType trunc(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'trunc' only accept floating-point inputs")

                                               ;


  return x < 0 ? -floor(-x) : floor(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> trunc( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( trunc(v.x), trunc(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> trunc( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( trunc(v.x), trunc(v.y), trunc(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> trunc( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( trunc(v.x), trunc(v.y), trunc(v.z), trunc(v.w)); }


 template <typename genType>
 inline genType round(genType const& x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'round' only accept floating-point inputs")

                                               ;


  return x < 0 ? genType(int(x - genType(0.5))) : genType(int(x + genType(0.5)));
 }

 template <typename T, precision P> inline detail::tvec2<T, P> round( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( round(v.x), round(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> round( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( round(v.x), round(v.y), round(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> round( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( round(v.x), round(v.y), round(v.z), round(v.w)); }
# 158 "/usr/include/glm/detail/func_common.inl" 3 4
 template <typename genType>
 inline genType roundEven(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs")

                                                   ;

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template <typename T, precision P> inline detail::tvec2<T, P> roundEven( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( roundEven(v.x), roundEven(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> roundEven( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( roundEven(v.x), roundEven(v.y), roundEven(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> roundEven( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( roundEven(v.x), roundEven(v.y), roundEven(v.z), roundEven(v.w)); }


 template <typename genType>
 inline genType ceil(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'ceil' only accept floating-point inputs")

                                              ;

  return ::std::ceil(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> ceil( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( ceil(v.x), ceil(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> ceil( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( ceil(v.x), ceil(v.y), ceil(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> ceil( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( ceil(v.x), ceil(v.y), ceil(v.z), ceil(v.w)); }


 template <typename genType>
 inline genType fract
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'fract' only accept floating-point inputs")

                                               ;

  return x - floor(x);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> fract( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( fract(v.x), fract(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> fract( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( fract(v.x), fract(v.y), fract(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> fract( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( fract(v.x), fract(v.y), fract(v.z), fract(v.w)); }


 template <typename genType>
 inline genType mod
 (
  genType const & x,
  genType const & y
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'mod' only accept floating-point inputs")

                                             ;

  return x - y * floor(x / y);
 }

 template <typename T, precision P> inline detail::tvec2<T, P> mod ( detail::tvec2<T, P> const & x, T const & y ) { return detail::tvec2<T, P>( mod(x.x, y), mod(x.y, y)); } template <typename T, precision P> inline detail::tvec3<T, P> mod ( detail::tvec3<T, P> const & x, T const & y ) { return detail::tvec3<T, P>( mod(x.x, y), mod(x.y, y), mod(x.z, y)); } template <typename T, precision P> inline detail::tvec4<T, P> mod ( detail::tvec4<T, P> const & x, T const & y ) { return detail::tvec4<T, P>( mod(x.x, y), mod(x.y, y), mod(x.z, y), mod(x.w, y)); }
 template <typename T, precision P> inline detail::tvec2<T, P> mod ( detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y ) { return detail::tvec2<T, P>( mod(x.x, y.x), mod(x.y, y.y)); } template <typename T, precision P> inline detail::tvec3<T, P> mod ( detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y ) { return detail::tvec3<T, P>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z)); } template <typename T, precision P> inline detail::tvec4<T, P> mod ( detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y ) { return detail::tvec4<T, P>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z), mod(x.w, y.w)); }


 template <typename genType>
 inline genType modf
 (
  genType const & x,
  genType & i
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs")

                                              ;

  return std::modf(x, &i);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> modf
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> & i
 )
 {
  return detail::tvec2<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> modf
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> & i
 )
 {
  return detail::tvec3<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> modf
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> & i
 )
 {
  return detail::tvec4<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 303 "/usr/include/glm/detail/func_common.inl" 3 4
 template <typename genType>
 inline genType min
 (
  genType const & x,
  genType const & y
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs")

                                                        ;

  return x < y ? x : y;
 }

 template <typename T, precision P> inline detail::tvec2<T, P> min ( detail::tvec2<T, P> const & x, T const & y ) { return detail::tvec2<T, P>( min(x.x, y), min(x.y, y)); } template <typename T, precision P> inline detail::tvec3<T, P> min ( detail::tvec3<T, P> const & x, T const & y ) { return detail::tvec3<T, P>( min(x.x, y), min(x.y, y), min(x.z, y)); } template <typename T, precision P> inline detail::tvec4<T, P> min ( detail::tvec4<T, P> const & x, T const & y ) { return detail::tvec4<T, P>( min(x.x, y), min(x.y, y), min(x.z, y), min(x.w, y)); }
 template <typename T, precision P> inline detail::tvec2<T, P> min ( detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y ) { return detail::tvec2<T, P>( min(x.x, y.x), min(x.y, y.y)); } template <typename T, precision P> inline detail::tvec3<T, P> min ( detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y ) { return detail::tvec3<T, P>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z)); } template <typename T, precision P> inline detail::tvec4<T, P> min ( detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y ) { return detail::tvec4<T, P>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z), min(x.w, y.w)); }


 template <typename genType>
 inline genType max
 (
  genType const & x,
  genType const & y
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs")

                                                        ;

  return x > y ? x : y;
 }

 template <typename T, precision P> inline detail::tvec2<T, P> max ( detail::tvec2<T, P> const & x, T const & y ) { return detail::tvec2<T, P>( max(x.x, y), max(x.y, y)); } template <typename T, precision P> inline detail::tvec3<T, P> max ( detail::tvec3<T, P> const & x, T const & y ) { return detail::tvec3<T, P>( max(x.x, y), max(x.y, y), max(x.z, y)); } template <typename T, precision P> inline detail::tvec4<T, P> max ( detail::tvec4<T, P> const & x, T const & y ) { return detail::tvec4<T, P>( max(x.x, y), max(x.y, y), max(x.z, y), max(x.w, y)); }
 template <typename T, precision P> inline detail::tvec2<T, P> max ( detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y ) { return detail::tvec2<T, P>( max(x.x, y.x), max(x.y, y.y)); } template <typename T, precision P> inline detail::tvec3<T, P> max ( detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y ) { return detail::tvec3<T, P>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z)); } template <typename T, precision P> inline detail::tvec4<T, P> max ( detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y ) { return detail::tvec4<T, P>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z), max(x.w, y.w)); }


 template <typename genType>
 inline genType clamp
 (
  genType const & x,
  genType const & minVal,
  genType const & maxVal
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return min(maxVal, max(minVal, x));
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> clamp
 (
  detail::tvec2<T, P> const & x,
  T const & minVal,
  T const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec2<T, P>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> clamp
 (
  detail::tvec3<T, P> const & x,
  T const & minVal,
  T const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec3<T, P>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal),
   clamp(x.z, minVal, maxVal));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> clamp
 (
  detail::tvec4<T, P> const & x,
  T const & minVal,
  T const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec4<T, P>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal),
   clamp(x.z, minVal, maxVal),
   clamp(x.w, minVal, maxVal));
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> clamp
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> const & minVal,
  detail::tvec2<T, P> const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec2<T, P>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> clamp
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & minVal,
  detail::tvec3<T, P> const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec3<T, P>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y),
   clamp(x.z, minVal.z, maxVal.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> clamp
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> const & minVal,
  detail::tvec4<T, P> const & maxVal
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs")

                                                          ;

  return detail::tvec4<T, P>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y),
   clamp(x.z, minVal.z, maxVal.z),
   clamp(x.w, minVal.w, maxVal.w));
 }


 template <typename genType>
 inline genType mix
 (
  genType const & x,
  genType const & y,
  genType const & a
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> mix
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> const & y,
  T const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> mix
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y,
  T const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> mix
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> const & y,
  T const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> mix
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> const & y,
  detail::tvec2<T, P> const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> mix
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y,
  detail::tvec3<T, P> const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> mix
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> const & y,
  detail::tvec4<T, P> const & a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return x + a * (y - x);
 }
# 584 "/usr/include/glm/detail/func_common.inl" 3 4
 template <>
 inline float mix
 (
  float const & x,
  float const & y,
  bool const & a
 )
 {
  return a ? y : x;
 }

 template <>
 inline double mix
 (
  double const & x,
  double const & y,
  bool const & a
 )
 {
  return a ? y : x;
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> mix
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> const & y,
  bool a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return a ? y : x;
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> mix
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y,
  bool a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return a ? y : x;
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> mix
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> const & y,
  bool a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  return a ? y : x;
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> mix
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<T, P> const & y,
  typename detail::tvec2<T, P>::bool_type a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  detail::tvec2<T, P> result;
  for(int i = 0; i < x.length(); ++i)
   result[i] = a[i] ? y[i] : x[i];

  return result;
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> mix
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y,
  typename detail::tvec3<T, P>::bool_type a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  detail::tvec3<T, P> result;
  for(int i = 0; i < x.length(); ++i)
   result[i] = a[i] ? y[i] : x[i];

  return result;
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> mix
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<T, P> const & y,
  typename detail::tvec4<T, P>::bool_type a
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'mix' only accept floating-point inputs")

                                             ;

  detail::tvec4<T, P> result;
  for(int i = 0; i < x.length(); ++i)
   result[i] = a[i] ? y[i] : x[i];

  return result;
 }


 template <typename genType>
 inline genType step
 (
  genType const & edge,
  genType const & x
 )
 {
  return mix(genType(1), genType(0), glm::lessThan(x, edge));
 }

 template <template <typename, precision> class vecType, typename T, precision P>
 inline vecType<T, P> step
 (
  T const & edge,
  vecType<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'step' only accept floating-point inputs")

                                              ;

  return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, vecType<T, P>(edge)));
 }


 template <typename genType>
 inline genType smoothstep
 (
  genType const & edge0,
  genType const & edge1,
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  genType tmp = clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> smoothstep
 (
  T const & edge0,
  T const & edge1,
  detail::tvec2<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec2<T, P>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> smoothstep
 (
  T const & edge0,
  T const & edge1,
  detail::tvec3<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec3<T, P>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y),
   smoothstep(edge0, edge1, x.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> smoothstep
 (
  T const & edge0,
  T const & edge1,
  detail::tvec4<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec4<T, P>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y),
   smoothstep(edge0, edge1, x.z),
   smoothstep(edge0, edge1, x.w));
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> smoothstep
 (
  detail::tvec2<T, P> const & edge0,
  detail::tvec2<T, P> const & edge1,
  detail::tvec2<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec2<T, P>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> smoothstep
 (
  detail::tvec3<T, P> const & edge0,
  detail::tvec3<T, P> const & edge1,
  detail::tvec3<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec3<T, P>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y),
   smoothstep(edge0.z, edge1.z, x.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> smoothstep
 (
  detail::tvec4<T, P> const & edge0,
  detail::tvec4<T, P> const & edge1,
  detail::tvec4<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs")

                                                    ;

  return detail::tvec4<T, P>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y),
   smoothstep(edge0.z, edge1.z, x.z),
   smoothstep(edge0.w, edge1.w, x.w));
 }


 template <typename genType>
 inline bool isnan(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'isnan' only accept floating-point inputs")

                                               ;







    return std::isnan(x);






 }

 template <typename T, precision P>
 inline typename detail::tvec2<T, P>::bool_type isnan
 (
  detail::tvec2<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs")

                                               ;

  return typename detail::tvec2<T, P>::bool_type(
   isnan(x.x),
   isnan(x.y));
 }

 template <typename T, precision P>
 inline typename detail::tvec3<T, P>::bool_type isnan
 (
  detail::tvec3<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs")

                                               ;

  return typename detail::tvec3<T, P>::bool_type(
   isnan(x.x),
   isnan(x.y),
   isnan(x.z));
 }

 template <typename T, precision P>
 inline typename detail::tvec4<T, P>::bool_type isnan
 (
  detail::tvec4<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs")

                                               ;

  return typename detail::tvec4<T, P>::bool_type(
   isnan(x.x),
   isnan(x.y),
   isnan(x.z),
   isnan(x.w));
 }

 template <typename genType>
 inline bool isinf(
  genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'isinf' only accept floating-point inputs")

                                               ;







    return std::isinf(x);







 }

 template <typename T, precision P>
 inline typename detail::tvec2<T, P>::bool_type isinf
 (
  detail::tvec2<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs")

                                               ;

  return typename detail::tvec2<T, P>::bool_type(
   isinf(x.x),
   isinf(x.y));
 }

 template <typename T, precision P>
 inline typename detail::tvec3<T, P>::bool_type isinf
 (
  detail::tvec3<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs")

                                               ;

  return typename detail::tvec3<T, P>::bool_type(
   isinf(x.x),
   isinf(x.y),
   isinf(x.z));
 }

 template <typename T, precision P>
 inline typename detail::tvec4<T, P>::bool_type isinf
 (
  detail::tvec4<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isinf' only accept floating-point inputs")

                                               ;

  return typename detail::tvec4<T, P>::bool_type(
   isinf(x.x),
   isinf(x.y),
   isinf(x.z),
   isinf(x.w));
 }

 inline int floatBitsToInt(float const & v)
 {
  return reinterpret_cast<int&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
 }

 inline uint floatBitsToUint(float const & v)
 {
  return reinterpret_cast<uint&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
 }

 inline float intBitsToFloat(int const & v)
 {
  return reinterpret_cast<float&>(const_cast<int&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
 }

 inline float uintBitsToFloat(uint const & v)
 {
  return reinterpret_cast<float&>(const_cast<uint&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
 }

 template <typename genType>
 inline genType fma
 (
  genType const & a,
  genType const & b,
  genType const & c
 )
 {
  return a * b + c;
 }

 template <typename genType>
 inline genType frexp
 (
  genType const & x,
  int & exp
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs")

                                               ;

  return std::frexp(x, exp);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> frexp
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<int, P> & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs")

                                               ;

  return detail::tvec2<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> frexp
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<int, P> & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs")

                                               ;

  return detail::tvec3<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> frexp
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<int, P> & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs")

                                               ;

  return detail::tvec4<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z),
   frexp(x.w, exp.w));
 }

 template <typename genType, precision P>
 inline genType ldexp
 (
  genType const & x,
  int const & exp
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs")

                                               ;

  return std::ldexp(x, exp);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> ldexp
 (
  detail::tvec2<T, P> const & x,
  detail::tvec2<int, P> const & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs")

                                               ;

  return detail::tvec2<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> ldexp
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<int, P> const & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs")

                                               ;

  return detail::tvec3<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> ldexp
 (
  detail::tvec4<T, P> const & x,
  detail::tvec4<int, P> const & exp
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs")

                                               ;

  return detail::tvec4<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z),
   ldexp(x.w, exp.w));
 }

}
# 459 "/usr/include/glm/detail/func_common.hpp" 2 3 4
# 33 "/usr/include/glm/common.hpp" 2 3 4
# 111 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/packing.hpp" 1 3 4
# 32 "/usr/include/glm/packing.hpp" 3 4
# 1 "/usr/include/glm/detail/func_packing.hpp" 1 3 4
# 42 "/usr/include/glm/detail/func_packing.hpp" 3 4
namespace glm
{
# 58 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uint packUnorm2x16(vec2 const & v);
# 71 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uint packSnorm2x16(vec2 const & v);
# 84 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uint packUnorm4x8(vec4 const & v);
# 97 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uint packSnorm4x8(vec4 const & v);
# 110 "/usr/include/glm/detail/func_packing.hpp" 3 4
 vec2 unpackUnorm2x16(uint const & p);
# 123 "/usr/include/glm/detail/func_packing.hpp" 3 4
 vec2 unpackSnorm2x16(uint const & p);
# 136 "/usr/include/glm/detail/func_packing.hpp" 3 4
 vec4 unpackUnorm4x8(uint const & p);
# 149 "/usr/include/glm/detail/func_packing.hpp" 3 4
 vec4 unpackSnorm4x8(uint const & p);
# 159 "/usr/include/glm/detail/func_packing.hpp" 3 4
 double packDouble2x32(uvec2 const & v);
# 168 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uvec2 unpackDouble2x32(double const & v);
# 178 "/usr/include/glm/detail/func_packing.hpp" 3 4
 uint packHalf2x16(vec2 const & v);
# 188 "/usr/include/glm/detail/func_packing.hpp" 3 4
 vec2 unpackHalf2x16(uint const & v);


}

# 1 "/usr/include/glm/detail/func_packing.inl" 1 3 4
# 29 "/usr/include/glm/detail/func_packing.inl" 3 4
# 1 "/usr/include/glm/detail/func_common.hpp" 1 3 4
# 30 "/usr/include/glm/detail/func_packing.inl" 2 3 4
# 1 "/usr/include/glm/detail/type_half.hpp" 1 3 4
# 34 "/usr/include/glm/detail/type_half.hpp" 3 4
namespace glm{
namespace detail
{
 typedef short hdata;

 float toFloat32(hdata value);
 hdata toFloat16(float const & value);

}




}

# 1 "/usr/include/glm/detail/type_half.inl" 1 3 4
# 33 "/usr/include/glm/detail/type_half.inl" 3 4
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;

  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f) :
   f(f)
  {}

  inline uif32(uint32 i) :
   i(i)
  {}

  float f;
  uint32 i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const & f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 154 "/usr/include/glm/detail/type_half.inl" 3 4
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 174 "/usr/include/glm/detail/type_half.inl" 3 4
    return hdata(s);
   }
# 184 "/usr/include/glm/detail/type_half.inl" 3 4
   m = (m | 0x00800000) >> (1 - e);
# 195 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 226 "/usr/include/glm/detail/type_half.inl" 3 4
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 242 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 50 "/usr/include/glm/detail/type_half.hpp" 2 3 4
# 31 "/usr/include/glm/detail/func_packing.inl" 2 3 4


namespace glm
{
 inline uint packUnorm2x16(vec2 const & v)
 {
  u16vec2 Topack(round(clamp(v, 0.0f, 1.0f) * 65535.0f));
  return reinterpret_cast<uint&>(Topack);
 }

 inline vec2 unpackUnorm2x16(uint const & p)
 {
  vec2 Unpack(reinterpret_cast<u16vec2 const &>(p));
  return Unpack * float(1.5259021896696421759365224689097e-5);
 }

 inline uint packSnorm2x16(vec2 const & v)
 {
  i16vec2 Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));
  return reinterpret_cast<uint32&>(Topack);
 }

 inline vec2 unpackSnorm2x16(uint const & p)
 {
  vec2 Unpack(reinterpret_cast<i16vec2 const &>(p));
  return clamp(
   Unpack * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const & v)
 {
  u8vec4 Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));
  return reinterpret_cast<uint&>(Topack);
 }

 inline vec4 unpackUnorm4x8(uint const & p)
 {
  vec4 Unpack(reinterpret_cast<u8vec4 const&>(p));
  return Unpack * float(0.0039215686274509803921568627451);
 }

 inline uint packSnorm4x8(vec4 const & v)
 {
  i8vec4 Topack(round(clamp(v ,-1.0f, 1.0f) * 127.0f));
  return reinterpret_cast<uint&>(Topack);
 }

 inline glm::vec4 unpackSnorm4x8(uint const & p)
 {
  vec4 Unpack(reinterpret_cast<i8vec4 const &>(p));
  return clamp(
   Unpack * 0.0078740157480315f,
   -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const & v)
 {
  return reinterpret_cast<double const &>(v);
 }

 inline uvec2 unpackDouble2x32(double const & v)
 {
  return reinterpret_cast<uvec2 const &>(v);
 }

 inline uint packHalf2x16(vec2 const & v)
 {
  i16vec2 Unpack(
   detail::toFloat16(v.x),
   detail::toFloat16(v.y));

  return *reinterpret_cast<uint*>(&Unpack);
 }

 inline vec2 unpackHalf2x16(uint const & v)
 {
  i16vec2 Unpack(reinterpret_cast<i16vec2 const &>(v));

  return vec2(
   detail::toFloat32(Unpack.x),
   detail::toFloat32(Unpack.y));
 }
}
# 194 "/usr/include/glm/detail/func_packing.hpp" 2 3 4
# 33 "/usr/include/glm/packing.hpp" 2 3 4
# 112 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/geometric.hpp" 1 3 4
# 32 "/usr/include/glm/geometric.hpp" 3 4
# 1 "/usr/include/glm/detail/func_geometric.hpp" 1 3 4
# 41 "/usr/include/glm/detail/func_geometric.hpp" 3 4
namespace glm
{
# 52 "/usr/include/glm/detail/func_geometric.hpp" 3 4
 template <typename genType>
 typename genType::value_type length(
  genType const & x);







 template <typename genType>
 typename genType::value_type distance(
  genType const & p0,
  genType const & p1);







 template <typename T, precision P, template <typename, precision> class vecType>
 T dot(
  vecType<T, P> const & x,
  vecType<T, P> const & y);







 template <typename genType>
 genType dot(
  genType const & x,
  genType const & y);







 template <typename T, precision P>
 detail::tvec3<T, P> cross(
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y);





 template <typename genType>
 genType normalize(
  genType const & x);







 template <typename genType>
 genType faceforward(
  genType const & N,
  genType const & I,
  genType const & Nref);
# 127 "/usr/include/glm/detail/func_geometric.hpp" 3 4
 template <typename genType>
 genType reflect(
  genType const & I,
  genType const & N);
# 140 "/usr/include/glm/detail/func_geometric.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> refract(
  vecType<T, P> const & I,
  vecType<T, P> const & N,
  T const & eta);


}

# 1 "/usr/include/glm/detail/func_geometric.inl" 1 3 4
# 29 "/usr/include/glm/detail/func_geometric.inl" 3 4
# 1 "/usr/include/glm/detail/func_exponential.hpp" 1 3 4
# 30 "/usr/include/glm/detail/func_geometric.inl" 2 3 4



# 1 "/usr/include/glm/detail/type_float.hpp" 1 3 4
# 34 "/usr/include/glm/detail/func_geometric.inl" 2 3 4

namespace glm{
namespace detail
{
 template <template <class, precision> class vecType, typename T, precision P>
 struct compute_dot{};

 template <typename T, precision P>
 struct compute_dot<detail::tvec1, T, P>
 {
  static T call(detail::tvec1<T, P> const & x, detail::tvec1<T, P> const & y)
  {
   return detail::tvec1<T, P>(x * y).x;
  }
 };

 template <typename T, precision P>
 struct compute_dot<detail::tvec2, T, P>
 {
  static T call(detail::tvec2<T, P> const & x, detail::tvec2<T, P> const & y)
  {
   detail::tvec2<T, P> tmp(x * y);
   return tmp.x + tmp.y;
  }
 };

 template <typename T, precision P>
 struct compute_dot<detail::tvec3, T, P>
 {
  static T call(detail::tvec3<T, P> const & x, detail::tvec3<T, P> const & y)
  {
   detail::tvec3<T, P> tmp(x * y);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template <typename T, precision P>
 struct compute_dot<detail::tvec4, T, P>
 {
  static T call(detail::tvec4<T, P> const & x, detail::tvec4<T, P> const & y)
  {
   detail::tvec4<T, P> tmp(x * y);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };
}


 template <typename genType>
 inline genType length
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' only accept floating-point inputs");

  genType sqr = x * x;
  return sqrt(sqr);
 }

 template <typename T, precision P>
 inline T length(detail::tvec2<T, P> const & v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' only accept floating-point inputs");

  T sqr = v.x * v.x + v.y * v.y;
  return sqrt(sqr);
 }

 template <typename T, precision P>
 inline T length(detail::tvec3<T, P> const & v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' only accept floating-point inputs");

  T sqr = v.x * v.x + v.y * v.y + v.z * v.z;
  return sqrt(sqr);
 }

 template <typename T, precision P>
 inline T length(detail::tvec4<T, P> const & v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' only accept floating-point inputs");

  T sqr = v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
  return sqrt(sqr);
 }


 template <typename genType>
 inline genType distance
 (
  genType const & p0,
  genType const & p1
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' only accept floating-point inputs");

  return length(p1 - p0);
 }

 template <typename T, precision P>
 inline T distance
 (
  detail::tvec2<T, P> const & p0,
  detail::tvec2<T, P> const & p1
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'distance' only accept floating-point inputs");

  return length(p1 - p0);
 }

 template <typename T, precision P>
 inline T distance
 (
  detail::tvec3<T, P> const & p0,
  detail::tvec3<T, P> const & p1
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'distance' only accept floating-point inputs");

  return length(p1 - p0);
 }

 template <typename T, precision P>
 inline T distance
 (
  detail::tvec4<T, P> const & p0,
  detail::tvec4<T, P> const & p1
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'distance' only accept floating-point inputs");

  return length(p1 - p0);
 }


 template <typename T>
 inline T dot
 (
  T const & x,
  T const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
  return detail::compute_dot<detail::tvec1, T, highp>::call(x, y);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline T dot
 (
  vecType<T, P> const & x,
  vecType<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
  return detail::compute_dot<vecType, T, P>::call(x, y);
 }
# 211 "/usr/include/glm/detail/func_geometric.inl" 3 4
 template <typename T, precision P>
 inline detail::tvec3<T, P> cross
 (
  detail::tvec3<T, P> const & x,
  detail::tvec3<T, P> const & y
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'cross' only accept floating-point inputs");

  return detail::tvec3<T, P>(
   x.y * y.z - y.y * x.z,
   x.z * y.x - y.z * x.x,
   x.x * y.y - y.x * x.y);
 }


 template <typename genType>
 inline genType normalize
 (
  genType const & x
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'normalize' only accept floating-point inputs");

  return x < genType(0) ? genType(-1) : genType(1);
 }


 template <typename T, precision P>
 inline detail::tvec2<T, P> normalize
 (
  detail::tvec2<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' only accept floating-point inputs");

  T sqr = x.x * x.x + x.y * x.y;
  return x * inversesqrt(sqr);
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> normalize
 (
  detail::tvec3<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' only accept floating-point inputs");

  T sqr = x.x * x.x + x.y * x.y + x.z * x.z;
  return x * inversesqrt(sqr);
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> normalize
 (
  detail::tvec4<T, P> const & x
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' only accept floating-point inputs");

  T sqr = x.x * x.x + x.y * x.y + x.z * x.z + x.w * x.w;
  return x * inversesqrt(sqr);
 }


 template <typename genType>
 inline genType faceforward
 (
  genType const & N,
  genType const & I,
  genType const & Nref
 )
 {
  return dot(Nref, I) < 0 ? N : -N;
 }


 template <typename genType>
 inline genType reflect
 (
  genType const & I,
  genType const & N
 )
 {
  return I - N * dot(N, I) * genType(2);
 }


 template <typename genType>
 inline genType refract
 (
  genType const & I,
  genType const & N,
  genType const & eta
 )
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' only accept floating-point inputs");

  genType dotValue = dot(N, I);
  genType k = genType(1) - eta * eta * (genType(1) - dotValue * dotValue);
  if(k < genType(0))
   return genType(0);
  else
   return eta * I - (eta * dotValue + sqrt(k)) * N;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> refract
 (
  vecType<T, P> const & I,
  vecType<T, P> const & N,
  T const & eta
 )
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' only accept floating-point inputs");

  T dotValue = dot(N, I);
  T k = T(1) - eta * eta * (T(1) - dotValue * dotValue);
  if(k < T(0))
   return vecType<T, P>(0);
  else
   return eta * I - (eta * dotValue + std::sqrt(k)) * N;
 }

}
# 150 "/usr/include/glm/detail/func_geometric.hpp" 2 3 4
# 33 "/usr/include/glm/geometric.hpp" 2 3 4
# 113 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/matrix.hpp" 1 3 4
# 32 "/usr/include/glm/matrix.hpp" 3 4
# 1 "/usr/include/glm/detail/func_matrix.hpp" 1 3 4
# 44 "/usr/include/glm/detail/func_matrix.hpp" 3 4
# 1 "/usr/include/glm/detail/precision.hpp" 1 3 4
# 45 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 46 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/detail/type_mat.hpp" 1 3 4
# 47 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/vec2.hpp" 1 3 4
# 48 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/vec3.hpp" 1 3 4
# 49 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/vec4.hpp" 1 3 4
# 50 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x2.hpp" 1 3 4
# 51 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x3.hpp" 1 3 4
# 52 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x4.hpp" 1 3 4
# 53 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x2.hpp" 1 3 4
# 54 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x3.hpp" 1 3 4
# 55 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x4.hpp" 1 3 4
# 56 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x2.hpp" 1 3 4
# 57 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x3.hpp" 1 3 4
# 58 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x4.hpp" 1 3 4
# 59 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4

namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec2>
 {
  typedef tmat2x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec3>
 {
  typedef tmat2x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec4>
 {
  typedef tmat2x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec2>
 {
  typedef tmat3x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec3>
 {
  typedef tmat3x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec4>
 {
  typedef tmat3x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec2>
 {
  typedef tmat4x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec3>
 {
  typedef tmat4x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec4>
 {
  typedef tmat4x4<T, P> type;
 };

}
# 129 "/usr/include/glm/detail/func_matrix.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class matType>
 matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);
# 142 "/usr/include/glm/detail/func_matrix.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
 typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);
# 162 "/usr/include/glm/detail/func_matrix.hpp" 3 4
 template <typename T, precision P, template <typename, precision> class matType>
 T determinant(matType<T, P> const & m);







 template <typename T, precision P, template <typename, precision> class matType>
 matType<T, P> inverse(matType<T, P> const & m);


}

# 1 "/usr/include/glm/detail/func_matrix.inl" 1 3 4
# 29 "/usr/include/glm/detail/func_matrix.inl" 3 4
# 1 "/usr/include/glm/geometric.hpp" 1 3 4
# 30 "/usr/include/glm/detail/func_matrix.inl" 2 3 4


namespace glm{
namespace detail
{
 template
 <
  template <class, precision> class vecTypeA,
  template <class, precision> class vecTypeB,
  typename T, precision P
 >
 struct compute_outerProduct{};

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec2, detail::tvec2, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec2, detail::tvec2>::type call(detail::tvec2<T, P> const & c, detail::tvec2<T, P> const & r)
  {
   detail::tmat2x2<T, P> m(detail::tmat2x2<T, P>::null);
   m[0][0] = c[0] * r[0];
   m[0][1] = c[1] * r[0];
   m[1][0] = c[0] * r[1];
   m[1][1] = c[1] * r[1];
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec3, detail::tvec3, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec3, detail::tvec3>::type call(detail::tvec3<T, P> const & c, detail::tvec3<T, P> const & r)
  {
   detail::tmat3x3<T, P> m(detail::tmat3x3<T, P>::null);
   for(length_t i(0); i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec4, detail::tvec4, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec4, detail::tvec4>::type call(detail::tvec4<T, P> const & c, detail::tvec4<T, P> const & r)
  {
   detail::tmat4x4<T, P> m(detail::tmat4x4<T, P>::null);
   for(length_t i(0); i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec3, detail::tvec2, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec3, detail::tvec2>::type call(detail::tvec3<T, P> const & c, detail::tvec2<T, P> const & r)
  {
   detail::tmat2x3<T, P> m(detail::tmat2x3<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[0][2] = c.z * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[1][2] = c.z * r.y;
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec2, detail::tvec3, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec2, detail::tvec3>::type call(detail::tvec2<T, P> const & c, detail::tvec3<T, P> const & r)
  {
   detail::tmat3x2<T, P> m(detail::tmat3x2<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[2][0] = c.x * r.z;
   m[2][1] = c.y * r.z;
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec4, detail::tvec2, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec4, detail::tvec2>::type call(detail::tvec4<T, P> const & c, detail::tvec2<T, P> const & r)
  {
   detail::tmat2x4<T, P> m(detail::tmat2x4<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[0][2] = c.z * r.x;
   m[0][3] = c.w * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[1][2] = c.z * r.y;
   m[1][3] = c.w * r.y;
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec2, detail::tvec4, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec2, detail::tvec4>::type call(detail::tvec2<T, P> const & c, detail::tvec4<T, P> const & r)
  {
   detail::tmat4x2<T, P> m(detail::tmat4x2<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[2][0] = c.x * r.z;
   m[2][1] = c.y * r.z;
   m[3][0] = c.x * r.w;
   m[3][1] = c.y * r.w;
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec4, detail::tvec3, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec4, detail::tvec3>::type call(detail::tvec4<T, P> const & c, detail::tvec3<T, P> const & r)
  {
   detail::tmat3x4<T, P> m(detail::tmat3x4<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[0][2] = c.z * r.x;
   m[0][3] = c.w * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[1][2] = c.z * r.y;
   m[1][3] = c.w * r.y;
   m[2][0] = c.x * r.z;
   m[2][1] = c.y * r.z;
   m[2][2] = c.z * r.z;
   m[2][3] = c.w * r.z;
   return m;
  }
 };

 template <typename T, precision P>
 struct compute_outerProduct<detail::tvec3, detail::tvec4, T, P>
 {
  inline static typename detail::outerProduct_trait<T, P, detail::tvec3, detail::tvec4>::type call(detail::tvec3<T, P> const & c, detail::tvec4<T, P> const & r)
  {
   detail::tmat4x3<T, P> m(detail::tmat4x3<T, P>::null);
   m[0][0] = c.x * r.x;
   m[0][1] = c.y * r.x;
   m[0][2] = c.z * r.x;
   m[1][0] = c.x * r.y;
   m[1][1] = c.y * r.y;
   m[1][2] = c.z * r.y;
   m[2][0] = c.x * r.z;
   m[2][1] = c.y * r.z;
   m[2][2] = c.z * r.z;
   m[3][0] = c.x * r.w;
   m[3][1] = c.y * r.w;
   m[3][2] = c.z * r.w;
   return m;
  }
 };

 template <template <class, precision> class matType, typename T, precision P>
 struct compute_transpose{};

 template <typename T, precision P>
 struct compute_transpose<detail::tmat2x2, T, P>
 {
  inline static detail::tmat2x2<T, P> call(detail::tmat2x2<T, P> const & m)
  {
   detail::tmat2x2<T, P> result(detail::tmat2x2<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat2x3, T, P>
 {
  inline static detail::tmat3x2<T, P> call(detail::tmat2x3<T, P> const & m)
  {
   detail::tmat3x2<T, P> result(detail::tmat3x2<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat2x4, T, P>
 {
  inline static detail::tmat4x2<T, P> call(detail::tmat2x4<T, P> const & m)
  {
   detail::tmat4x2<T, P> result(detail::tmat4x2<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat3x2, T, P>
 {
  inline static detail::tmat2x3<T, P> call(detail::tmat3x2<T, P> const & m)
  {
   detail::tmat2x3<T, P> result(detail::tmat2x3<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat3x3, T, P>
 {
  inline static detail::tmat3x3<T, P> call(detail::tmat3x3<T, P> const & m)
  {
   detail::tmat3x3<T, P> result(detail::tmat3x3<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat3x4, T, P>
 {
  inline static detail::tmat4x3<T, P> call(detail::tmat3x4<T, P> const & m)
  {
   detail::tmat4x3<T, P> result(detail::tmat4x3<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat4x2, T, P>
 {
  inline static detail::tmat2x4<T, P> call(detail::tmat4x2<T, P> const & m)
  {
   detail::tmat2x4<T, P> result(detail::tmat2x4<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat4x3, T, P>
 {
  inline static detail::tmat3x4<T, P> call(detail::tmat4x3<T, P> const & m)
  {
   detail::tmat3x4<T, P> result(detail::tmat3x4<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<detail::tmat4x4, T, P>
 {
  inline static detail::tmat4x4<T, P> call(detail::tmat4x4<T, P> const & m)
  {
   detail::tmat4x4<T, P> result(detail::tmat4x4<T, P>::_null);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];

   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   result[3][3] = m[3][3];
   return result;
  }
 };

 template <template <class, precision> class matType, typename T, precision P>
 struct compute_determinant{};

 template <typename T, precision P>
 struct compute_determinant<detail::tmat2x2, T, P>
 {
  inline static T call(detail::tmat2x2<T, P> const & m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template <typename T, precision P>
 struct compute_determinant<detail::tmat3x3, T, P>
 {
  inline static T call(detail::tmat3x3<T, P> const & m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template <typename T, precision P>
 struct compute_determinant<detail::tmat4x4, T, P>
 {
  inline static T call(detail::tmat4x4<T, P> const & m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   detail::tvec4<T, P> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };
}

 template <typename T, precision P, template <typename, precision> class matType>
 inline matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'matrixCompMult' only accept floating-point inputs");

  matType<T, P> result(matType<T, P>::_null);
  for(length_t i = 0; i < result.length(); ++i)
   result[i] = x[i] * y[i];
  return result;
 }

 template<template <class, precision> class vecTypeA, template <class, precision> class vecTypeB, typename T, precision P>
 inline typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'outerProduct' only accept floating-point inputs");
  return detail::compute_outerProduct<vecTypeA, vecTypeB, T, P>::call(c, r);
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'transpose' only accept floating-point inputs");
  return detail::compute_transpose<matType, T, P>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline T determinant(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'determinant' only accept floating-point inputs");
  return detail::compute_determinant<matType, T, P>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline matType<T, P> inverse(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse<matType, T, P>::call(m);
 }

}
# 178 "/usr/include/glm/detail/func_matrix.hpp" 2 3 4
# 33 "/usr/include/glm/matrix.hpp" 2 3 4
# 114 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vector_relational.hpp" 1 3 4
# 32 "/usr/include/glm/vector_relational.hpp" 3 4
# 1 "/usr/include/glm/detail/func_vector_relational.hpp" 1 3 4
# 33 "/usr/include/glm/vector_relational.hpp" 2 3 4
# 115 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/integer.hpp" 1 3 4
# 32 "/usr/include/glm/integer.hpp" 3 4
# 1 "/usr/include/glm/detail/func_integer.hpp" 1 3 4
# 43 "/usr/include/glm/detail/func_integer.hpp" 3 4
namespace glm
{
# 56 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genUType>
 genUType uaddCarry(
  genUType const & x,
  genUType const & y,
  genUType & carry);
# 70 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genUType>
 genUType usubBorrow(
  genUType const & x,
  genUType const & y,
  genUType & borrow);
# 84 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genUType>
 void umulExtended(
  genUType const & x,
  genUType const & y,
  genUType & msb,
  genUType & lsb);
# 99 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genIType>
 void imulExtended(
  genIType const & x,
  genIType const & y,
  genIType & msb,
  genIType & lsb);
# 121 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldExtract(
  genIUType const & Value,
  int const & Offset,
  int const & Bits);
# 141 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldInsert(
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits);
# 156 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename genIUType>
 genIUType bitfieldReverse(genIUType const & Value);
# 167 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type bitCount(genIUType<T> const & Value);
# 180 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findLSB(genIUType<T> const & Value);
# 194 "/usr/include/glm/detail/func_integer.hpp" 3 4
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findMSB(genIUType<T> const & Value);


}

# 1 "/usr/include/glm/detail/func_integer.inl" 1 3 4
# 42 "/usr/include/glm/detail/func_integer.inl" 3 4
namespace glm
{

 template <>
 inline uint uaddCarry
 (
  uint const & x,
  uint const & y,
  uint & Carry
 )
 {
  uint64 Value64 = static_cast<uint64>(x) + static_cast<uint64>(y);
  uint32 Result = static_cast<uint32>(Value64 % (static_cast<uint64>(1) << static_cast<uint64>(32)));
  Carry = (Value64 % (static_cast<uint64>(1) << static_cast<uint64>(32))) > 1 ? static_cast<uint32>(1) : static_cast<uint32>(0);
  return Result;
 }

 template <>
 inline uvec2 uaddCarry
 (
  uvec2 const & x,
  uvec2 const & y,
  uvec2 & Carry
 )
 {
  return uvec2(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]));
 }

 template <>
 inline uvec3 uaddCarry
 (
  uvec3 const & x,
  uvec3 const & y,
  uvec3 & Carry
 )
 {
  return uvec3(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]));
 }

 template <>
 inline uvec4 uaddCarry
 (
  uvec4 const & x,
  uvec4 const & y,
  uvec4 & Carry
 )
 {
  return uvec4(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]),
   uaddCarry(x[3], y[3], Carry[3]));
 }


 template <>
 inline uint usubBorrow
 (
  uint const & x,
  uint const & y,
  uint & Borrow
 )
 {
  static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

  Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
  if(x > y)
   return static_cast<uint32>(static_cast<int64>(x) -static_cast<int64>(y));
  else
   return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + static_cast<int64>(x) - static_cast<int64>(y));
 }

 template <>
 inline uvec2 usubBorrow
 (
  uvec2 const & x,
  uvec2 const & y,
  uvec2 & Borrow
 )
 {
  return uvec2(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]));
 }

 template <>
 inline uvec3 usubBorrow
 (
  uvec3 const & x,
  uvec3 const & y,
  uvec3 & Borrow
 )
 {
  return uvec3(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]));
 }

 template <>
 inline uvec4 usubBorrow
 (
  uvec4 const & x,
  uvec4 const & y,
  uvec4 & Borrow
 )
 {
  return uvec4(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]),
   usubBorrow(x[3], y[3], Borrow[3]));
 }


 template <>
 inline void umulExtended
 (
  uint const & x,
  uint const & y,
  uint & msb,
  uint & lsb
 )
 {
  static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

  uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
  msb = *(reinterpret_cast<uint32*>(&Value64) + 1);
  lsb = reinterpret_cast<uint32&>(Value64);
 }

 template <>
 inline void umulExtended
 (
  uvec2 const & x,
  uvec2 const & y,
  uvec2 & msb,
  uvec2 & lsb
 )
 {
  umulExtended(x[0], y[0], msb[0], lsb[0]);
  umulExtended(x[1], y[1], msb[1], lsb[1]);
 }

 template <>
 inline void umulExtended
 (
  uvec3 const & x,
  uvec3 const & y,
  uvec3 & msb,
  uvec3 & lsb
 )
 {
  umulExtended(x[0], y[0], msb[0], lsb[0]);
  umulExtended(x[1], y[1], msb[1], lsb[1]);
  umulExtended(x[2], y[2], msb[2], lsb[2]);
 }

 template <>
 inline void umulExtended
 (
  uvec4 const & x,
  uvec4 const & y,
  uvec4 & msb,
  uvec4 & lsb
 )
 {
  umulExtended(x[0], y[0], msb[0], lsb[0]);
  umulExtended(x[1], y[1], msb[1], lsb[1]);
  umulExtended(x[2], y[2], msb[2], lsb[2]);
  umulExtended(x[3], y[3], msb[3], lsb[3]);
 }


 template <>
 inline void imulExtended
 (
  int const & x,
  int const & y,
  int & msb,
  int & lsb
 )
 {
  static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");

  int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
  msb = *(reinterpret_cast<int32*>(&Value64) + 1);
  lsb = reinterpret_cast<int32&>(Value64);
 }

 template <>
 inline void imulExtended
 (
  ivec2 const & x,
  ivec2 const & y,
  ivec2 & msb,
  ivec2 & lsb
 )
 {
  imulExtended(x[0], y[0], msb[0], lsb[0]),
  imulExtended(x[1], y[1], msb[1], lsb[1]);
 }

 template <>
 inline void imulExtended
 (
  ivec3 const & x,
  ivec3 const & y,
  ivec3 & msb,
  ivec3 & lsb
 )
 {
  imulExtended(x[0], y[0], msb[0], lsb[0]),
  imulExtended(x[1], y[1], msb[1], lsb[1]);
  imulExtended(x[2], y[2], msb[2], lsb[2]);
 }

 template <>
 inline void imulExtended
 (
  ivec4 const & x,
  ivec4 const & y,
  ivec4 & msb,
  ivec4 & lsb
 )
 {
  imulExtended(x[0], y[0], msb[0], lsb[0]),
  imulExtended(x[1], y[1], msb[1], lsb[1]);
  imulExtended(x[2], y[2], msb[2], lsb[2]);
  imulExtended(x[3], y[3], msb[3], lsb[3]);
 }


 template <typename genIUType>
 inline genIUType bitfieldExtract
 (
  genIUType const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  int GenSize = int(sizeof(genIUType)) << int(3);

  ((Offset + Bits <= GenSize) ? static_cast<void> (0) : __assert_fail ("Offset + Bits <= GenSize", "/usr/include/glm/detail/func_integer.inl", 290, __PRETTY_FUNCTION__));

  genIUType ShiftLeft = Bits ? Value << (GenSize - (Bits + Offset)) : genIUType(0);
  genIUType ShiftBack = ShiftLeft >> genIUType(GenSize - Bits);

  return ShiftBack;
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> bitfieldExtract
 (
  detail::tvec2<T, P> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T, P>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> bitfieldExtract
 (
  detail::tvec3<T, P> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T, P>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits),
   bitfieldExtract(Value[2], Offset, Bits));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> bitfieldExtract
 (
  detail::tvec4<T, P> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T, P>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits),
   bitfieldExtract(Value[2], Offset, Bits),
   bitfieldExtract(Value[3], Offset, Bits));
 }


 template <typename genIUType>
 inline genIUType bitfieldInsert
 (
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");
  ((Offset + Bits <= sizeof(genIUType)) ? static_cast<void> (0) : __assert_fail ("Offset + Bits <= sizeof(genIUType)", "/usr/include/glm/detail/func_integer.inl", 351, __PRETTY_FUNCTION__));

  if(Bits == 0)
   return Base;

  genIUType Mask = 0;
  for(int Bit = Offset; Bit < Offset + Bits; ++Bit)
   Mask |= (1 << Bit);

  return (Base & ~Mask) | (Insert & Mask);
 }

 template <typename T, precision P>
 inline detail::tvec2<T, P> bitfieldInsert
 (
  detail::tvec2<T, P> const & Base,
  detail::tvec2<T, P> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T, P>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits));
 }

 template <typename T, precision P>
 inline detail::tvec3<T, P> bitfieldInsert
 (
  detail::tvec3<T, P> const & Base,
  detail::tvec3<T, P> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T, P>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits));
 }

 template <typename T, precision P>
 inline detail::tvec4<T, P> bitfieldInsert
 (
  detail::tvec4<T, P> const & Base,
  detail::tvec4<T, P> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T, P>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits),
   bitfieldInsert(Base[3], Insert[3], Offset, Bits));
 }


 template <typename genIUType>
 inline genIUType bitfieldReverse(genIUType const & Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

  genIUType Out = 0;
  std::size_t BitSize = sizeof(genIUType) * 8;
  for(std::size_t i = 0; i < BitSize; ++i)
   if(Value & (genIUType(1) << i))
    Out |= genIUType(1) << (BitSize - 1 - i);
  return Out;
 }

 template <typename T, precision P> inline detail::tvec2<T, P> bitfieldReverse( detail::tvec2<T, P> const & v) { return detail::tvec2<T, P>( bitfieldReverse(v.x), bitfieldReverse(v.y)); } template <typename T, precision P> inline detail::tvec3<T, P> bitfieldReverse( detail::tvec3<T, P> const & v) { return detail::tvec3<T, P>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z)); } template <typename T, precision P> inline detail::tvec4<T, P> bitfieldReverse( detail::tvec4<T, P> const & v) { return detail::tvec4<T, P>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z), bitfieldReverse(v.w)); }


 template <typename genIUType>
 inline int bitCount(genIUType const & Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

  int Count = 0;
  for(std::size_t i = 0; i < sizeof(genIUType) * std::size_t(8); ++i)
  {
   if(Value & (1 << i))
    ++Count;
  }
  return Count;
 }

 template <typename T, precision P>
 inline detail::tvec2<int, P> bitCount
 (
  detail::tvec2<T, P> const & value
 )
 {
  return detail::tvec2<int, P>(
   bitCount(value[0]),
   bitCount(value[1]));
 }

 template <typename T, precision P>
 inline detail::tvec3<int, P> bitCount
 (
  detail::tvec3<T, P> const & value
 )
 {
  return detail::tvec3<int, P>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]));
 }

 template <typename T, precision P>
 inline detail::tvec4<int, P> bitCount
 (
  detail::tvec4<T, P> const & value
 )
 {
  return detail::tvec4<int, P>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]),
   bitCount(value[3]));
 }


 template <typename genIUType>
 inline int findLSB
 (
  genIUType const & Value
 )
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");
  if(Value == 0)
   return -1;

  genIUType Bit;
  for(Bit = genIUType(0); !(Value & (1 << Bit)); ++Bit){}
  return Bit;
 }

 template <typename T, precision P>
 inline detail::tvec2<int, P> findLSB
 (
  detail::tvec2<T, P> const & value
 )
 {
  return detail::tvec2<int, P>(
   findLSB(value[0]),
   findLSB(value[1]));
 }

 template <typename T, precision P>
 inline detail::tvec3<int, P> findLSB
 (
  detail::tvec3<T, P> const & value
 )
 {
  return detail::tvec3<int, P>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]));
 }

 template <typename T, precision P>
 inline detail::tvec4<int, P> findLSB
 (
  detail::tvec4<T, P> const & value
 )
 {
  return detail::tvec4<int, P>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]),
   findLSB(value[3]));
 }
# 587 "/usr/include/glm/detail/func_integer.inl" 3 4
 template <typename genIUType>
 inline int findMSB
 (
  genIUType const & Value
 )
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  if(Value == genIUType(0) || Value == genIUType(-1))
   return -1;
  else if(Value > 0)
  {
   genIUType Bit = genIUType(-1);
   for(genIUType tmp = Value; tmp > 0; tmp >>= 1, ++Bit){}
   return Bit;
  }
  else
  {
   int const BitCount(sizeof(genIUType) * 8);
   int MostSignificantBit(-1);
   for(int BitIndex(0); BitIndex < BitCount; ++BitIndex)
    MostSignificantBit = (Value & (1 << BitIndex)) ? MostSignificantBit : BitIndex;
   ((MostSignificantBit >= 0) ? static_cast<void> (0) : __assert_fail ("MostSignificantBit >= 0", "/usr/include/glm/detail/func_integer.inl", 609, __PRETTY_FUNCTION__));
   return MostSignificantBit;
  }
 }


 template <typename T, precision P>
 inline detail::tvec2<int, P> findMSB
 (
  detail::tvec2<T, P> const & value
 )
 {
  return detail::tvec2<int, P>(
   findMSB(value[0]),
   findMSB(value[1]));
 }

 template <typename T, precision P>
 inline detail::tvec3<int, P> findMSB
 (
  detail::tvec3<T, P> const & value
 )
 {
  return detail::tvec3<int, P>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]));
 }

 template <typename T, precision P>
 inline detail::tvec4<int, P> findMSB
 (
  detail::tvec4<T, P> const & value
 )
 {
  return detail::tvec4<int, P>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]),
   findMSB(value[3]));
 }
}
# 201 "/usr/include/glm/detail/func_integer.hpp" 2 3 4
# 33 "/usr/include/glm/integer.hpp" 2 3 4
# 116 "/usr/include/glm/glm.hpp" 2 3 4
# 15 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/usr/include/glm/gtc/matrix_transform.hpp" 1 3 4
# 50 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
# 1 "/usr/include/glm/mat4x4.hpp" 1 3 4
# 51 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/vec2.hpp" 1 3 4
# 52 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/vec3.hpp" 1 3 4
# 53 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/vec4.hpp" 1 3 4
# 54 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4





namespace glm
{
# 84 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> translate(
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v);
# 100 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> rotate(
  detail::tmat4x4<T, P> const & m,
  T const & angle,
  detail::tvec3<T, P> const & axis);
# 116 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> scale(
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v);
# 132 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T, defaultp> ortho(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top,
  T const & zNear,
  T const & zFar);
# 150 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T>
 detail::tmat4x4<T, defaultp> ortho(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top);
# 167 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> frustum(
  T const & left,
  T const & right,
  T const & bottom,
  T const & top,
  T const & near,
  T const & far);
# 184 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> perspective(
  T const & fovy,
  T const & aspect,
  T const & near,
  T const & far);
# 200 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> perspectiveFov(
  T const & fov,
  T const & width,
  T const & height,
  T const & near,
  T const & far);
# 215 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> infinitePerspective(
  T fovy, T aspect, T near);
# 226 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 239 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, typename U, precision P>
 detail::tvec3<T, P> project(
  detail::tvec3<T, P> const & obj,
  detail::tmat4x4<T, P> const & model,
  detail::tmat4x4<T, P> const & proj,
  detail::tvec4<U, P> const & viewport);
# 255 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, typename U, precision P>
 detail::tvec3<T, P> unProject(
  detail::tvec3<T, P> const & win,
  detail::tmat4x4<T, P> const & model,
  detail::tmat4x4<T, P> const & proj,
  detail::tvec4<U, P> const & viewport);
# 270 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P, typename U>
 detail::tmat4x4<T, P> pickMatrix(
  detail::tvec2<T, P> const & center,
  detail::tvec2<T, P> const & delta,
  detail::tvec4<U, P> const & viewport);
# 283 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
 template <typename T, precision P>
 detail::tmat4x4<T, P> lookAt(
  detail::tvec3<T, P> const & eye,
  detail::tvec3<T, P> const & center,
  detail::tvec3<T, P> const & up);


}

# 1 "/usr/include/glm/gtc/matrix_transform.inl" 1 3 4
# 29 "/usr/include/glm/gtc/matrix_transform.inl" 3 4
# 1 "/usr/include/glm/geometric.hpp" 1 3 4
# 30 "/usr/include/glm/gtc/matrix_transform.inl" 2 3 4
# 1 "/usr/include/glm/trigonometric.hpp" 1 3 4
# 31 "/usr/include/glm/gtc/matrix_transform.inl" 2 3 4
# 1 "/usr/include/glm/matrix.hpp" 1 3 4
# 32 "/usr/include/glm/gtc/matrix_transform.inl" 2 3 4

namespace glm
{
 template <typename T, precision P>
 inline detail::tmat4x4<T, P> translate
 (
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v
 )
 {
  detail::tmat4x4<T, P> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }


 template <typename T, precision P>
 inline detail::tmat4x4<T, P> translate_slow
  (
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v
  )
 {
  detail::tmat4x4<T, P> Result(T(1));
  Result[3] = detail::tvec4<T, P>(v, T(1));
  return m * Result;


  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];





 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> rotate
 (
  detail::tmat4x4<T, P> const & m,
  T const & angle,
  detail::tvec3<T, P> const & v
 )
 {

  T a = angle;




  T c = cos(a);
  T s = sin(a);

  detail::tvec3<T, P> axis(normalize(v));
  detail::tvec3<T, P> temp((T(1) - c) * axis);

  detail::tmat4x4<T, P> Rotate(detail::tmat4x4<T, P>::_null);
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  detail::tmat4x4<T, P> Result(detail::tmat4x4<T, P>::_null);
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> rotate_slow
 (
  detail::tmat4x4<T, P> const & m,
  T const & angle,
  detail::tvec3<T, P> const & v
 )
 {

  T const a = angle;




  T c = cos(a);
  T s = sin(a);
  detail::tmat4x4<T, P> Result;

  detail::tvec3<T, P> axis = normalize(v);

  Result[0][0] = c + (1 - c) * axis.x * axis.x;
  Result[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = 0;

  Result[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (1 - c) * axis.y * axis.y;
  Result[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = 0;

  Result[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (1 - c) * axis.z * axis.z;
  Result[2][3] = 0;

  Result[3] = detail::tvec4<T, P>(0, 0, 0, 1);
  return m * Result;
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> scale
  (
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v
  )
 {
  detail::tmat4x4<T, P> Result(detail::tmat4x4<T, P>::_null);
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> scale_slow
 (
  detail::tmat4x4<T, P> const & m,
  detail::tvec3<T, P> const & v
 )
 {
  detail::tmat4x4<T, P> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template <typename T>
 inline detail::tmat4x4<T, defaultp> ortho
 (
  T const & left,
  T const & right,
  T const & bottom,
  T const & top,
  T const & zNear,
  T const & zFar
 )
 {
  detail::tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - T(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T, defaultp> ortho
 (
  T const & left,
  T const & right,
  T const & bottom,
  T const & top
 )
 {
  detail::tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - T(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType, defaultp> frustum
 (
  valType const & left,
  valType const & right,
  valType const & bottom,
  valType const & top,
  valType const & nearVal,
  valType const & farVal
 )
 {
  detail::tmat4x4<valType, defaultp> Result(0);
  Result[0][0] = (valType(2) * nearVal) / (right - left);
  Result[1][1] = (valType(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = -(farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = valType(-1);
  Result[3][2] = -(valType(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType, defaultp> perspective
 (
  valType const & fovy,
  valType const & aspect,
  valType const & zNear,
  valType const & zFar
 )
 {
  ((aspect != valType(0)) ? static_cast<void> (0) : __assert_fail ("aspect != valType(0)", "/usr/include/glm/gtc/matrix_transform.inl", 247, __PRETTY_FUNCTION__));
  ((zFar != zNear) ? static_cast<void> (0) : __assert_fail ("zFar != zNear", "/usr/include/glm/gtc/matrix_transform.inl", 248, __PRETTY_FUNCTION__));


  valType const rad = fovy;





  valType tanHalfFovy = tan(rad / valType(2));

  detail::tmat4x4<valType, defaultp> Result(valType(0));
  Result[0][0] = valType(1) / (aspect * tanHalfFovy);
  Result[1][1] = valType(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - valType(1);
  Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename valType>
 inline detail::tmat4x4<valType, defaultp> perspectiveFov
 (
  valType const & fov,
  valType const & width,
  valType const & height,
  valType const & zNear,
  valType const & zFar
 )
 {
  ((width > valType(0)) ? static_cast<void> (0) : __assert_fail ("width > valType(0)", "/usr/include/glm/gtc/matrix_transform.inl", 278, __PRETTY_FUNCTION__));
  ((height > valType(0)) ? static_cast<void> (0) : __assert_fail ("height > valType(0)", "/usr/include/glm/gtc/matrix_transform.inl", 279, __PRETTY_FUNCTION__));
  ((fov > valType(0)) ? static_cast<void> (0) : __assert_fail ("fov > valType(0)", "/usr/include/glm/gtc/matrix_transform.inl", 280, __PRETTY_FUNCTION__));


  valType rad = fov;




  valType h = glm::cos(valType(0.5) * rad) / glm::sin(valType(0.5) * rad);
  valType w = h * height / width;

  detail::tmat4x4<valType, defaultp> Result(valType(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - valType(1);
  Result[3][2] = - (valType(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T, defaultp> infinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {

  T const range = tan(fovy / T(2)) * zNear;




  T left = -range * aspect;
  T right = range * aspect;
  T bottom = -range;
  T top = range;

  detail::tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (T(2) * zNear) / (right - left);
  Result[1][1] = (T(2) * zNear) / (top - bottom);
  Result[2][2] = - T(1);
  Result[2][3] = - T(1);
  Result[3][2] = - T(2) * zNear;
  return Result;
 }

 template <typename T>
 inline detail::tmat4x4<T, defaultp> tweakedInfinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {

  T range = tan(fovy / T(2)) * zNear;




  T left = -range * aspect;
  T right = range * aspect;
  T bottom = -range;
  T top = range;

  detail::tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (T(2) * zNear) / (right - left);
  Result[1][1] = (T(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(0.0001) - T(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = - (T(0.0001) - T(2)) * zNear;
  return Result;
 }

 template <typename T, typename U, precision P>
 inline detail::tvec3<T, P> project
 (
  detail::tvec3<T, P> const & obj,
  detail::tmat4x4<T, P> const & model,
  detail::tmat4x4<T, P> const & proj,
  detail::tvec4<U, P> const & viewport
 )
 {
  detail::tvec4<T, P> tmp = detail::tvec4<T, P>(obj, T(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * T(0.5) + T(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return detail::tvec3<T, P>(tmp);
 }

 template <typename T, typename U, precision P>
 inline detail::tvec3<T, P> unProject
 (
  detail::tvec3<T, P> const & win,
  detail::tmat4x4<T, P> const & model,
  detail::tmat4x4<T, P> const & proj,
  detail::tvec4<U, P> const & viewport
 )
 {
  detail::tmat4x4<T, P> Inverse = inverse(proj * model);

  detail::tvec4<T, P> tmp = detail::tvec4<T, P>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * T(2) - T(1);

  detail::tvec4<T, P> obj = Inverse * tmp;
  obj /= obj.w;

  return detail::tvec3<T, P>(obj);
 }

 template <typename T, precision P, typename U>
 inline detail::tmat4x4<T, P> pickMatrix
 (
  detail::tvec2<T, P> const & center,
  detail::tvec2<T, P> const & delta,
  detail::tvec4<U, P> const & viewport
 )
 {
  ((delta.x > T(0) && delta.y > T(0)) ? static_cast<void> (0) : __assert_fail ("delta.x > T(0) && delta.y > T(0)", "/usr/include/glm/gtc/matrix_transform.inl", 407, __PRETTY_FUNCTION__));
  detail::tmat4x4<T, P> Result(1.0f);

  if(!(delta.x > T(0) && delta.y > T(0)))
   return Result;

  detail::tvec3<T, P> Temp(
   (T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,
   (T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,
   T(0));


  Result = translate(Result, Temp);
  return scale(Result, detail::tvec3<T, P>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> lookAt
 (
  detail::tvec3<T, P> const & eye,
  detail::tvec3<T, P> const & center,
  detail::tvec3<T, P> const & up
 )
 {
  detail::tvec3<T, P> f(normalize(center - eye));
  detail::tvec3<T, P> s(normalize(cross(f, up)));
  detail::tvec3<T, P> u(cross(s, f));

  detail::tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }
}
# 293 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 16 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/usr/include/glm/gtx/transform.hpp" 1 3 4
# 45 "/usr/include/glm/gtx/transform.hpp" 3 4
# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 78 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 29 "/usr/include/glm/detail/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 30 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 79 "/usr/include/glm/glm.hpp" 2 3 4
# 46 "/usr/include/glm/gtx/transform.hpp" 2 3 4
# 1 "/usr/include/glm/gtc/matrix_transform.hpp" 1 3 4
# 47 "/usr/include/glm/gtx/transform.hpp" 2 3 4





namespace glm
{






 template <typename T, precision P>
 detail::tmat4x4<T, P> translate(
  detail::tvec3<T, P> const & v);




 template <typename T, precision P>
 detail::tmat4x4<T, P> rotate(
  T angle,
  detail::tvec3<T, P> const & v);




 template <typename T, precision P>
 detail::tmat4x4<T, P> scale(
  detail::tvec3<T, P> const & v);


}

# 1 "/usr/include/glm/gtx/transform.inl" 1 3 4
# 10 "/usr/include/glm/gtx/transform.inl" 3 4
namespace glm
{
 template <typename T, precision P>
 inline detail::tmat4x4<T, P> translate(
  detail::tvec3<T, P> const & v)
 {
  return translate(
   detail::tmat4x4<T, P>(1.0f), v);
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> rotate(
  T angle,
  detail::tvec3<T, P> const & v)
 {
  return rotate(
   detail::tmat4x4<T, P>(1), angle, v);
 }

 template <typename T, precision P>
 inline detail::tmat4x4<T, P> scale(
  detail::tvec3<T, P> const & v)
 {
  return scale(
   detail::tmat4x4<T, P>(1.0f), v);
 }

}
# 83 "/usr/include/glm/gtx/transform.hpp" 2 3 4
# 17 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2


# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Shader.h" 1
# 11 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Shader.h"
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/ShaderGenerator.h" 1
# 10 "/home/joe/Github_Repos/CustomLibs/GL_Utils/ShaderGenerator.h"
# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 78 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 29 "/usr/include/glm/detail/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 30 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 79 "/usr/include/glm/glm.hpp" 2 3 4
# 11 "/home/joe/Github_Repos/CustomLibs/GL_Utils/ShaderGenerator.h" 2


# 1 "/home/joe/Github_Repos/CustomLibs/MISC/FileLoader.h" 1





# 1 "/usr/include/c++/4.8/fstream" 1 3
# 36 "/usr/include/c++/4.8/fstream" 3
       
# 37 "/usr/include/c++/4.8/fstream" 3



# 1 "/usr/include/c++/4.8/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/4.8/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/4.8/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/include/c++/4.8/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/include/c++/4.8/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/include/c++/4.8/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/include/c++/4.8/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/include/c++/4.8/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 275 "/usr/include/c++/4.8/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };



  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };



  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }

    protected:
      virtual
      ~codecvt_byname() { }
    };




  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);




}
# 41 "/usr/include/c++/4.8/fstream" 2 3
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3
# 42 "/usr/include/c++/4.8/fstream" 2 3
# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/basic_file.h" 1 3
# 37 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/basic_file.h" 3
       
# 38 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/basic_file.h" 3


# 1 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++io.h" 1 3
# 35 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++io.h" 3
# 1 "/usr/include/c++/4.8/cstdio" 1 3
# 39 "/usr/include/c++/4.8/cstdio" 3
       
# 40 "/usr/include/c++/4.8/cstdio" 3
# 36 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/include/x86_64-linux-gnu/c++/4.8/bits/basic_file.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();

      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);

      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/include/c++/4.8/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/4.8/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 133 "/usr/include/c++/4.8/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();




      virtual
      ~basic_filebuf()
      { this->close(); }





      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 269 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 279 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 296 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 328 "/usr/include/c++/4.8/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 348 "/usr/include/c++/4.8/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 394 "/usr/include/c++/4.8/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
  const bool __testin = _M_mode & ios_base::in;
  const bool __testout = _M_mode & ios_base::out;

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 426 "/usr/include/c++/4.8/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 453 "/usr/include/c++/4.8/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 466 "/usr/include/c++/4.8/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 482 "/usr/include/c++/4.8/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 498 "/usr/include/c++/4.8/fstream" 3
      ~basic_ifstream()
      { }
# 508 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 537 "/usr/include/c++/4.8/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 557 "/usr/include/c++/4.8/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 575 "/usr/include/c++/4.8/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 598 "/usr/include/c++/4.8/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 625 "/usr/include/c++/4.8/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 639 "/usr/include/c++/4.8/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 657 "/usr/include/c++/4.8/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out|ios_base::trunc)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 673 "/usr/include/c++/4.8/fstream" 3
      ~basic_ofstream()
      { }
# 683 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 712 "/usr/include/c++/4.8/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 733 "/usr/include/c++/4.8/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::out | ios_base::trunc)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 752 "/usr/include/c++/4.8/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 775 "/usr/include/c++/4.8/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 803 "/usr/include/c++/4.8/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 815 "/usr/include/c++/4.8/fstream" 3
      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }







      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 846 "/usr/include/c++/4.8/fstream" 3
      ~basic_fstream()
      { }
# 856 "/usr/include/c++/4.8/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 885 "/usr/include/c++/4.8/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 906 "/usr/include/c++/4.8/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 925 "/usr/include/c++/4.8/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };


}

# 1 "/usr/include/c++/4.8/bits/fstream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/fstream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/fstream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     _M_file.close();
     throw;
   }
 catch(...)
   { __testfail = true; }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             );
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = _M_mode & ios_base::out;
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
    if (overflow() == traits_type::eof())
      return __ret;
    _M_set_buffer(-1);
    _M_writing = false;
  }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
     && __testin)
   {

     const streamsize __avail = this->egptr() - this->gptr();
     if (__avail != 0)
       {
        traits_type::copy(__s, this->gptr(), __avail);
         __s += __avail;
        this->setg(this->eback(), this->gptr() + __avail,
     this->egptr());
        __ret += __avail;
        __n -= __avail;
       }



     streamsize __len;
     for (;;)
       {
         __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),
           __n);
         if (__len == -1)
    __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                                );
         if (__len == 0)
    break;

         __n -= __len;
         __ret += __len;
         if (__n == 0)
    break;

         __s += __len;
       }

     if (__n == 0)
       {
         _M_set_buffer(0);
         _M_reading = true;
       }
     else if (__len == 0)
       {



         _M_set_buffer(-1);
         _M_reading = false;
       }
   }
      else
   __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = _M_mode & ios_base::out;
      if (__check_facet(_M_codecvt).always_noconv()
     && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 700 "/usr/include/c++/4.8/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

        off_type __file_off = _M_file.seekoff(0, ios_base::cur);
        if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 937 "/usr/include/c++/4.8/fstream" 2 3
# 7 "/home/joe/Github_Repos/CustomLibs/MISC/FileLoader.h" 2
# 1 "/usr/include/c++/4.8/sstream" 1 3
# 36 "/usr/include/c++/4.8/sstream" 3
       
# 37 "/usr/include/c++/4.8/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 97 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 110 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
# 125 "/usr/include/c++/4.8/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 149 "/usr/include/c++/4.8/sstream" 3
      void
      str(const __string_type& __s)
      {

 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 201 "/usr/include/c++/4.8/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);
    };
# 271 "/usr/include/c++/4.8/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 307 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 325 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }
# 347 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 386 "/usr/include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 422 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 440 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }
# 462 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 501 "/usr/include/c++/4.8/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 536 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 552 "/usr/include/c++/4.8/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }
# 574 "/usr/include/c++/4.8/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };


}

# 1 "/usr/include/c++/4.8/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/4.8/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/4.8/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "/usr/include/c++/4.8/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 601 "/usr/include/c++/4.8/sstream" 2 3
# 8 "/home/joe/Github_Repos/CustomLibs/MISC/FileLoader.h" 2

std::string LoadFileToString(std::string filename) {
    std::ifstream shader(filename);
    std::stringstream buffer;
    buffer << shader.rdbuf();
    std::string src = buffer.str();
    return src;
}
# 14 "/home/joe/Github_Repos/CustomLibs/GL_Utils/ShaderGenerator.h" 2
# 1 "/home/joe/Github_Repos/CustomLibs/MISC/conio.h" 1



# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4
extern "C" {



# 1 "/usr/include/x86_64-linux-gnu/bits/termios.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;


struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) throw ();


extern speed_t cfgetispeed (const struct termios *__termios_p) throw ();


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) throw ();


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) throw ();



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) throw ();




extern int tcgetattr (int __fd, struct termios *__termios_p) throw ();



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) throw ();




extern void cfmakeraw (struct termios *__termios_p) throw ();



extern int tcsendbreak (int __fd, int __duration) throw ();





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) throw ();



extern int tcflow (int __fd, int __action) throw ();




extern __pid_t tcgetsid (int __fd) throw ();




# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4


}
# 5 "/home/joe/Github_Repos/CustomLibs/MISC/conio.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4
extern "C" {
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
# 345 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();


extern __pid_t getpgrp (void) throw ();


extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();






extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 48 "/usr/include/getopt.h" 3 4
extern "C" {
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
# 185 "/usr/include/getopt.h" 3 4
}
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1005 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) throw () ;
# 1026 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1091 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
# 1151 "/usr/include/unistd.h" 3 4
}
# 6 "/home/joe/Github_Repos/CustomLibs/MISC/conio.h" 2



int getch(void) {
    struct termios oldattr, newattr;
    int ch;
    tcgetattr( 0, &oldattr );
    newattr = oldattr;
    newattr.c_lflag &= ~( 0000002 | 0000010 );
    tcsetattr( 0, 0, &newattr );
    ch = getchar();
    tcsetattr( 0, 0, &oldattr );
    return ch;
}


int getche(void) {
    struct termios oldattr, newattr;
    int ch;
    tcgetattr( 0, &oldattr );
    newattr = oldattr;
    newattr.c_lflag &= ~( 0000002 );
    tcsetattr( 0, 0, &newattr );
    ch = getchar();
    tcsetattr( 0, 0, &oldattr );
    return ch;
}
# 15 "/home/joe/Github_Repos/CustomLibs/GL_Utils/ShaderGenerator.h" 2






enum ShaderType {
    VERTEX = 0, FRAGMENT = 1
};

class ShaderGenerator {
private:
    static std::string __directory;

public:

    static GLuint compile(std::string filename, ShaderType __type, bool __debug = true);


    static GLuint link(GLuint vertex_shader, GLuint fragment_shader);


    static GLuint createProgram(std::string vertex_shader_file, std::string fragment_shader_file);


    static void setDirectory(std::string directory);
};

std::string ShaderGenerator::__directory = std::string("");

void ShaderGenerator::setDirectory(std::string directory) {
    __directory = directory;
}

GLuint ShaderGenerator::compile(std::string filename, ShaderType __type, bool __debug) {
    filename = __directory + filename;

    if(__debug) {
        if(__type == ShaderType::VERTEX)
            std::cout << "Src: " << filename << "\nType: VERTEX\n";
        if(__type == ShaderType::FRAGMENT)
            std::cout << "Src: " << filename << "\nType: FRAGMENT\n";
    }

    GLuint shader_id;

    if(__type == ShaderType::VERTEX)
        shader_id = __glewCreateShader(0x8B31);
    else
        shader_id = __glewCreateShader(0x8B30);

    std::string contents = LoadFileToString(filename);

    char const* sourcePtr = (char*)contents.c_str();

    __glewShaderSource(shader_id, 1, &sourcePtr, __null);
    __glewCompileShader(shader_id);


    GLint result = 0;
    __glewGetShaderiv(shader_id, 0x8B81, &result);

    if(result == 0) {
        GLint log_length = 0;
        __glewGetShaderiv(shader_id, 0x8B84, &log_length);

        GLchar* error_log = new GLchar[log_length];
        __glewGetShaderInfoLog(shader_id, log_length, &log_length, error_log);

        std::cerr << "shader compile error: " << filename << std::endl;
        std::cerr << "Error log:\n    " << error_log << std::endl;
        std::cerr << "See INFO? y/n ";

        int ch = getch();

        if(ch == 'y') {
            std::cerr << std::endl << "OpenGL version: " << glGetString(0x1F02) << std::endl;
            std::cerr << "GLSL version:   " << glGetString(0x8B8C) << std::endl;
            std::cerr << "GL vendor:      " << glGetString(0x1F00) << std::endl;
            std::cerr << "GL renderer:    " << glGetString(0x1F01) << std::endl;

        } else {
            std::cerr << std::endl;
        }

        delete[] error_log;

        glfwTerminate();
        exit(-2);
    }

    return shader_id;
}

GLuint ShaderGenerator::link(GLuint vertex_shader, GLuint fragment_shader) {
    GLuint program_id = __glewCreateProgram();
    __glewAttachShader(program_id, vertex_shader);
    __glewAttachShader(program_id, fragment_shader);
    __glewLinkProgram(program_id);


    GLint result = 0;
    __glewGetProgramiv(program_id, 0x8B82, &result);

    if(result == 0) {
        GLint log_length = 0;
        __glewGetShaderiv(program_id, 0x8B84, &log_length);

        GLchar* error_log = new GLchar[log_length];
        std::cout << "shader program link error" << std::endl;
        std::cout << error_log << std::endl;
        delete[] error_log;

        glfwTerminate();
        exit(-2);
    }

    return program_id;
}

GLuint ShaderGenerator::createProgram(std::string vertex_shader_file, std::string fragment_shader_file) {
    GLuint vertexShader = compile(vertex_shader_file, ShaderType::VERTEX);
    GLuint fragmentShader = compile(fragment_shader_file, ShaderType::FRAGMENT);
    return link(vertexShader, fragmentShader);
}
# 12 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Shader.h" 2

namespace Util {

class Shader {
private:
    GLuint shader_program;
    GLuint vertex_shader;
    GLuint fragment_shader;

public:

    Shader(std::string loc_vertex_shader, std::string loc_fragment_shader);


    Shader(std::string _prefix, std::string loc_vertex_shader, std::string loc_fragment_shader);


    GLuint getFragmentShader(void) { return fragment_shader; }


    GLuint getVertexShader(void) { return vertex_shader; }


    GLuint getUniformLocation(std::string uniform_name);


    void bind(void);
};

Shader::Shader(std::string loc_vertex_shader, std::string loc_fragment_shader) {
    ShaderGenerator::setDirectory("");

    vertex_shader = ShaderGenerator::compile(loc_vertex_shader, ShaderType::VERTEX);
    fragment_shader = ShaderGenerator::compile(loc_fragment_shader, ShaderType::FRAGMENT);

    shader_program = ShaderGenerator::link(vertex_shader, fragment_shader);
}

Shader::Shader(std::string _prefix, std::string loc_vertex_shader, std::string loc_fragment_shader) {
    ShaderGenerator::setDirectory(_prefix);

    vertex_shader = ShaderGenerator::compile(loc_vertex_shader, ShaderType::VERTEX);
    fragment_shader = ShaderGenerator::compile(loc_fragment_shader, ShaderType::FRAGMENT);

    shader_program = ShaderGenerator::link(vertex_shader, fragment_shader);
}

void Shader::bind(void) {
    __glewUseProgram(shader_program);
}

GLuint Shader::getUniformLocation(std::string uniform_name) {
    return __glewGetUniformLocation(shader_program, (char*)uniform_name.c_str());
}

}
# 20 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/InitGlfw.h" 1
# 9 "/home/joe/Github_Repos/CustomLibs/GL_Utils/InitGlfw.h"
# 1 "/home/joe/Github_Repos/CustomLibs/MISC/RandomNumber.h" 1







int getRandomNumber(void) {
    static int i = 0;
    if(i == 0) {
        srand(time(__null));
        i = 1;
    }
    return rand();
}
# 10 "/home/joe/Github_Repos/CustomLibs/GL_Utils/InitGlfw.h" 2


GLFWwindow* GLFW_Init(int width, int height, std::string window_title, int v_major, int v_minor, GLboolean forward_compat);


GLfloat randColor(void);





GLFWwindow* GLFW_Init(int width, int height, std::string window_title, int v_major, int v_minor, GLboolean forward_compat) {
    if(!glfwInit()) {
        std::cerr << "Failed to initialize GLFW3" << std::endl;
        exit(-1);
    } else {
        std::cout << "GLFW3! ";
    }

    glfwWindowHint(0x0002100D, 4);
    glfwWindowHint(0x00022002, v_major);
    glfwWindowHint(0x00022003, v_minor);
    glfwWindowHint(0x00022006,forward_compat);
    glfwWindowHint(0x00022008, 0x00032001);

    GLFWwindow* window = glfwCreateWindow(width, height, window_title.c_str(), __null, __null);

    if(!window) {
        std::cerr << "Failed to open GLFW window" << std::endl;
        glfwTerminate();
        exit(-1);
    } else {
        std::cout << "WINDOW! ";
    }

    glfwMakeContextCurrent(window);
    glewExperimental = 1;

    if(glewInit() != 0) {
        std::cerr << "Failed to initialize GLEW" << std::endl;
        exit(-1);
    } else {
        std::cout << "GLEW! ";
    }

    std::cout << "GO!" << std::endl;

    glfwSetInputMode(window, 0x00033002, 1);

    return window;
}


GLfloat randColor(void) {
    int r = getRandomNumber();
    r = r % 1001;
    float r_f = (float)r;
    return r_f / 1000;
}
# 21 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Texture.h" 1
# 11 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Texture.h"
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/TextureLoader.h" 1
# 10 "/home/joe/Github_Repos/CustomLibs/GL_Utils/TextureLoader.h"
# 1 "/usr/include/IL/il.h" 1 3 4
# 25 "/usr/include/IL/il.h" 3 4
extern "C" {
# 76 "/usr/include/IL/il.h" 3 4
typedef unsigned int ILenum;
typedef unsigned char ILboolean;
typedef unsigned int ILbitfield;
typedef signed char ILbyte;
typedef signed short ILshort;
typedef int ILint;
typedef size_t ILsizei;
typedef unsigned char ILubyte;
typedef unsigned short ILushort;
typedef unsigned int ILuint;
typedef float ILfloat;
typedef float ILclampf;
typedef double ILdouble;
typedef double ILclampd;





typedef long long int ILint64;
typedef long long unsigned int ILuint64;



# 1 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed/limits.h" 1 3 4
# 101 "/usr/include/IL/il.h" 2 3 4
# 502 "/usr/include/IL/il.h" 3 4
typedef void* ILHANDLE;
typedef void ( *fCloseRProc)(ILHANDLE);
typedef ILboolean ( *fEofProc) (ILHANDLE);
typedef ILint ( *fGetcProc) (ILHANDLE);
typedef ILHANDLE ( *fOpenRProc) (char const *);
typedef ILint ( *fReadProc) (void*, ILuint, ILuint, ILHANDLE);
typedef ILint ( *fSeekRProc) (ILHANDLE, ILint, ILint);
typedef ILint ( *fTellRProc) (ILHANDLE);


typedef void ( *fCloseWProc)(ILHANDLE);
typedef ILHANDLE ( *fOpenWProc) (char const *);
typedef ILint ( *fPutcProc) (ILubyte, ILHANDLE);
typedef ILint ( *fSeekWProc) (ILHANDLE, ILint, ILint);
typedef ILint ( *fTellWProc) (ILHANDLE);
typedef ILint ( *fWriteProc) (const void*, ILuint, ILuint, ILHANDLE);


typedef void* ( *mAlloc)(const ILsizei);
typedef void ( *mFree) (const void* const);


typedef ILenum ( *IL_LOADPROC)(char const *);
typedef ILenum ( *IL_SAVEPROC)(char const *);



 ILboolean ilActiveFace(ILuint Number);
 ILboolean ilActiveImage(ILuint Number);
 ILboolean ilActiveLayer(ILuint Number);
 ILboolean ilActiveMipmap(ILuint Number);
 ILboolean ilApplyPal(char const * FileName);
 ILboolean ilApplyProfile(char* InProfile, char* OutProfile);
 void ilBindImage(ILuint Image);
 ILboolean ilBlit(ILuint Source, ILint DestX, ILint DestY, ILint DestZ, ILuint SrcX, ILuint SrcY, ILuint SrcZ, ILuint Width, ILuint Height, ILuint Depth);
 ILboolean ilClampNTSC(void);
 void ilClearColour(ILclampf Red, ILclampf Green, ILclampf Blue, ILclampf Alpha);
 ILboolean ilClearImage(void);
 ILuint ilCloneCurImage(void);
 ILubyte* ilCompressDXT(ILubyte *Data, ILuint Width, ILuint Height, ILuint Depth, ILenum DXTCFormat, ILuint *DXTCSize);
 ILboolean ilCompressFunc(ILenum Mode);
 ILboolean ilConvertImage(ILenum DestFormat, ILenum DestType);
 ILboolean ilConvertPal(ILenum DestFormat);
 ILboolean ilCopyImage(ILuint Src);
 ILuint ilCopyPixels(ILuint XOff, ILuint YOff, ILuint ZOff, ILuint Width, ILuint Height, ILuint Depth, ILenum Format, ILenum Type, void *Data);
 ILuint ilCreateSubImage(ILenum Type, ILuint Num);
 ILboolean ilDefaultImage(void);
 void ilDeleteImage(const ILuint Num);
 void ilDeleteImages(ILsizei Num, const ILuint *Images);
 ILenum ilDetermineType(char const * FileName);
 ILenum ilDetermineTypeF(ILHANDLE File);
 ILenum ilDetermineTypeL(const void *Lump, ILuint Size);
 ILboolean ilDisable(ILenum Mode);
 ILboolean ilDxtcDataToImage(void);
 ILboolean ilDxtcDataToSurface(void);
 ILboolean ilEnable(ILenum Mode);
 void ilFlipSurfaceDxtcData(void);
 ILboolean ilFormatFunc(ILenum Mode);
 void ilGenImages(ILsizei Num, ILuint *Images);
 ILuint ilGenImage(void);
 ILubyte* ilGetAlpha(ILenum Type);
 ILboolean ilGetBoolean(ILenum Mode);
 void ilGetBooleanv(ILenum Mode, ILboolean *Param);
 ILubyte* ilGetData(void);
 ILuint ilGetDXTCData(void *Buffer, ILuint BufferSize, ILenum DXTCFormat);
 ILenum ilGetError(void);
 ILint ilGetInteger(ILenum Mode);
 void ilGetIntegerv(ILenum Mode, ILint *Param);
 ILuint ilGetLumpPos(void);
 ILubyte* ilGetPalette(void);
 char const * ilGetString(ILenum StringName);
 void ilHint(ILenum Target, ILenum Mode);
 ILboolean ilInvertSurfaceDxtcDataAlpha(void);
 void ilInit(void);
 ILboolean ilImageToDxtcData(ILenum Format);
 ILboolean ilIsDisabled(ILenum Mode);
 ILboolean ilIsEnabled(ILenum Mode);
 ILboolean ilIsImage(ILuint Image);
 ILboolean ilIsValid(ILenum Type, char const * FileName);
 ILboolean ilIsValidF(ILenum Type, ILHANDLE File);
 ILboolean ilIsValidL(ILenum Type, void *Lump, ILuint Size);
 void ilKeyColour(ILclampf Red, ILclampf Green, ILclampf Blue, ILclampf Alpha);
 ILboolean ilLoad(ILenum Type, char const * FileName);
 ILboolean ilLoadF(ILenum Type, ILHANDLE File);
 ILboolean ilLoadImage(char const * FileName);
 ILboolean ilLoadL(ILenum Type, const void *Lump, ILuint Size);
 ILboolean ilLoadPal(char const * FileName);
 void ilModAlpha(ILdouble AlphaValue);
 ILboolean ilOriginFunc(ILenum Mode);
 ILboolean ilOverlayImage(ILuint Source, ILint XCoord, ILint YCoord, ILint ZCoord);
 void ilPopAttrib(void);
 void ilPushAttrib(ILuint Bits);
 void ilRegisterFormat(ILenum Format);
 ILboolean ilRegisterLoad(char const * Ext, IL_LOADPROC Load);
 ILboolean ilRegisterMipNum(ILuint Num);
 ILboolean ilRegisterNumFaces(ILuint Num);
 ILboolean ilRegisterNumImages(ILuint Num);
 void ilRegisterOrigin(ILenum Origin);
 void ilRegisterPal(void *Pal, ILuint Size, ILenum Type);
 ILboolean ilRegisterSave(char const * Ext, IL_SAVEPROC Save);
 void ilRegisterType(ILenum Type);
 ILboolean ilRemoveLoad(char const * Ext);
 ILboolean ilRemoveSave(char const * Ext);
 void ilResetMemory(void);
 void ilResetRead(void);
 void ilResetWrite(void);
 ILboolean ilSave(ILenum Type, char const * FileName);
 ILuint ilSaveF(ILenum Type, ILHANDLE File);
 ILboolean ilSaveImage(char const * FileName);
 ILuint ilSaveL(ILenum Type, void *Lump, ILuint Size);
 ILboolean ilSavePal(char const * FileName);
 ILboolean ilSetAlpha(ILdouble AlphaValue);
 ILboolean ilSetData(void *Data);
 ILboolean ilSetDuration(ILuint Duration);
 void ilSetInteger(ILenum Mode, ILint Param);
 void ilSetMemory(mAlloc, mFree);
 void ilSetPixels(ILint XOff, ILint YOff, ILint ZOff, ILuint Width, ILuint Height, ILuint Depth, ILenum Format, ILenum Type, void *Data);
 void ilSetRead(fOpenRProc, fCloseRProc, fEofProc, fGetcProc, fReadProc, fSeekRProc, fTellRProc);
 void ilSetString(ILenum Mode, const char *String);
 void ilSetWrite(fOpenWProc, fCloseWProc, fPutcProc, fSeekWProc, fTellWProc, fWriteProc);
 void ilShutDown(void);
 ILboolean ilSurfaceToDxtcData(ILenum Format);
 ILboolean ilTexImage(ILuint Width, ILuint Height, ILuint Depth, ILubyte NumChannels, ILenum Format, ILenum Type, void *Data);
 ILboolean ilTexImageDxtc(ILint w, ILint h, ILint d, ILenum DxtFormat, const ILubyte* data);
 ILenum ilTypeFromExt(char const * FileName);
 ILboolean ilTypeFunc(ILenum Mode);
 ILboolean ilLoadData(char const * FileName, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
 ILboolean ilLoadDataF(ILHANDLE File, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
 ILboolean ilLoadDataL(void *Lump, ILuint Size, ILuint Width, ILuint Height, ILuint Depth, ILubyte Bpp);
 ILboolean ilSaveData(char const * FileName);
# 640 "/usr/include/IL/il.h" 3 4
}
# 11 "/home/joe/Github_Repos/CustomLibs/GL_Utils/TextureLoader.h" 2
# 1 "/usr/include/IL/ilu.h" 1 3 4
# 27 "/usr/include/IL/ilu.h" 3 4
extern "C" {
# 105 "/usr/include/IL/ilu.h" 3 4
typedef struct ILinfo
{
 ILuint Id;
 ILubyte *Data;
 ILuint Width;
 ILuint Height;
 ILuint Depth;
 ILubyte Bpp;
 ILuint SizeOfData;
 ILenum Format;
 ILenum Type;
 ILenum Origin;
 ILubyte *Palette;
 ILenum PalType;
 ILuint PalSize;
 ILenum CubeFlags;
 ILuint NumNext;
 ILuint NumMips;
 ILuint NumLayers;
} ILinfo;


typedef struct ILpointf {
 ILfloat x;
 ILfloat y;
} ILpointf;

typedef struct ILpointi {
 ILint x;
 ILint y;
} ILpointi;

 ILboolean iluAlienify(void);
 ILboolean iluBlurAvg(ILuint Iter);
 ILboolean iluBlurGaussian(ILuint Iter);
 ILboolean iluBuildMipmaps(void);
 ILuint iluColoursUsed(void);
 ILboolean iluCompareImage(ILuint Comp);
 ILboolean iluContrast(ILfloat Contrast);
 ILboolean iluCrop(ILuint XOff, ILuint YOff, ILuint ZOff, ILuint Width, ILuint Height, ILuint Depth);
 void iluDeleteImage(ILuint Id);
 ILboolean iluEdgeDetectE(void);
 ILboolean iluEdgeDetectP(void);
 ILboolean iluEdgeDetectS(void);
 ILboolean iluEmboss(void);
 ILboolean iluEnlargeCanvas(ILuint Width, ILuint Height, ILuint Depth);
 ILboolean iluEnlargeImage(ILfloat XDim, ILfloat YDim, ILfloat ZDim);
 ILboolean iluEqualize(void);
 char const * iluErrorString(ILenum Error);
 ILboolean iluConvolution(ILint *matrix, ILint scale, ILint bias);
 ILboolean iluFlipImage(void);
 ILboolean iluGammaCorrect(ILfloat Gamma);
 ILuint iluGenImage(void);
 void iluGetImageInfo(ILinfo *Info);
 ILint iluGetInteger(ILenum Mode);
 void iluGetIntegerv(ILenum Mode, ILint *Param);
 char* iluGetString(ILenum StringName);
 void iluImageParameter(ILenum PName, ILenum Param);
 void iluInit(void);
 ILboolean iluInvertAlpha(void);
 ILuint iluLoadImage(char const * FileName);
 ILboolean iluMirror(void);
 ILboolean iluNegative(void);
 ILboolean iluNoisify(ILclampf Tolerance);
 ILboolean iluPixelize(ILuint PixSize);
 void iluRegionfv(ILpointf *Points, ILuint n);
 void iluRegioniv(ILpointi *Points, ILuint n);
 ILboolean iluReplaceColour(ILubyte Red, ILubyte Green, ILubyte Blue, ILfloat Tolerance);
 ILboolean iluRotate(ILfloat Angle);
 ILboolean iluRotate3D(ILfloat x, ILfloat y, ILfloat z, ILfloat Angle);
 ILboolean iluSaturate1f(ILfloat Saturation);
 ILboolean iluSaturate4f(ILfloat r, ILfloat g, ILfloat b, ILfloat Saturation);
 ILboolean iluScale(ILuint Width, ILuint Height, ILuint Depth);
 ILboolean iluScaleAlpha(ILfloat scale);
 ILboolean iluScaleColours(ILfloat r, ILfloat g, ILfloat b);
 ILboolean iluSetLanguage(ILenum Language);
 ILboolean iluSharpen(ILfloat Factor, ILuint Iter);
 ILboolean iluSwapColours(void);
 ILboolean iluWave(ILfloat Angle);







}
# 12 "/home/joe/Github_Repos/CustomLibs/GL_Utils/TextureLoader.h" 2
# 1 "/usr/include/IL/ilut.h" 1 3 4
# 225 "/usr/include/IL/ilut.h" 3 4
extern "C" {



 ILboolean ilutDisable(ILenum Mode);
 ILboolean ilutEnable(ILenum Mode);
 ILboolean ilutGetBoolean(ILenum Mode);
 void ilutGetBooleanv(ILenum Mode, ILboolean *Param);
 ILint ilutGetInteger(ILenum Mode);
 void ilutGetIntegerv(ILenum Mode, ILint *Param);
 char* ilutGetString(ILenum StringName);
 void ilutInit(void);
 ILboolean ilutIsDisabled(ILenum Mode);
 ILboolean ilutIsEnabled(ILenum Mode);
 void ilutPopAttrib(void);
 void ilutPushAttrib(ILuint Bits);
 void ilutSetInteger(ILenum Mode, ILint Param);

 ILboolean ilutRenderer(ILenum Renderer);




 GLuint ilutGLBindTexImage();
 GLuint ilutGLBindMipmaps(void);
 ILboolean ilutGLBuildMipmaps(void);
 GLuint ilutGLLoadImage(char* FileName);
 ILboolean ilutGLScreen(void);
 ILboolean ilutGLScreenie(void);
 ILboolean ilutGLSaveImage(char* FileName, GLuint TexID);
 ILboolean ilutGLSubTex2D(GLuint TexID, ILuint XOff, ILuint YOff);
 ILboolean ilutGLSubTex3D(GLuint TexID, ILuint XOff, ILuint YOff, ILuint ZOff);
 ILboolean ilutGLSetTex2D(GLuint TexID);
 ILboolean ilutGLSetTex3D(GLuint TexID);
 ILboolean ilutGLTexImage(GLuint Level);
 ILboolean ilutGLSubTex(GLuint TexID, ILuint XOff, ILuint YOff);

 ILboolean ilutGLSetTex(GLuint TexID);
 ILboolean ilutGLSubTex(GLuint TexID, ILuint XOff, ILuint YOff);
# 386 "/usr/include/IL/ilut.h" 3 4
}
# 13 "/home/joe/Github_Repos/CustomLibs/GL_Utils/TextureLoader.h" 2

class TextureLoader {
private:

    static GLuint __texture_handle;

    static bool __inited;

public:

    static void InitIL(void);

    static void load(std::string filename);

    static GLuint getTextureID(void);
};


bool TextureLoader::__inited = false;
GLuint TextureLoader::__texture_handle = 0;

void TextureLoader::load(std::string filename) {
    if(__inited)
        __texture_handle = ilutGLLoadImage((char*)filename.c_str());
    else {
        std::cerr << "TextureLoader: DevIL not initialized\n";
        std::cerr << "\tCall TextureLoader::InitIL\n";
        exit(-1);
    }
}

void TextureLoader::InitIL(void) {

    ilInit();
    iluInit();
    ilutInit();
    ilutRenderer(0);
    __inited = true;
}

GLuint TextureLoader::getTextureID(void) {
    return __texture_handle;
}
# 12 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Texture.h" 2

namespace Util {

class Texture {
private:
    GLuint texture_id;

public:

    Texture(std::string filename);


    Texture(std::string prefix, std::string filename);

    void bind(void);

    GLuint getID(void) { return texture_id; }
};

Texture::Texture(std::string filename) {
    TextureLoader::load(filename);
    texture_id = TextureLoader::getTextureID();
}

Texture::Texture(std::string prefix, std::string filename) {
    TextureLoader::load(prefix + filename);
    texture_id = TextureLoader::getTextureID();
}

void Texture::bind(void) {
    glBindTexture(0x0DE1, texture_id);
}

}
# 22 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Camera.h" 1







# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 78 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 29 "/usr/include/glm/detail/_fixes.hpp" 3 4
# 1 "/usr/include/c++/4.8/cmath" 1 3 4
# 39 "/usr/include/c++/4.8/cmath" 3 4
       
# 40 "/usr/include/c++/4.8/cmath" 3
# 30 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 79 "/usr/include/glm/glm.hpp" 2 3 4
# 9 "/home/joe/Github_Repos/CustomLibs/GL_Utils/Camera.h" 2



namespace Util {

class Camera {
private:
    glm::vec3 _loc;
    glm::vec3 _look;
    glm::vec3 _up;

public:

    Camera(void);


    void setLocation(glm::vec3 _loc);


    void setLookingAt(glm::vec3 _look);


    void setUp(glm::vec3 _up);


    glm::mat4 getViewTf(void);
};

Camera::Camera(void) {
    this->_up = glm::vec3(0, 1, 0);
}

void Camera::setLocation(glm::vec3 _loc) {
    this->_loc = _loc;
}

void Camera::setLookingAt(glm::vec3 _look) {
    this->_look = _look;
}

void Camera::setUp(glm::vec3 _up) {
    this->_up = _up;
}

glm::mat4 Camera::getViewTf(void) {
    return glm::lookAt(_loc, _look, _up);
}

}
# 23 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/VAO.h" 1







namespace Util {

class VertexArrayObject {
private:

    GLuint __vao = 0;

public:

    VertexArrayObject(void);


    void bind(void);


    void enableAttribute(int __index);


    void disableAttribute(int __index);
};

VertexArrayObject::VertexArrayObject(void) {
    __glewGenVertexArrays(1, &__vao);
}

void VertexArrayObject::bind(void) {
    __glewBindVertexArray(__vao);
}

void VertexArrayObject::enableAttribute(int __index) {
    __glewEnableVertexAttribArray(__index);
}

void VertexArrayObject::disableAttribute(int __index) {
    __glewDisableVertexAttribArray(__index);
}

}
# 24 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2
# 1 "/home/joe/Github_Repos/CustomLibs/GL_Utils/VBO.h" 1
# 12 "/home/joe/Github_Repos/CustomLibs/GL_Utils/VBO.h"
namespace Util {

class VertexBufferObject {
private:

    GLuint __vbo = 0;


    int __attrib_index;
    int __element_size;
    int __def_type;
    GLboolean __normalized = 0;

public:

    VertexBufferObject(void);


    void bufferData(const void* data, int __size);


    GLuint getID(void) { return __vbo; }


    void bind(void);


    void setAttribPtrData(int index, int element_size, int def_type, GLboolean normalized = 0);


    void generateAttribPointer(void);
};

VertexBufferObject::VertexBufferObject(void) {
    __glewGenBuffers(1, &__vbo);
}

void VertexBufferObject::bufferData(const void* data, int __size) {
    __glewBufferData(0x8892, __size, data, 0x88E4);
}

void VertexBufferObject::bind(void) {
    __glewBindBuffer(0x8892, __vbo);
}

void VertexBufferObject::setAttribPtrData(int index, int element_size, int def_type, GLboolean normalized) {
    this->__attrib_index = index;
    this->__element_size = element_size;
    this->__def_type = def_type;
    this->__normalized = normalized;
}

void VertexBufferObject::generateAttribPointer(void) {
    __glewVertexAttribPointer(
        __attrib_index,
        __element_size,
        __def_type,
        __normalized,
        0, 0
    );
}

}
# 25 "/home/joe/Github_Repos/opengl-projects/TextureMapping/main.cpp" 2



const int window_width = 640;
const int window_height = 480;

using namespace std;

int main(int argc, char* argv[]) {

    GLFWwindow* window = GLFW_Init(window_width, window_height, "TextureMapping", 3, 3, 1);
    TextureLoader::InitIL();

    glEnable(0x0B71);

    glDepthFunc(0x0201);
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);

    string res_loc("../assets/shader/");
    string img_loc("../assets/img/");

    Util::Shader shader_color(res_loc, "vtx_color.glsl", "frag_color.glsl");
    Util::Shader shader_texture(res_loc, "vtx_texture.glsl", "frag_texture.glsl");

    Util::Texture IMG_plant(img_loc, "shaggy.bmp");
    IMG_plant.bind();

    glTexParameterf(0x0DE1, 0x2801, 0x2601);
    glTexParameterf(0x0DE1, 0x2800, 0x2601);
    glTexParameteri(0x0DE1,0x2802,0x812F);
    glTexParameteri(0x0DE1,0x2803,0x812F);

    Util::Camera cam;
    cam.setLocation(glm::vec3(4.0f, 3.0f, 1.0f));
    cam.setLookingAt(glm::vec3(0.0f, 0.0f, 0.0f));


    static const GLfloat g_vertex_buffer_data[] = {
        -1.0f, -1.0f, 0.0f,
        1.0f, -1.0f, 0.0f,
        0.0f, 1.0f, 0.0f,
    };


    static GLfloat g_color_buffer_data[9];
    for(int i = 0; i < 9; i++)
        g_color_buffer_data[i] = randColor();


    static GLfloat g_uv_buffer_data[6] = {
        0.0f, 0.0f,
        1.0f, 0.0f,
        1.0f, 1.0f
    };


    Util::VertexArrayObject vao;
    vao.bind();

        Util::VertexBufferObject vbo_pos;
        vbo_pos.bind();
        vbo_pos.bufferData(g_vertex_buffer_data, 9*sizeof(GLfloat));
        vbo_pos.setAttribPtrData(0, 3, 0x1406);


        Util::VertexBufferObject vbo_col;
        vbo_col.bind();
        vbo_col.bufferData(g_color_buffer_data, 9*sizeof(GLfloat));
        vbo_col.setAttribPtrData(1, 3, 0x1406);


        Util::VertexBufferObject vbo_uv;
        vbo_uv.bind();
        vbo_uv.bufferData(g_uv_buffer_data, 6*sizeof(GLfloat));
        vbo_uv.setAttribPtrData(2, 2, 0x1406);


    glm::mat4 Projection = glm::perspective(glm::radians(30.0f), ((float)window_width/(float)window_height), 0.1f, 100.0f);
    glm::mat4 View = cam.getViewTf();




    glm::mat4 Model = glm::mat4(1.0f);
    glm::mat4 mvp = Projection * View * Model;


    GLuint MatrixID = shader_texture.getUniformLocation("MVP");
    GLuint SamplerID = shader_texture.getUniformLocation("TEX");

    do {
        glClear(0x00004000 | 0x00000100);

        vao.bind();


        shader_texture.bind();


        __glewUniformMatrix4fv(MatrixID, 1, 0, &mvp[0][0]);

        __glewActiveTexture(0x84C0);
        IMG_plant.bind();
        __glewUniform1i(SamplerID, 0);

        vao.enableAttribute(0);
        vbo_pos.bind();
        vbo_pos.generateAttribPointer();

        vao.enableAttribute(1);
        vbo_col.bind();
        vbo_col.generateAttribPointer();

        vao.enableAttribute(2);
        vbo_uv.bind();
        vbo_uv.generateAttribPointer();

        glDrawArrays(0x0004, 0, 3);

        vao.disableAttribute(0);
        vao.disableAttribute(1);
        vao.disableAttribute(2);

        glfwSwapBuffers(window);
        glfwPollEvents();

    } while(glfwGetKey(window, 256) != 1 &&
            glfwWindowShouldClose(window) == 0);

    glfwTerminate();
    return 0;
}
